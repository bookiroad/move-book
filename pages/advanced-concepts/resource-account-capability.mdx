# ğŸ” Resource Account & Capability

Movement Networkì˜ ê³ ê¸‰ ê¶Œí•œ ê´€ë¦¬ ì‹œìŠ¤í…œì¸ Resource Accountì™€ Capability íŒ¨í„´ì„ ì‹¬í™” í•™ìŠµí•©ë‹ˆë‹¤. í”„ë¡œê·¸ë˜ë° ê°€ëŠ¥í•œ ê³„ì •ê³¼ ì„¸ë°€í•œ ê¶Œí•œ ì œì–´ë¡œ ë³´ì•ˆì„±ê³¼ ìœ ì—°ì„±ì„ ë™ì‹œì— í™•ë³´í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- Resource Accountì˜ ê°œë…ê³¼ ìƒì„± ë°©ë²•ì„ ì™„ì „íˆ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Capability ê¸°ë°˜ ê¶Œí•œ ì œì–´ ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ê³  êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë‹¤ì¤‘ ì„œëª…ê³¼ ì‹œê°„ ê¸°ë°˜ ê¶Œí•œì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë³µì¡í•œ ê¶Œí•œ ìœ„ì„ ì²´ê³„ë¥¼ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ¢ Resource Account ì‹¬í™”

### Resource Accountë€?
```
Resource Account = í”„ë¡œê·¸ë˜ë° ê°€ëŠ¥í•œ ê³„ì •

ì¼ë°˜ ê³„ì • (EOA):
â”œâ”€â”€ ê°œì¸ í‚¤ë¡œ ì œì–´
â”œâ”€â”€ ì‚¬ëŒì´ ì§ì ‘ ì„œëª…
â”œâ”€â”€ ë‹¨ìˆœí•œ ê¶Œí•œ êµ¬ì¡°
â””â”€â”€ ì œí•œì ì¸ ìë™í™”

Resource Account:
â”œâ”€â”€ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ìœ¼ë¡œ ì œì–´  
â”œâ”€â”€ í”„ë¡œê·¸ë˜ë°ëœ ë¡œì§ìœ¼ë¡œ ì„œëª…
â”œâ”€â”€ ë³µì¡í•œ ê¶Œí•œ ìœ„ì„ ê°€ëŠ¥
â””â”€â”€ ì™„ì „í•œ ìë™í™” ì§€ì›
```

### Resource Account ìƒì„±ê³¼ ê´€ë¦¬
```move
module resource_account_manager {
    use std::signer;
    use std::vector;
    use std::string::{Self, String};
    use aptos_framework::account::{Self, SignerCapability};
    use aptos_framework::resource_account;
    use aptos_framework::timestamp;
    
    /// Resource Account ë ˆì§€ìŠ¤íŠ¸ë¦¬
    struct ResourceAccountRegistry has key {
        accounts: SmartTable<String, ResourceAccountInfo>,
        total_created: u64,
        admin: address
    }
    
    struct ResourceAccountInfo has store, drop {
        address: address,
        creator: address,
        purpose: String,
        created_at: u64,
        signer_cap: SignerCapability,
        permissions: vector<Permission>,
        is_active: bool
    }
    
    struct Permission has store, drop, copy {
        permission_type: u8,  // 0: transfer, 1: module_publish, 2: admin
        allowed_addresses: vector<address>,
        expiry: Option<u64>
    }
    
    /// Resource Account ìƒì„± (ê³ ê¸‰ íŒ¨í„´)
    public fun create_managed_resource_account(
        creator: &signer,
        seed: vector<u8>,
        purpose: String,
        initial_permissions: vector<Permission>
    ): address acquires ResourceAccountRegistry {
        let creator_addr = signer::address_of(creator);
        
        // Resource Account ìƒì„±
        let (resource_signer, signer_cap) = account::create_resource_account(
            creator,
            seed
        );
        let resource_addr = signer::address_of(&resource_signer);
        
        // ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì—…ë°ì´íŠ¸
        let registry = borrow_global_mut<ResourceAccountRegistry>(@admin);
        let account_name = generate_account_name(purpose, registry.total_created);
        
        let account_info = ResourceAccountInfo {
            address: resource_addr,
            creator: creator_addr,
            purpose,
            created_at: timestamp::now_seconds(),
            signer_cap,
            permissions: initial_permissions,
            is_active: true
        };
        
        smart_table::add(&mut registry.accounts, account_name, account_info);
        registry.total_created = registry.total_created + 1;
        
        // ì´ˆê¸° ì„¤ì • ìˆ˜í–‰
        initialize_resource_account(&resource_signer, initial_permissions);
        
        resource_addr
    }
    
    /// Resource Accountë¥¼ í†µí•œ í”„ë¡œê·¸ë˜ë°ëœ íŠ¸ëœì­ì…˜ ì‹¤í–‰
    public fun execute_as_resource_account<T>(
        executor: &signer,
        account_name: String,
        operation: |&signer|T
    ): T acquires ResourceAccountRegistry {
        let executor_addr = signer::address_of(executor);
        let registry = borrow_global<ResourceAccountRegistry>(@admin);
        
        assert!(smart_table::contains(&registry.accounts, account_name), E_ACCOUNT_NOT_FOUND);
        let account_info = smart_table::borrow(&registry.accounts, account_name);
        
        // ê¶Œí•œ í™•ì¸
        assert!(has_permission(account_info, executor_addr, EXECUTE_PERMISSION), E_NO_PERMISSION);
        assert!(account_info.is_active, E_ACCOUNT_INACTIVE);
        
        // Resource Accountì˜ signer ìƒì„±
        let resource_signer = account::create_signer_with_capability(&account_info.signer_cap);
        
        // í”„ë¡œê·¸ë˜ë°ëœ ì‘ì—… ì‹¤í–‰
        operation(&resource_signer)
    }
    
    /// ë°°ì¹˜ íŠ¸ëœì­ì…˜ ì‹¤í–‰ (ê°€ìŠ¤ íš¨ìœ¨ì )
    public fun batch_execute_as_resource_account(
        executor: &signer,
        account_name: String,
        operations: vector<BatchOperation>
    ) acquires ResourceAccountRegistry {
        let registry = borrow_global<ResourceAccountRegistry>(@admin);
        let account_info = smart_table::borrow(&registry.accounts, account_name);
        let resource_signer = account::create_signer_with_capability(&account_info.signer_cap);
        
        // ë°°ì¹˜ë¡œ ì‘ì—… ì‹¤í–‰
        while (!vector::is_empty(&operations)) {
            let op = vector::pop_back(&mut operations);
            execute_batch_operation(&resource_signer, op);
        };
        
        vector::destroy_empty(operations);
    }
    
    /// ë™ì  ê¶Œí•œ ê´€ë¦¬
    public fun update_account_permissions(
        admin: &signer,
        account_name: String,
        new_permissions: vector<Permission>
    ) acquires ResourceAccountRegistry {
        assert!(signer::address_of(admin) == @admin, E_NOT_ADMIN);
        
        let registry = borrow_global_mut<ResourceAccountRegistry>(@admin);
        let account_info = smart_table::borrow_mut(&mut registry.accounts, account_name);
        
        account_info.permissions = new_permissions;
        
        // ê¶Œí•œ ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
        emit_permission_changed_event(account_info.address, new_permissions);
    }
    
    /// Resource Account ìƒíƒœ ê´€ë¦¬
    public fun set_account_status(
        admin: &signer,
        account_name: String,
        active: bool
    ) acquires ResourceAccountRegistry {
        assert!(signer::address_of(admin) == @admin, E_NOT_ADMIN);
        
        let registry = borrow_global_mut<ResourceAccountRegistry>(@admin);
        let account_info = smart_table::borrow_mut(&mut registry.accounts, account_name);
        
        account_info.is_active = active;
    }
    
    struct BatchOperation has drop {
        operation_type: u8,
        target: address,
        data: vector<u8>
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun generate_account_name(purpose: String, counter: u64): String {
        let name = string::utf8(b"");
        string::append(&mut name, purpose);
        string::append_utf8(&mut name, b"_");
        string::append_utf8(&mut name, to_string(counter));
        name
    }
    
    fun has_permission(account_info: &ResourceAccountInfo, addr: address, perm_type: u8): bool {
        let i = 0;
        let len = vector::length(&account_info.permissions);
        
        while (i < len) {
            let permission = vector::borrow(&account_info.permissions, i);
            if (permission.permission_type == perm_type) {
                // ë§Œë£Œ ì‹œê°„ ì²´í¬
                if (option::is_some(&permission.expiry)) {
                    let expiry = *option::borrow(&permission.expiry);
                    if (timestamp::now_seconds() > expiry) {
                        i = i + 1;
                        continue
                    }
                };
                
                // ì£¼ì†Œ í™•ì¸
                if (vector::contains(&permission.allowed_addresses, &addr)) {
                    return true
                }
            };
            i = i + 1;
        };
        
        false
    }
}
```

## ğŸ­ Capability íŒ¨í„´ ì‹¬í™”

### Capability ê¸°ë°˜ ê¶Œí•œ ì œì–´
```move
module capability_system {
    use std::signer;
    use aptos_framework::timestamp;
    use std::option::{Self, Option};
    
    /// ê¸°ë³¸ Capability êµ¬ì¡°
    struct Capability<phantom T> has store {
        // phantom TëŠ” capabilityì˜ íƒ€ì…ì„ ë‚˜íƒ€ëƒ„
    }
    
    /// ê´€ë¦¬ì ê¶Œí•œ
    struct AdminCapability has key, store {}
    
    /// ë¯¼íŒ… ê¶Œí•œ  
    struct MintCapability<phantom CoinType> has key, store {
        max_amount: Option<u64>,
        daily_limit: Option<u64>,
        last_mint_day: u64,
        today_minted: u64
    }
    
    /// ì†Œê° ê¶Œí•œ
    struct BurnCapability<phantom CoinType> has key, store {}
    
    /// ì‹œê°„ ì œí•œ ê¶Œí•œ
    struct TimedCapability<T: store> has key, store {
        capability: T,
        start_time: u64,
        end_time: u64,
        max_uses: Option<u64>,
        current_uses: u64
    }
    
    /// ë‹¤ì¤‘ ì„œëª… ê¶Œí•œ
    struct MultiSigCapability<T: store> has key, store {
        capability: T,
        required_signatures: u64,
        authorized_signers: vector<address>,
        pending_operations: SmartTable<u64, PendingOperation<T>>,
        operation_counter: u64
    }
    
    struct PendingOperation<T: store> has store {
        operation_data: T,
        signatures: vector<address>,
        created_at: u64,
        expires_at: u64
    }
    
    /// Capability ë°œê¸‰ ì‹œìŠ¤í…œ
    public fun issue_mint_capability<CoinType>(
        admin: &signer,
        recipient: address,
        max_amount: Option<u64>,
        daily_limit: Option<u64>
    ) {
        // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
        assert!(has_admin_capability(signer::address_of(admin)), E_NOT_ADMIN);
        
        let mint_cap = MintCapability<CoinType> {
            max_amount,
            daily_limit,
            last_mint_day: get_current_day(),
            today_minted: 0
        };
        
        move_to<MintCapability<CoinType>>(&create_signer(recipient), mint_cap);
    }
    
    /// ì‹œê°„ ì œí•œ Capability ìƒì„±
    public fun create_timed_capability<T: store>(
        base_capability: T,
        duration_seconds: u64,
        max_uses: Option<u64>
    ): TimedCapability<T> {
        let current_time = timestamp::now_seconds();
        
        TimedCapability {
            capability: base_capability,
            start_time: current_time,
            end_time: current_time + duration_seconds,
            max_uses,
            current_uses: 0
        }
    }
    
    /// ì‹œê°„ ì œí•œ Capability ì‚¬ìš©
    public fun use_timed_capability<T: store>(
        timed_cap: &mut TimedCapability<T>
    ): &T {
        let current_time = timestamp::now_seconds();
        
        // ì‹œê°„ ë²”ìœ„ í™•ì¸
        assert!(current_time >= timed_cap.start_time, E_TOO_EARLY);
        assert!(current_time <= timed_cap.end_time, E_EXPIRED);
        
        // ì‚¬ìš© íšŸìˆ˜ í™•ì¸
        if (option::is_some(&timed_cap.max_uses)) {
            let max = *option::borrow(&timed_cap.max_uses);
            assert!(timed_cap.current_uses < max, E_USAGE_EXCEEDED);
        };
        
        timed_cap.current_uses = timed_cap.current_uses + 1;
        &timed_cap.capability
    }
    
    /// ë‹¤ì¤‘ ì„œëª… Capability ìƒì„±
    public fun create_multisig_capability<T: store>(
        base_capability: T,
        required_signatures: u64,
        authorized_signers: vector<address>
    ): MultiSigCapability<T> {
        assert!(required_signatures > 0, E_INVALID_THRESHOLD);
        assert!(required_signatures <= vector::length(&authorized_signers), E_THRESHOLD_TOO_HIGH);
        
        MultiSigCapability {
            capability: base_capability,
            required_signatures,
            authorized_signers,
            pending_operations: smart_table::new(),
            operation_counter: 0
        }
    }
    
    /// ë‹¤ì¤‘ ì„œëª… ì‘ì—… ì œì•ˆ
    public fun propose_multisig_operation<T: store + copy>(
        proposer: &signer,
        multisig_cap: &mut MultiSigCapability<T>,
        operation_data: T,
        expiry_seconds: u64
    ): u64 {
        let proposer_addr = signer::address_of(proposer);
        assert!(vector::contains(&multisig_cap.authorized_signers, &proposer_addr), E_NOT_AUTHORIZED);
        
        let operation_id = multisig_cap.operation_counter;
        multisig_cap.operation_counter = multisig_cap.operation_counter + 1;
        
        let current_time = timestamp::now_seconds();
        let pending_op = PendingOperation {
            operation_data,
            signatures: vector::singleton(proposer_addr),  // ì œì•ˆìëŠ” ìë™ ì„œëª…
            created_at: current_time,
            expires_at: current_time + expiry_seconds
        };
        
        smart_table::add(&mut multisig_cap.pending_operations, operation_id, pending_op);
        operation_id
    }
    
    /// ë‹¤ì¤‘ ì„œëª… ì‘ì—…ì— ì„œëª…
    public fun sign_multisig_operation<T: store + copy>(
        signer: &signer,
        multisig_cap: &mut MultiSigCapability<T>,
        operation_id: u64
    ): bool {
        let signer_addr = signer::address_of(signer);
        assert!(vector::contains(&multisig_cap.authorized_signers, &signer_addr), E_NOT_AUTHORIZED);
        assert!(smart_table::contains(&multisig_cap.pending_operations, operation_id), E_OPERATION_NOT_FOUND);
        
        let pending_op = smart_table::borrow_mut(&mut multisig_cap.pending_operations, operation_id);
        
        // ë§Œë£Œ í™•ì¸
        assert!(timestamp::now_seconds() <= pending_op.expires_at, E_OPERATION_EXPIRED);
        
        // ì¤‘ë³µ ì„œëª… ë°©ì§€
        assert!(!vector::contains(&pending_op.signatures, &signer_addr), E_ALREADY_SIGNED);
        
        // ì„œëª… ì¶”ê°€
        vector::push_back(&mut pending_op.signatures, signer_addr);
        
        // í•„ìš”í•œ ì„œëª… ìˆ˜ ë‹¬ì„± í™•ì¸
        vector::length(&pending_op.signatures) >= multisig_cap.required_signatures
    }
    
    /// ë‹¤ì¤‘ ì„œëª… ì‘ì—… ì‹¤í–‰
    public fun execute_multisig_operation<T: store + copy>(
        executor: &signer,
        multisig_cap: &mut MultiSigCapability<T>,
        operation_id: u64
    ): T {
        assert!(smart_table::contains(&multisig_cap.pending_operations, operation_id), E_OPERATION_NOT_FOUND);
        
        let pending_op = smart_table::borrow(&multisig_cap.pending_operations, operation_id);
        
        // ì¶©ë¶„í•œ ì„œëª… í™•ì¸
        assert!(
            vector::length(&pending_op.signatures) >= multisig_cap.required_signatures,
            E_INSUFFICIENT_SIGNATURES
        );
        
        // ë§Œë£Œ í™•ì¸
        assert!(timestamp::now_seconds() <= pending_op.expires_at, E_OPERATION_EXPIRED);
        
        // ì‘ì—… ë°ì´í„° ë³µì‚¬ ë° ì •ë¦¬
        let operation_data = pending_op.operation_data;
        smart_table::remove(&mut multisig_cap.pending_operations, operation_id);
        
        operation_data
    }
    
    /// Capability ìœ„ì„ ì‹œìŠ¤í…œ
    struct DelegatedCapability<T: store> has key, store {
        original_capability: T,
        delegate: address,
        permissions: vector<u8>,  // ìœ„ì„ëœ ê¶Œí•œ ëª©ë¡
        start_time: u64,
        end_time: u64,
        revocable: bool
    }
    
    /// Capability ìœ„ì„
    public fun delegate_capability<T: store>(
        owner: &signer,
        capability: T,
        delegate: address,
        permissions: vector<u8>,
        duration_seconds: u64,
        revocable: bool
    ) {
        let current_time = timestamp::now_seconds();
        let delegated_cap = DelegatedCapability {
            original_capability: capability,
            delegate,
            permissions,
            start_time: current_time,
            end_time: current_time + duration_seconds,
            revocable
        };
        
        move_to(&create_signer(delegate), delegated_cap);
    }
    
    /// ìœ„ì„ëœ Capability ì‚¬ìš©
    public fun use_delegated_capability<T: store>(
        delegate: &signer,
        permission_type: u8
    ): &T acquires DelegatedCapability {
        let delegate_addr = signer::address_of(delegate);
        assert!(exists<DelegatedCapability<T>>(delegate_addr), E_NO_DELEGATED_CAPABILITY);
        
        let delegated_cap = borrow_global<DelegatedCapability<T>>(delegate_addr);
        
        // ì‹œê°„ í™•ì¸
        let current_time = timestamp::now_seconds();
        assert!(current_time >= delegated_cap.start_time, E_TOO_EARLY);
        assert!(current_time <= delegated_cap.end_time, E_EXPIRED);
        
        // ê¶Œí•œ í™•ì¸
        assert!(vector::contains(&delegated_cap.permissions, &permission_type), E_PERMISSION_DENIED);
        
        &delegated_cap.original_capability
    }
    
    /// Capability íšŒìˆ˜
    public fun revoke_delegated_capability<T: store>(
        owner: &signer,
        delegate: address
    ): T acquires DelegatedCapability {
        let delegated_cap = move_from<DelegatedCapability<T>>(delegate);
        assert!(delegated_cap.revocable, E_NOT_REVOCABLE);
        
        delegated_cap.original_capability
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun get_current_day(): u64 {
        timestamp::now_seconds() / 86400  // 24 * 60 * 60
    }
    
    fun has_admin_capability(addr: address): bool {
        exists<AdminCapability>(addr)
    }
    
    fun create_signer(addr: address): signer {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì ì ˆí•œ signer ìƒì„± ë¡œì§ í•„ìš”
        abort 0  // placeholder
    }
}
```

## ğŸª ê³ ê¸‰ ê¶Œí•œ íŒ¨í„´

### ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ (RBAC)
```move
module rbac_system {
    use std::signer;
    use std::vector;
    use std::string::String;
    use aptos_std::smart_table::{Self, SmartTable};
    use aptos_framework::timestamp;
    
    /// RBAC ì‹œìŠ¤í…œ ë©”ì¸ êµ¬ì¡°
    struct RBACSystem has key {
        roles: SmartTable<String, Role>,
        user_roles: SmartTable<address, vector<String>>,
        permissions: SmartTable<String, Permission>,
        role_permissions: SmartTable<String, vector<String>>,
        admin: address
    }
    
    struct Role has store, drop, copy {
        name: String,
        description: String,
        is_active: bool,
        created_at: u64,
        max_holders: Option<u64>,
        current_holders: u64
    }
    
    struct Permission has store, drop, copy {
        name: String,
        resource: String,      // ë¦¬ì†ŒìŠ¤ ì‹ë³„ì
        action: String,        // ì‘ì—… ìœ í˜•
        conditions: vector<Condition>
    }
    
    struct Condition has store, drop, copy {
        condition_type: u8,    // 0: time, 1: amount, 2: frequency
        operator: u8,          // 0: eq, 1: gt, 2: lt, 3: between
        values: vector<u64>
    }
    
    /// RBAC ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    public fun initialize_rbac(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        
        move_to(admin, RBACSystem {
            roles: smart_table::new(),
            user_roles: smart_table::new(),
            permissions: smart_table::new(),
            role_permissions: smart_table::new(),
            admin: admin_addr
        });
        
        // ê¸°ë³¸ ê´€ë¦¬ì ì—­í•  ìƒì„±
        create_default_admin_role(admin_addr);
    }
    
    /// ì—­í•  ìƒì„±
    public fun create_role(
        admin: &signer,
        role_name: String,
        description: String,
        max_holders: Option<u64>
    ) acquires RBACSystem {
        let admin_addr = signer::address_of(admin);
        let rbac = borrow_global_mut<RBACSystem>(@rbac_admin);
        
        assert!(rbac.admin == admin_addr, E_NOT_ADMIN);
        assert!(!smart_table::contains(&rbac.roles, role_name), E_ROLE_EXISTS);
        
        let role = Role {
            name: role_name,
            description,
            is_active: true,
            created_at: timestamp::now_seconds(),
            max_holders,
            current_holders: 0
        };
        
        smart_table::add(&mut rbac.roles, role_name, role);
        smart_table::add(&mut rbac.role_permissions, role_name, vector::empty());
    }
    
    /// ê¶Œí•œ ìƒì„±
    public fun create_permission(
        admin: &signer,
        permission_name: String,
        resource: String,
        action: String,
        conditions: vector<Condition>
    ) acquires RBACSystem {
        let rbac = borrow_global_mut<RBACSystem>(@rbac_admin);
        assert!(rbac.admin == signer::address_of(admin), E_NOT_ADMIN);
        
        let permission = Permission {
            name: permission_name,
            resource,
            action,
            conditions
        };
        
        smart_table::add(&mut rbac.permissions, permission_name, permission);
    }
    
    /// ì—­í• ì— ê¶Œí•œ í• ë‹¹
    public fun assign_permission_to_role(
        admin: &signer,
        role_name: String,
        permission_name: String
    ) acquires RBACSystem {
        let rbac = borrow_global_mut<RBACSystem>(@rbac_admin);
        assert!(rbac.admin == signer::address_of(admin), E_NOT_ADMIN);
        
        // ì—­í• ê³¼ ê¶Œí•œ ì¡´ì¬ í™•ì¸
        assert!(smart_table::contains(&rbac.roles, role_name), E_ROLE_NOT_FOUND);
        assert!(smart_table::contains(&rbac.permissions, permission_name), E_PERMISSION_NOT_FOUND);
        
        let role_perms = smart_table::borrow_mut(&mut rbac.role_permissions, role_name);
        if (!vector::contains(role_perms, &permission_name)) {
            vector::push_back(role_perms, permission_name);
        }
    }
    
    /// ì‚¬ìš©ìì—ê²Œ ì—­í•  í• ë‹¹
    public fun assign_role_to_user(
        admin: &signer,
        user: address,
        role_name: String
    ) acquires RBACSystem {
        let rbac = borrow_global_mut<RBACSystem>(@rbac_admin);
        assert!(rbac.admin == signer::address_of(admin), E_NOT_ADMIN);
        
        // ì—­í•  ì¡´ì¬ ë° í™œì„± ìƒíƒœ í™•ì¸
        assert!(smart_table::contains(&rbac.roles, role_name), E_ROLE_NOT_FOUND);
        let role = smart_table::borrow_mut(&mut rbac.roles, role_name);
        assert!(role.is_active, E_ROLE_INACTIVE);
        
        // ìµœëŒ€ ë³´ìœ ì ìˆ˜ í™•ì¸
        if (option::is_some(&role.max_holders)) {
            let max = *option::borrow(&role.max_holders);
            assert!(role.current_holders < max, E_ROLE_FULL);
        };
        
        // ì‚¬ìš©ì ì—­í•  ëª©ë¡ ì—…ë°ì´íŠ¸
        if (!smart_table::contains(&rbac.user_roles, user)) {
            smart_table::add(&mut rbac.user_roles, user, vector::empty());
        };
        
        let user_roles = smart_table::borrow_mut(&mut rbac.user_roles, user);
        if (!vector::contains(user_roles, &role_name)) {
            vector::push_back(user_roles, role_name);
            role.current_holders = role.current_holders + 1;
        }
    }
    
    /// ê¶Œí•œ í™•ì¸ (í•µì‹¬ í•¨ìˆ˜)
    public fun check_permission(
        user: address,
        resource: String,
        action: String,
        context: vector<u64>  // ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸ (ì‹œê°„, ì–‘ ë“±)
    ): bool acquires RBACSystem {
        let rbac = borrow_global<RBACSystem>(@rbac_admin);
        
        // ì‚¬ìš©ì ì—­í•  í™•ì¸
        if (!smart_table::contains(&rbac.user_roles, user)) {
            return false
        };
        
        let user_roles = smart_table::borrow(&rbac.user_roles, user);
        let i = 0;
        let roles_len = vector::length(user_roles);
        
        // ê° ì—­í• ì— ëŒ€í•´ ê¶Œí•œ í™•ì¸
        while (i < roles_len) {
            let role_name = vector::borrow(user_roles, i);
            
            if (smart_table::contains(&rbac.role_permissions, *role_name)) {
                let role_perms = smart_table::borrow(&rbac.role_permissions, *role_name);
                
                if (check_role_permissions(rbac, role_perms, &resource, &action, &context)) {
                    return true
                }
            };
            
            i = i + 1;
        };
        
        false
    }
    
    /// ì—­í• ë³„ ê¶Œí•œ í™•ì¸
    fun check_role_permissions(
        rbac: &RBACSystem,
        role_permissions: &vector<String>,
        resource: &String,
        action: &String,
        context: &vector<u64>
    ): bool {
        let i = 0;
        let perms_len = vector::length(role_permissions);
        
        while (i < perms_len) {
            let perm_name = vector::borrow(role_permissions, i);
            
            if (smart_table::contains(&rbac.permissions, *perm_name)) {
                let permission = smart_table::borrow(&rbac.permissions, *perm_name);
                
                // ë¦¬ì†ŒìŠ¤ì™€ ì•¡ì…˜ ë§¤ì¹­
                if (permission.resource == *resource && permission.action == *action) {
                    // ì¡°ê±´ í™•ì¸
                    if (check_permission_conditions(&permission.conditions, context)) {
                        return true
                    }
                }
            };
            
            i = i + 1;
        };
        
        false
    }
    
    /// ê¶Œí•œ ì¡°ê±´ í™•ì¸
    fun check_permission_conditions(
        conditions: &vector<Condition>,
        context: &vector<u64>
    ): bool {
        let i = 0;
        let conditions_len = vector::length(conditions);
        
        while (i < conditions_len) {
            let condition = vector::borrow(conditions, i);
            
            if (!evaluate_condition(condition, context)) {
                return false  // í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ì „ì²´ ì‹¤íŒ¨
            };
            
            i = i + 1;
        };
        
        true  // ëª¨ë“  ì¡°ê±´ í†µê³¼
    }
    
    /// ê°œë³„ ì¡°ê±´ í‰ê°€
    fun evaluate_condition(condition: &Condition, context: &vector<u64>): bool {
        if (condition.condition_type == 0) {  // ì‹œê°„ ì¡°ê±´
            let current_time = timestamp::now_seconds();
            let start_time = *vector::borrow(&condition.values, 0);
            let end_time = *vector::borrow(&condition.values, 1);
            
            current_time >= start_time && current_time <= end_time
        } else if (condition.condition_type == 1) {  // ì–‘ ì¡°ê±´
            if (vector::is_empty(context)) return false;
            
            let amount = *vector::borrow(context, 0);
            let limit = *vector::borrow(&condition.values, 0);
            
            match (condition.operator) {
                0 => amount == limit,      // equal
                1 => amount > limit,       // greater than
                2 => amount < limit,       // less than
                _ => false
            }
        } else {
            true  // ê¸°íƒ€ ì¡°ê±´ì€ í†µê³¼
        }
    }
    
    /// ì‚¬ìš©ì ê¶Œí•œ ê°ì‚¬
    public fun audit_user_permissions(user: address): vector<String> acquires RBACSystem {
        let rbac = borrow_global<RBACSystem>(@rbac_admin);
        let all_permissions = vector::empty();
        
        if (!smart_table::contains(&rbac.user_roles, user)) {
            return all_permissions
        };
        
        let user_roles = smart_table::borrow(&rbac.user_roles, user);
        let i = 0;
        
        while (i < vector::length(user_roles)) {
            let role_name = vector::borrow(user_roles, i);
            
            if (smart_table::contains(&rbac.role_permissions, *role_name)) {
                let role_perms = smart_table::borrow(&rbac.role_permissions, *role_name);
                
                // ì¤‘ë³µ ì œê±°í•˜ë©´ì„œ ê¶Œí•œ ì¶”ê°€
                let j = 0;
                while (j < vector::length(role_perms)) {
                    let perm = *vector::borrow(role_perms, j);
                    if (!vector::contains(&all_permissions, &perm)) {
                        vector::push_back(&mut all_permissions, perm);
                    };
                    j = j + 1;
                }
            };
            
            i = i + 1;
        };
        
        all_permissions
    }
    
    fun create_default_admin_role(admin_addr: address) {
        // ê¸°ë³¸ ê´€ë¦¬ì ì—­í•  ìƒì„± ë¡œì§
    }
}
```

### ë™ì  ê¶Œí•œ ê´€ë¦¬ ì‹œìŠ¤í…œ
```move
module dynamic_permissions {
    use std::signer;
    use aptos_framework::timestamp;
    use aptos_std::smart_table::{Self, SmartTable};
    
    /// ë™ì  ê¶Œí•œ ê´€ë¦¬ì
    struct DynamicPermissionManager has key {
        permission_rules: SmartTable<String, PermissionRule>,
        user_contexts: SmartTable<address, UserContext>,
        rule_counter: u64
    }
    
    struct PermissionRule has store, drop {
        rule_id: String,
        conditions: vector<RuleCondition>,
        actions: vector<RuleAction>,
        priority: u64,
        is_active: bool
    }
    
    struct RuleCondition has store, drop {
        condition_type: u8,  // 0: balance, 1: time, 2: frequency, 3: location
        operator: u8,
        threshold: u64,
        timeframe: Option<u64>
    }
    
    struct RuleAction has store, drop {
        action_type: u8,  // 0: grant, 1: revoke, 2: limit, 3: notify
        permission: String,
        duration: Option<u64>,
        parameters: vector<u64>
    }
    
    struct UserContext has store, drop {
        last_activity: u64,
        activity_count: u64,
        risk_score: u64,
        temporary_permissions: SmartTable<String, u64>  // permission -> expiry
    }
    
    /// ë™ì  ê·œì¹™ ìƒì„±
    public fun create_dynamic_rule(
        admin: &signer,
        rule_name: String,
        conditions: vector<RuleCondition>,
        actions: vector<RuleAction>,
        priority: u64
    ) acquires DynamicPermissionManager {
        let manager = borrow_global_mut<DynamicPermissionManager>(@permission_admin);
        
        let rule = PermissionRule {
            rule_id: rule_name,
            conditions,
            actions,
            priority,
            is_active: true
        };
        
        smart_table::add(&mut manager.permission_rules, rule_name, rule);
    }
    
    /// ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
    public fun update_user_context(
        user: address,
        activity_type: u8,
        additional_data: vector<u64>
    ) acquires DynamicPermissionManager {
        let manager = borrow_global_mut<DynamicPermissionManager>(@permission_admin);
        
        if (!smart_table::contains(&manager.user_contexts, user)) {
            smart_table::add(&mut manager.user_contexts, user, UserContext {
                last_activity: 0,
                activity_count: 0,
                risk_score: 0,
                temporary_permissions: smart_table::new()
            });
        };
        
        let context = smart_table::borrow_mut(&mut manager.user_contexts, user);
        context.last_activity = timestamp::now_seconds();
        context.activity_count = context.activity_count + 1;
        
        // ìœ„í—˜ ì ìˆ˜ ê³„ì‚° (í™œë™ íŒ¨í„´ ê¸°ë°˜)
        context.risk_score = calculate_risk_score(context, activity_type, additional_data);
        
        // ë™ì  ê·œì¹™ í‰ê°€ ë° ì ìš©
        evaluate_and_apply_rules(manager, user, context);
    }
    
    /// ë™ì  ê¶Œí•œ í™•ì¸
    public fun check_dynamic_permission(
        user: address,
        permission: String,
        context_data: vector<u64>
    ): bool acquires DynamicPermissionManager {
        let manager = borrow_global<DynamicPermissionManager>(@permission_admin);
        
        // ê¸°ë³¸ ê¶Œí•œ í™•ì¸
        let has_static_permission = check_static_permission(user, permission);
        
        // ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ í™•ì¸
        if (!smart_table::contains(&manager.user_contexts, user)) {
            return has_static_permission
        };
        
        let user_context = smart_table::borrow(&manager.user_contexts, user);
        
        // ì„ì‹œ ê¶Œí•œ í™•ì¸
        if (smart_table::contains(&user_context.temporary_permissions, permission)) {
            let expiry = *smart_table::borrow(&user_context.temporary_permissions, permission);
            if (timestamp::now_seconds() <= expiry) {
                return true
            }
        };
        
        // ë™ì  ê·œì¹™ ê¸°ë°˜ ê¶Œí•œ í™•ì¸
        let dynamic_permission = evaluate_dynamic_rules(manager, user, user_context, permission, context_data);
        
        has_static_permission || dynamic_permission
    }
    
    /// ìœ„í—˜ ì ìˆ˜ ê³„ì‚°
    fun calculate_risk_score(
        context: &UserContext,
        activity_type: u8,
        additional_data: vector<u64>
    ): u64 {
        let base_score = context.risk_score;
        let current_time = timestamp::now_seconds();
        
        // í™œë™ ë¹ˆë„ ê¸°ë°˜ ì ìˆ˜ ì¡°ì •
        let time_since_last = current_time - context.last_activity;
        let frequency_multiplier = if (time_since_last < 60) {  // 1ë¶„ ë¯¸ë§Œ
            150  // 1.5ë°°
        } else if (time_since_last < 3600) {  // 1ì‹œê°„ ë¯¸ë§Œ
            100  // 1.0ë°°
        } else {
            50   // 0.5ë°°
        };
        
        // í™œë™ ìœ í˜•ë³„ ìœ„í—˜ë„
        let activity_risk = match (activity_type) {
            0 => 10,  // ì¼ë°˜ ì¡°íšŒ
            1 => 30,  // í† í° ì „ì†¡
            2 => 50,  // ê³ ì•¡ ê±°ë˜
            3 => 80,  // ê´€ë¦¬ì ì‘ì—…
            _ => 20   // ê¸°íƒ€
        };
        
        let new_score = (base_score + activity_risk) * frequency_multiplier / 100;
        
        // ìµœëŒ€ê°’ ì œí•œ
        if (new_score > 1000) {
            1000
        } else {
            new_score
        }
    }
    
    /// ë™ì  ê·œì¹™ í‰ê°€ ë° ì ìš©
    fun evaluate_and_apply_rules(
        manager: &mut DynamicPermissionManager,
        user: address,
        user_context: &mut UserContext
    ) {
        // ëª¨ë“  í™œì„± ê·œì¹™ì„ ìš°ì„ ìˆœìœ„ìˆœìœ¼ë¡œ í‰ê°€
        let rule_names = get_sorted_rule_names(manager);
        let i = 0;
        
        while (i < vector::length(&rule_names)) {
            let rule_name = vector::borrow(&rule_names, i);
            let rule = smart_table::borrow(&manager.permission_rules, *rule_name);
            
            if (rule.is_active && evaluate_rule_conditions(&rule.conditions, user_context)) {
                apply_rule_actions(&rule.actions, user_context);
            };
            
            i = i + 1;
        }
    }
    
    fun get_sorted_rule_names(manager: &DynamicPermissionManager): vector<String> {
        // ê·œì¹™ì„ ìš°ì„ ìˆœìœ„ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ë°˜í™˜
        vector::empty()  // placeholder
    }
    
    fun evaluate_rule_conditions(conditions: &vector<RuleCondition>, context: &UserContext): bool {
        // ëª¨ë“  ì¡°ê±´ì´ ë§Œì¡±ë˜ëŠ”ì§€ í™•ì¸
        true  // placeholder
    }
    
    fun apply_rule_actions(actions: &vector<RuleAction>, context: &mut UserContext) {
        // ê·œì¹™ì˜ ì•¡ì…˜ë“¤ì„ ì ìš©
    }
    
    fun check_static_permission(user: address, permission: String): bool {
        // ì •ì  ê¶Œí•œ í™•ì¸ (RBAC ë“±)
        false  // placeholder
    }
    
    fun evaluate_dynamic_rules(
        manager: &DynamicPermissionManager,
        user: address,
        context: &UserContext,
        permission: String,
        context_data: vector<u64>
    ): bool {
        // ë™ì  ê·œì¹™ í‰ê°€
        false  // placeholder
    }
}