# ğŸ›¡ï¸ Access Control & Security

Movement Networkì—ì„œ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ì ‘ê·¼ ì œì–´ì™€ ë³´ì•ˆ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ëŠ” ê³ ê¸‰ íŒ¨í„´ë“¤ì„ í•™ìŠµí•©ë‹ˆë‹¤. ë‹¤ì¸µ ë³´ì•ˆë¶€í„° ê°ì‚¬ ì¶”ì ê¹Œì§€ í¬ê´„ì ì¸ ë³´ì•ˆ ì•„í‚¤í…ì²˜ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ì ‘ê·¼ ì œì–´ ì‹œìŠ¤í…œì„ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë‹¤ì¸µ ë³´ì•ˆ ì•„í‚¤í…ì²˜ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì™„ì „í•œ ê°ì‚¬ ì¶”ì  ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì¼ë°˜ì ì¸ ë³´ì•ˆ ì·¨ì•½ì ì„ ì‹ë³„í•˜ê³  ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ° ë‹¤ì¸µ ë³´ì•ˆ ì•„í‚¤í…ì²˜

### ë³´ì•ˆ ê³„ì¸µ êµ¬ì¡°
```move
module layered_security {
    use std::signer;
    use std::vector;
    use std::string::{Self, String};
    use std::option::{Self, Option};
    use aptos_framework::timestamp;
    use aptos_framework::event::{Self, EventHandle};
    use aptos_framework::account;
    use aptos_std::smart_table::{Self, SmartTable};
    
    /// ë‹¤ì¸µ ë³´ì•ˆ ì‹œìŠ¤í…œ
    struct LayeredSecuritySystem has key {
        // ê³„ì¸µë³„ ë³´ì•ˆ êµ¬ì„±
        authentication_layer: AuthenticationConfig,
        authorization_layer: AuthorizationConfig,
        audit_layer: AuditConfig,
        encryption_layer: EncryptionConfig,
        
        // ë³´ì•ˆ ì •ì±…
        security_policies: SmartTable<String, SecurityPolicy>,
        
        // ìœ„í˜‘ íƒì§€
        threat_detection: ThreatDetectionSystem,
        
        // ì‚¬ê³  ëŒ€ì‘
        incident_response: IncidentResponseSystem,
        
        // ë³´ì•ˆ ë©”íŠ¸ë¦­
        security_metrics: SecurityMetrics
    }
    
    /// ì¸ì¦ ê³„ì¸µ êµ¬ì„±
    struct AuthenticationConfig has store, drop {
        multi_factor_enabled: bool,
        session_timeout: u64,
        max_failed_attempts: u64,
        lockout_duration: u64,
        password_policy: PasswordPolicy,
        supported_auth_methods: vector<u8>  // 0: password, 1: biometric, 2: hardware_key
    }
    
    struct PasswordPolicy has store, drop, copy {
        min_length: u64,
        require_uppercase: bool,
        require_lowercase: bool,
        require_numbers: bool,
        require_symbols: bool,
        max_age_days: u64,
        history_count: u64  // ì´ì „ íŒ¨ìŠ¤ì›Œë“œ ì¬ì‚¬ìš© ë°©ì§€
    }
    
    /// ê¶Œí•œ ë¶€ì—¬ ê³„ì¸µ êµ¬ì„±
    struct AuthorizationConfig has store, drop {
        rbac_enabled: bool,
        abac_enabled: bool,     // Attribute-Based Access Control
        principle_of_least_privilege: bool,
        permission_inheritance: bool,
        dynamic_permissions: bool
    }
    
    /// ê°ì‚¬ ê³„ì¸µ êµ¬ì„±
    struct AuditConfig has store, drop {
        log_all_access: bool,
        log_failed_attempts: bool,
        log_data_changes: bool,
        log_admin_actions: bool,
        retention_period_days: u64,
        compliance_standards: vector<String>  // SOX, GDPR, HIPAA ë“±
    }
    
    /// ì•”í˜¸í™” ê³„ì¸µ êµ¬ì„±
    struct EncryptionConfig has store, drop {
        data_at_rest_encryption: bool,
        data_in_transit_encryption: bool,
        key_rotation_interval: u64,
        encryption_algorithm: String,
        key_derivation_function: String
    }
    
    /// ë³´ì•ˆ ì •ì±…
    struct SecurityPolicy has store, drop {
        policy_name: String,
        policy_version: String,
        rules: vector<SecurityRule>,
        enforcement_level: u8,  // 0: advisory, 1: warning, 2: blocking
        last_updated: u64,
        approved_by: address
    }
    
    struct SecurityRule has store, drop, copy {
        rule_id: String,
        condition: SecurityCondition,
        action: SecurityAction,
        severity: u8,           // 0: low, 1: medium, 2: high, 3: critical
        is_active: bool
    }
    
    struct SecurityCondition has store, drop, copy {
        condition_type: u8,     // 0: time, 1: location, 2: behavior, 3: resource
        operator: u8,
        threshold: u64,
        parameters: vector<String>
    }
    
    struct SecurityAction has store, drop, copy {
        action_type: u8,        // 0: allow, 1: deny, 2: challenge, 3: quarantine
        response_code: u64,
        notification_required: bool,
        escalation_level: u8
    }
    
    /// ìœ„í˜‘ íƒì§€ ì‹œìŠ¤í…œ
    struct ThreatDetectionSystem has store, drop {
        anomaly_detection: AnomalyDetection,
        signature_detection: SignatureDetection,
        behavioral_analysis: BehavioralAnalysis,
        threat_intelligence: ThreatIntelligence
    }
    
    struct AnomalyDetection has store, drop {
        baseline_established: bool,
        detection_algorithms: vector<String>,
        sensitivity_level: u8,
        false_positive_rate: u64
    }
    
    struct SignatureDetection has store, drop {
        signature_database: SmartTable<String, ThreatSignature>,
        last_update: u64,
        auto_update_enabled: bool
    }
    
    struct ThreatSignature has store, drop, copy {
        signature_id: String,
        pattern: String,
        severity: u8,
        created_at: u64,
        source: String
    }
    
    struct BehavioralAnalysis has store, drop {
        user_profiles: SmartTable<address, UserBehaviorProfile>,
        analysis_window: u64,
        deviation_threshold: u64
    }
    
    struct UserBehaviorProfile has store, drop {
        user: address,
        typical_access_times: vector<u64>,
        typical_resources: vector<String>,
        access_patterns: vector<AccessPattern>,
        risk_score: u64,
        last_updated: u64
    }
    
    struct AccessPattern has store, drop, copy {
        pattern_type: u8,
        frequency: u64,
        time_distribution: vector<u64>,
        resource_types: vector<String>
    }
    
    struct ThreatIntelligence has store, drop {
        threat_feeds: vector<String>,
        ioc_database: SmartTable<String, IOC>,  // Indicators of Compromise
        last_feed_update: u64
    }
    
    struct IOC has store, drop, copy {
        indicator: String,
        indicator_type: String,
        threat_level: u8,
        first_seen: u64,
        source: String
    }
    
    /// ë³´ì•ˆ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    public fun initialize_security_system(admin: &signer) {
        let security_system = LayeredSecuritySystem {
            authentication_layer: create_default_auth_config(),
            authorization_layer: create_default_authz_config(),
            audit_layer: create_default_audit_config(),
            encryption_layer: create_default_encryption_config(),
            
            security_policies: smart_table::new(),
            threat_detection: create_default_threat_detection(),
            incident_response: create_default_incident_response(),
            security_metrics: create_default_security_metrics()
        };
        
        move_to(admin, security_system);
        
        // ê¸°ë³¸ ë³´ì•ˆ ì •ì±… ìƒì„±
        create_default_security_policies(admin);
    }
    
    /// ì ì‘í˜• ì ‘ê·¼ ì œì–´
    public fun adaptive_access_control(
        user: &signer,
        system_addr: address,
        resource: String,
        action: String,
        context: AccessContext
    ): AccessDecision acquires LayeredSecuritySystem {
        let user_addr = signer::address_of(user);
        let system = borrow_global_mut<LayeredSecuritySystem>(system_addr);
        
        // 1ë‹¨ê³„: ì¸ì¦ ê²€ì¦
        let auth_result = verify_authentication(user_addr, &system.authentication_layer, &context);
        if (!auth_result.is_valid) {
            return create_deny_decision(AUTH_FAILED, auth_result.reason)
        };
        
        // 2ë‹¨ê³„: ê¶Œí•œ ë¶€ì—¬ í™•ì¸
        let authz_result = check_authorization(user_addr, &resource, &action, &system.authorization_layer);
        if (!authz_result.is_authorized) {
            return create_deny_decision(AUTHZ_FAILED, authz_result.reason)
        };
        
        // 3ë‹¨ê³„: ìœ„í˜‘ íƒì§€ ë¶„ì„
        let threat_result = analyze_threats(user_addr, &context, &mut system.threat_detection);
        if (threat_result.threat_level > ACCEPTABLE_THREAT_LEVEL) {
            return create_challenge_decision(THREAT_DETECTED, threat_result.details)
        };
        
        // 4ë‹¨ê³„: ì •ì±… í‰ê°€
        let policy_result = evaluate_security_policies(&system.security_policies, user_addr, &resource, &action);
        if (!policy_result.compliant) {
            return create_conditional_decision(POLICY_VIOLATION, policy_result.conditions)
        };
        
        // 5ë‹¨ê³„: ê°ì‚¬ ë¡œê¹…
        log_access_decision(&mut system.audit_layer, user_addr, &resource, &action, &context, true);
        
        create_allow_decision()
    }
    
    struct AccessContext has drop {
        timestamp: u64,
        source_ip: String,
        user_agent: String,
        session_id: String,
        risk_indicators: vector<String>,
        additional_attributes: SmartTable<String, String>
    }
    
    struct AccessDecision has drop {
        decision: u8,           // 0: allow, 1: deny, 2: challenge, 3: conditional
        reason_code: u64,
        reason_message: String,
        additional_requirements: vector<String>,
        expires_at: Option<u64>
    }
    
    /// ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì•„í‚¤í…ì²˜ êµ¬í˜„
    public fun zero_trust_verification(
        requester: &signer,
        system_addr: address,
        target_resource: String,
        verification_level: u8
    ): ZeroTrustResult acquires LayeredSecuritySystem {
        let requester_addr = signer::address_of(requester);
        let system = borrow_global_mut<LayeredSecuritySystem>(system_addr);
        
        let mut verification_steps = vector::empty();
        
        // 1. Identity Verification (ì‹ ì› í™•ì¸)
        let identity_check = verify_identity(requester_addr, verification_level);
        vector::push_back(&mut verification_steps, identity_check);
        
        // 2. Device Trust Assessment (ë””ë°”ì´ìŠ¤ ì‹ ë¢°ë„ í‰ê°€)
        let device_check = assess_device_trust(requester_addr, &target_resource);
        vector::push_back(&mut verification_steps, device_check);
        
        // 3. Network Security Analysis (ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ ë¶„ì„)
        let network_check = analyze_network_security(requester_addr);
        vector::push_back(&mut verification_steps, network_check);
        
        // 4. Behavioral Pattern Analysis (í–‰ë™ íŒ¨í„´ ë¶„ì„)
        let behavior_check = analyze_behavior_patterns(
            &mut system.threat_detection.behavioral_analysis,
            requester_addr,
            &target_resource
        );
        vector::push_back(&mut verification_steps, behavior_check);
        
        // 5. Real-time Risk Assessment (ì‹¤ì‹œê°„ ìœ„í—˜ í‰ê°€)
        let risk_check = assess_realtime_risk(requester_addr, &target_resource, &verification_steps);
        vector::push_back(&mut verification_steps, risk_check);
        
        // ì¢…í•© ê²°ê³¼ ê³„ì‚°
        let overall_trust_score = calculate_trust_score(&verification_steps);
        let decision = determine_access_decision(overall_trust_score, verification_level);
        
        ZeroTrustResult {
            trust_score: overall_trust_score,
            decision,
            verification_steps,
            valid_until: timestamp::now_seconds() + 300, // 5ë¶„ê°„ ìœ íš¨
            requires_reauthentication: overall_trust_score < 70
        }
    }
    
    struct ZeroTrustResult has drop {
        trust_score: u64,       // 0-100
        decision: AccessDecision,
        verification_steps: vector<VerificationStep>,
        valid_until: u64,
        requires_reauthentication: bool
    }
    
    struct VerificationStep has drop {
        step_name: String,
        result: bool,
        confidence: u64,        // 0-100
        risk_factors: vector<String>
    }
    
    /// ë™ì  ê¶Œí•œ ì¡°ì • ì‹œìŠ¤í…œ
    public fun dynamic_permission_adjustment(
        admin: &signer,
        system_addr: address,
        user: address,
        adjustment_trigger: AdjustmentTrigger
    ) acquires LayeredSecuritySystem {
        let system = borrow_global_mut<LayeredSecuritySystem>(system_addr);
        
        match (adjustment_trigger.trigger_type) {
            0 => {  // Security Incident
                reduce_user_permissions(user, adjustment_trigger.severity);
                create_security_incident(system, user, adjustment_trigger.details);
            },
            1 => {  // Behavior Anomaly
                implement_additional_verification(user, adjustment_trigger.anomaly_type);
                update_user_risk_profile(&mut system.threat_detection.behavioral_analysis, user);
            },
            2 => {  // Time-based Adjustment
                apply_temporal_restrictions(user, adjustment_trigger.time_constraints);
            },
            3 => {  // Context-based Adjustment
                modify_context_permissions(user, adjustment_trigger.context_changes);
            },
            _ => {}
        };
        
        // ì¡°ì • ì‚¬í•­ ê°ì‚¬ ë¡œê·¸ ê¸°ë¡
        log_permission_adjustment(&mut system.audit_layer, user, adjustment_trigger);
    }
    
    struct AdjustmentTrigger has drop {
        trigger_type: u8,
        severity: u8,
        anomaly_type: Option<u8>,
        time_constraints: Option<vector<u64>>,
        context_changes: Option<SmartTable<String, String>>,
        details: String
    }
    
    /// ë³´ì•ˆ ê°ì‚¬ ì‹œìŠ¤í…œ
    public fun comprehensive_security_audit(
        auditor: &signer,
        system_addr: address,
        audit_scope: AuditScope
    ): SecurityAuditReport acquires LayeredSecuritySystem {
        let system = borrow_global<LayeredSecuritySystem>(system_addr);
        let audit_start_time = timestamp::now_seconds();
        
        let mut audit_findings = vector::empty();
        
        // 1. ì ‘ê·¼ ì œì–´ ê°ì‚¬
        if (audit_scope.include_access_control) {
            let access_findings = audit_access_controls(system);
            vector::append(&mut audit_findings, access_findings);
        };
        
        // 2. ì¸ì¦ ì‹œìŠ¤í…œ ê°ì‚¬
        if (audit_scope.include_authentication) {
            let auth_findings = audit_authentication_system(&system.authentication_layer);
            vector::append(&mut audit_findings, auth_findings);
        };
        
        // 3. ë°ì´í„° ë³´í˜¸ ê°ì‚¬
        if (audit_scope.include_data_protection) {
            let data_findings = audit_data_protection(&system.encryption_layer);
            vector::append(&mut audit_findings, data_findings);
        };
        
        // 4. ë¡œê·¸ ë¬´ê²°ì„± ê°ì‚¬
        if (audit_scope.include_log_integrity) {
            let log_findings = audit_log_integrity(&system.audit_layer);
            vector::append(&mut audit_findings, log_findings);
        };
        
        // 5. ì •ì±… ì¤€ìˆ˜ ê°ì‚¬
        if (audit_scope.include_policy_compliance) {
            let policy_findings = audit_policy_compliance(&system.security_policies);
            vector::append(&mut audit_findings, policy_findings);
        };
        
        // ê°ì‚¬ ë³´ê³ ì„œ ìƒì„±
        let risk_assessment = assess_overall_security_risk(&audit_findings);
        let recommendations = generate_security_recommendations(&audit_findings);
        
        SecurityAuditReport {
            audit_id: generate_audit_id(),
            auditor: signer::address_of(auditor),
            audit_start_time,
            audit_end_time: timestamp::now_seconds(),
            scope: audit_scope,
            findings: audit_findings,
            risk_assessment,
            recommendations,
            compliance_status: calculate_compliance_status(&audit_findings)
        }
    }
    
    struct AuditScope has drop, copy {
        include_access_control: bool,
        include_authentication: bool,
        include_data_protection: bool,
        include_log_integrity: bool,
        include_policy_compliance: bool,
        time_range: Option<(u64, u64)>,
        specific_users: Option<vector<address>>,
        specific_resources: Option<vector<String>>
    }
    
    struct SecurityAuditReport has drop {
        audit_id: String,
        auditor: address,
        audit_start_time: u64,
        audit_end_time: u64,
        scope: AuditScope,
        findings: vector<AuditFinding>,
        risk_assessment: RiskAssessment,
        recommendations: vector<SecurityRecommendation>,
        compliance_status: ComplianceStatus
    }
    
    struct AuditFinding has drop {
        finding_id: String,
        category: String,       // "access_control", "authentication", etc.
        severity: u8,           // 0: info, 1: low, 2: medium, 3: high, 4: critical
        description: String,
        evidence: vector<String>,
        affected_components: vector<String>,
        remediation_required: bool
    }
    
    struct RiskAssessment has drop {
        overall_risk_level: u8, // 0: low, 1: medium, 2: high, 3: critical
        risk_factors: vector<String>,
        likelihood: u8,         // 0-100
        impact: u8,             // 0-100
        risk_score: u64         // likelihood * impact
    }
    
    struct SecurityRecommendation has drop {
        recommendation_id: String,
        priority: u8,           // 0: low, 1: medium, 2: high, 3: urgent
        category: String,
        description: String,
        implementation_effort: u8, // 0: low, 1: medium, 2: high
        expected_risk_reduction: u8
    }
    
    struct ComplianceStatus has drop {
        standards: SmartTable<String, ComplianceResult>,
        overall_compliance_score: u64, // 0-100
        gaps_identified: vector<String>,
        certification_status: SmartTable<String, bool>
    }
    
    struct ComplianceResult has store, drop {
        standard_name: String,
        compliance_score: u64, // 0-100
        requirements_met: u64,
        total_requirements: u64,
        gaps: vector<String>
    }
    
    /// ìë™ ë³´ì•ˆ ëŒ€ì‘ ì‹œìŠ¤í…œ
    public fun automated_security_response(
        system_addr: address,
        security_event: SecurityEvent
    ) acquires LayeredSecuritySystem {
        let system = borrow_global_mut<LayeredSecuritySystem>(system_addr);
        
        // ì´ë²¤íŠ¸ ì‹¬ê°ë„ì— ë”°ë¥¸ ìë™ ëŒ€ì‘
        match (security_event.severity) {
            4 => {  // Critical
                execute_critical_response(&mut system.incident_response, security_event);
            },
            3 => {  // High
                execute_high_priority_response(&mut system.incident_response, security_event);
            },
            2 => {  // Medium
                execute_medium_priority_response(&mut system.incident_response, security_event);
            },
            1 => {  // Low
                execute_low_priority_response(&mut system.incident_response, security_event);
            },
            _ => {  // Info
                log_security_event(&mut system.audit_layer, security_event);
            }
        };
        
        // ë³´ì•ˆ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
        update_security_metrics(&mut system.security_metrics, &security_event);
        
        // ê´€ë ¨ ì •ì±… ìë™ ì¡°ì •
        if (security_event.requires_policy_update) {
            auto_adjust_security_policies(&mut system.security_policies, &security_event);
        }
    }
    
    struct SecurityEvent has drop {
        event_id: String,
        event_type: u8,         // 0: intrusion, 1: data_breach, 2: policy_violation
        severity: u8,           // 0: info, 1: low, 2: medium, 3: high, 4: critical
        source: String,
        target: String,
        timestamp: u64,
        indicators: vector<String>,
        requires_policy_update: bool,
        additional_data: SmartTable<String, String>
    }
    
    /// ì‚¬ê³  ëŒ€ì‘ ì‹œìŠ¤í…œ
    struct IncidentResponseSystem has store, drop {
        response_plans: SmartTable<u8, ResponsePlan>,
        active_incidents: SmartTable<String, SecurityIncident>,
        response_team: vector<address>,
        escalation_matrix: SmartTable<u8, EscalationRule>,
        recovery_procedures: SmartTable<String, RecoveryProcedure>
    }
    
    struct ResponsePlan has store, drop {
        severity_level: u8,
        immediate_actions: vector<String>,
        investigation_steps: vector<String>,
        containment_measures: vector<String>,
        recovery_actions: vector<String>,
        communication_plan: CommunicationPlan
    }
    
    struct SecurityIncident has store, drop {
        incident_id: String,
        detected_at: u64,
        severity: u8,
        status: u8,             // 0: new, 1: investigating, 2: contained, 3: resolved
        affected_systems: vector<String>,
        response_actions_taken: vector<String>,
        assigned_responders: vector<address>,
        estimated_impact: String,
        lessons_learned: Option<String>
    }
    
    struct EscalationRule has store, drop {
        trigger_conditions: vector<String>,
        escalation_targets: vector<address>,
        notification_methods: vector<u8>,
        time_thresholds: vector<u64>
    }
    
    struct RecoveryProcedure has store, drop {
        procedure_name: String,
        steps: vector<RecoveryStep>,
        estimated_duration: u64,
        required_resources: vector<String>,
        success_criteria: vector<String>
    }
    
    struct RecoveryStep has store, drop, copy {
        step_number: u64,
        description: String,
        responsible_party: String,
        dependencies: vector<u64>,
        estimated_time: u64
    }
    
    struct CommunicationPlan has store, drop {
        internal_notifications: vector<address>,
        external_notifications: vector<String>,
        regulatory_reporting: vector<String>,
        customer_communication: bool,
        media_response: bool
    }
    
    /// ë³´ì•ˆ ë©”íŠ¸ë¦­ ì‹œìŠ¤í…œ
    struct SecurityMetrics has store, drop {
        threat_detection_rate: u64,
        false_positive_rate: u64,
        incident_response_time: u64,     // average in seconds
        policy_violation_count: u64,
        successful_attacks_prevented: u64,
        compliance_score: u64,           // 0-100
        user_training_completion: u64,   // percentage
        last_security_assessment: u64,
        metrics_by_category: SmartTable<String, CategoryMetrics>
    }
    
    struct CategoryMetrics has store, drop {
        category_name: String,
        success_rate: u64,      // 0-100
        failure_count: u64,
        average_response_time: u64,
        trend_direction: u8     // 0: improving, 1: stable, 2: degrading
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤ê³¼ ê¸°ë³¸ ì„¤ì • ìƒì„± í•¨ìˆ˜ë“¤
    fun create_default_auth_config(): AuthenticationConfig {
        AuthenticationConfig {
            multi_factor_enabled: true,
            session_timeout: 3600, // 1 hour
            max_failed_attempts: 3,
            lockout_duration: 900,  // 15 minutes
            password_policy: PasswordPolicy {
                min_length: 12,
                require_uppercase: true,
                require_lowercase: true,
                require_numbers: true,
                require_symbols: true,
                max_age_days: 90,
                history_count: 5
            },
            supported_auth_methods: vector[0, 1, 2] // all methods
        }
    }
    
    fun create_default_authz_config(): AuthorizationConfig {
        AuthorizationConfig {
            rbac_enabled: true,
            abac_enabled: true,
            principle_of_least_privilege: true,
            permission_inheritance: true,
            dynamic_permissions: true
        }
    }
    
    fun create_default_audit_config(): AuditConfig {
        AuditConfig {
            log_all_access: true,
            log_failed_attempts: true,
            log_data_changes: true,
            log_admin_actions: true,
            retention_period_days: 2555, // 7 years
            compliance_standards: vector[
                string::utf8(b"SOX"),
                string::utf8(b"GDPR"),
                string::utf8(b"HIPAA")
            ]
        }
    }
    
    fun create_default_encryption_config(): EncryptionConfig {
        EncryptionConfig {
            data_at_rest_encryption: true,
            data_in_transit_encryption: true,
            key_rotation_interval: 7776000, // 90 days
            encryption_algorithm: string::utf8(b"AES-256-GCM"),
            key_derivation_function: string::utf8(b"PBKDF2")
        }
    }
    
    fun create_default_threat_detection(): ThreatDetectionSystem {
        ThreatDetectionSystem {
            anomaly_detection: AnomalyDetection {
                baseline_established: false,
                detection_algorithms: vector[
                    string::utf8(b"statistical"),
                    string::utf8(b"machine_learning"),
                    string::utf8(b"behavioral")
                ],
                sensitivity_level: 2, // medium
                false_positive_rate: 5 // 5%
            },
            signature_detection: SignatureDetection {
                signature_database: smart_table::new(),
                last_update: 0,
                auto_update_enabled: true
            },
            behavioral_analysis: BehavioralAnalysis {
                user_profiles: smart_table::new(),
                analysis_window: 604800, // 7 days
                deviation_threshold: 70   // 70% deviation triggers alert
            },
            threat_intelligence: ThreatIntelligence {
                threat_feeds: vector[
                    string::utf8(b"NIST_CVE"),
                    string::utf8(b"MISP"),
                    string::utf8(b"internal")
                ],
                ioc_database: smart_table::new(),
                last_feed_update: 0
            }
        }
    }
    
    fun create_default_incident_response(): IncidentResponseSystem {
        IncidentResponseSystem {
            response_plans: smart_table::new(),
            active_incidents: smart_table::new(),
            response_team: vector::empty(),
            escalation_matrix: smart_table::new(),
            recovery_procedures: smart_table::new()
        }
    }
    
    fun create_default_security_metrics(): SecurityMetrics {
        SecurityMetrics {
            threat_detection_rate: 0,
            false_positive_rate: 0,
            incident_response_time: 0,
            policy_violation_count: 0,
            successful_attacks_prevented: 0,
            compliance_score: 100,
            user_training_completion: 0,
            last_security_assessment: timestamp::now_seconds(),
            metrics_by_category: smart_table::new()
        }
    }
    
    fun create_default_security_policies(admin: &signer) {
        // ê¸°ë³¸ ë³´ì•ˆ ì •ì±…ë“¤ì„ ìƒì„±í•˜ëŠ” í•¨ìˆ˜
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ê° ì •ì±…ì„ ì„¸ë¶€ì ìœ¼ë¡œ ì •ì˜
    }
    
    // ê¸°íƒ€ í•„ìš”í•œ í—¬í¼ í•¨ìˆ˜ë“¤
    fun verify_authentication(user: address, config: &AuthenticationConfig, context: &AccessContext): AuthResult {
        // ì¸ì¦ ê²€ì¦ ë¡œì§
        AuthResult { is_valid: true, reason: string::utf8(b"") }
    }
    
    fun check_authorization(user: address, resource: &String, action: &String, config: &AuthorizationConfig): AuthzResult {
        // ê¶Œí•œ í™•ì¸ ë¡œì§
        AuthzResult { is_authorized: true, reason: string::utf8(b"") }
    }
    
    fun analyze_threats(user: address, context: &AccessContext, detection: &mut ThreatDetectionSystem): ThreatResult {
        // ìœ„í˜‘ ë¶„ì„ ë¡œì§
        ThreatResult { threat_level: 1, details: string::utf8(b"") }
    }
    
    // ì¶”ê°€ êµ¬ì¡°ì²´ ì •ì˜
    struct AuthResult has drop {
        is_valid: bool,
        reason: String
    }
    
    struct AuthzResult has drop {
        is_authorized: bool,
        reason: String
    }
    
    struct ThreatResult has drop {
        threat_level: u8,
        details: String
    }
    
    // ìƒìˆ˜ ì •ì˜
    const AUTH_FAILED: u64 = 1001;
    const AUTHZ_FAILED: u64 = 1002;
    const THREAT_DETECTED: u64 = 1003;
    const POLICY_VIOLATION: u64 = 1004;
    const ACCEPTABLE_THREAT_LEVEL: u8 = 2;
    
    // ê²°ì • ìƒì„± í•¨ìˆ˜ë“¤
    fun create_deny_decision(code: u64, message: String): AccessDecision {
        AccessDecision {
            decision: 1, // deny
            reason_code: code,
            reason_message: message,
            additional_requirements: vector::empty(),
            expires_at: option::none()
        }
    }
    
    fun create_challenge_decision(code: u64, message: String): AccessDecision {
        AccessDecision {
            decision: 2, // challenge
            reason_code: code,
            reason_message: message,
            additional_requirements: vector[string::utf8(b"additional_auth")],
            expires_at: option::some(timestamp::now_seconds() + 300)
        }
    }
    
    fun create_conditional_decision(code: u64, conditions: vector<String>): AccessDecision {
        AccessDecision {
            decision: 3, // conditional
            reason_code: code,
            reason_message: string::utf8(b"Policy conditions must be met"),
            additional_requirements: conditions,
            expires_at: option::some(timestamp::now_seconds() + 3600)
        }
    }
    
    fun create_allow_decision(): AccessDecision {
        AccessDecision {
            decision: 0, // allow
            reason_code: 0,
            reason_message: string::utf8(b"Access granted"),
            additional_requirements: vector::empty(),
            expires_at: option::none()
        }
    }
    
    // ê¸°íƒ€ í•„ìš”í•œ í•¨ìˆ˜ë“¤ (placeholder)
    fun evaluate_security_policies(policies: &SmartTable<String, SecurityPolicy>, user: address, resource: &String, action: &String): PolicyResult {
        PolicyResult { compliant: true, conditions: vector::empty() }
    }
    
    fun log_access_decision(audit: &mut AuditConfig, user: address, resource: &String, action: &String, context: &AccessContext, granted: bool) {
        // ì ‘ê·¼ ê²°ì • ë¡œê¹…
    }
    
    struct PolicyResult has drop {
        compliant: bool,
        conditions: vector<String>
    }
    
    // ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ê´€ë ¨ í•¨ìˆ˜ë“¤
    fun verify_identity(user: address, level: u8): VerificationStep {
        VerificationStep {
            step_name: string::utf8(b"Identity Verification"),
            result: true,
            confidence: 95,
            risk_factors: vector::empty()
        }
    }
    
    fun assess_device_trust(user: address, resource: &String): VerificationStep {
        VerificationStep {
            step_name: string::utf8(b"Device Trust Assessment"),
            result: true,
            confidence: 85,
            risk_factors: vector::empty()
        }
    }
    
    fun analyze_network_security(user: address): VerificationStep {
        VerificationStep {
            step_name: string::utf8(b"Network Security Analysis"),
            result: true,
            confidence: 90,
            risk_factors: vector::empty()
        }
    }
    
    fun analyze_behavior_patterns(analysis: &mut BehavioralAnalysis, user: address, resource: &String): VerificationStep {
        VerificationStep {
            step_name: string::utf8(b"Behavioral Analysis"),
            result: true,
            confidence: 80,
            risk_factors: vector::empty()
        }
    }
    
    fun assess_realtime_risk(user: address, resource: &String, steps: &vector<VerificationStep>): VerificationStep {
        VerificationStep {
            step_name: string::utf8(b"Real-time Risk Assessment"),
            result: true,
            confidence: 88,
            risk_factors: vector::empty()
        }
    }
    
    fun calculate_trust_score(steps: &vector<VerificationStep>): u64 {
        let mut total_confidence = 0;
        let step_count = vector::length(steps);
        
        let i = 0;
        while (i < step_count) {
            let step = vector::borrow(steps, i);
            total_confidence = total_confidence + step.confidence;
            i = i + 1;
        };
        
        if (step_count > 0) {
            total_confidence / step_count
        } else {
            0
        }
    }
    
    fun determine_access_decision(trust_score: u64, verification_level: u8): AccessDecision {
        let required_score = match (verification_level) {
            0 => 60, // low
            1 => 75, // medium
            2 => 90, // high
            _ => 95  // critical
        };
        
        if (trust_score >= required_score) {
            create_allow_decision()
        } else {
            create_deny_decision(1005, string::utf8(b"Insufficient trust score"))
        }
    }
    
    // ì¶”ê°€ì ì¸ ë³´ì•ˆ í•¨ìˆ˜ë“¤ê³¼ ê°ì‚¬ í•¨ìˆ˜ë“¤ë„ í•„ìš”ì— ë”°ë¼ êµ¬í˜„...
}
```

## ğŸ”— advanced-concepts ì„¹ì…˜ ì™„ì„±!

**ëª¨ë“  4ê°œ í˜ì´ì§€ê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤!** ğŸ‰

### âœ… **ì™„ì„±ëœ íŒŒì¼ë“¤:**
1. **index.mdx** - ê³ ê¸‰ ê°œë… ê°œìš” âœ…
2. **_meta.json** - ë©”íƒ€ë°ì´í„° ì„¤ì • âœ…  
3. **smart-vector-table.mdx** - Smart Vector & Smart Table âœ…
4. **resource-account-capability.mdx** - Resource Account & Capability âœ…
5. **event-object-signer.mdx** - Event, Object, Signer ì‹¬í™” âœ…
6. **access-control-security.mdx** - Access Control & Security âœ…

### ğŸ“‹ **êµ¬ì¡° ìš”ì•½:**
```
ğŸ¯ advanced-concepts/
â”œâ”€â”€ index.mdx (ê³ ê¸‰ ê°œë… ê°œìš”)
â”œâ”€â”€ _meta.json (ë©”íƒ€ë°ì´í„°)
â”œâ”€â”€ smart-vector-table.mdx (ë°ì´í„° êµ¬ì¡°)
â”œâ”€â”€ resource-account-capability.mdx (ê¶Œí•œ ê´€ë¦¬)
â”œâ”€â”€ event-object-signer.mdx (í•µì‹¬ ê°œë… ì‹¬í™”)
â””â”€â”€ access-control-security.mdx (ë³´ì•ˆ ì‹œìŠ¤í…œ)
```

**ì´ì œ Cursorì—ì„œ ëª¨ë“  íŒŒì¼ì„ ìƒì„±í•˜ì‹œê³ , ë‹¤ìŒ ì„¹ì…˜ì„ ì§„í–‰í•˜ì‹œê² ì–´ìš”?**

### ğŸš€ **ë‹¤ìŒ ë‹¨ê³„ ì˜µì…˜:**
1. **dapp-development** - dApp ê°œë°œ (ë§ˆì§€ë§‰ ì„¹ì…˜)
2. **ë‹¤ë¥¸ ìš°ì„ ìˆœìœ„ê°€ ìˆìœ¼ì‹œë©´ ë§ì”€í•´ì£¼ì„¸ìš”!**

**ì–´ë–¤ ê±¸ ë‹¤ìŒì— í•˜ì‹œê² ì–´ìš”?** ğŸ˜Š

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€](https://docs.movementnetwork.xyz/security)
- [ì ‘ê·¼ ì œì–´ ê°€ì´ë“œ](https://docs.movementnetwork.xyz/access-control)

---

*ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë³´ì•ˆìœ¼ë¡œ ì•ˆì „í•˜ê³  ì‹ ë¢°ë°›ëŠ” ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ›¡ï¸ğŸ”’*