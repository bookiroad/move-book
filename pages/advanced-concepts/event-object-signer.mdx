# ğŸ“¡ Event, Object, Signer ì‹¬í™”

Movement Networkì˜ í•µì‹¬ ê°œë…ì¸ Event, Object, Signerë¥¼ ê³ ê¸‰ ìˆ˜ì¤€ì—ì„œ í™œìš©í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤. ë³µì¡í•œ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œìŠ¤í…œë¶€í„° ê°ì²´ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ê¹Œì§€ ì „ë¬¸ì ì¸ íŒ¨í„´ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- ë³µì¡í•œ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ê³  êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Objectì˜ ë¼ì´í”„ì‚¬ì´í´ì„ ì™„ì „íˆ ì œì–´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Signer íŒ¨í„´ì˜ ê³ ê¸‰ í™œìš©ë²•ì„ ë§ˆìŠ¤í„°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ëª¨ë“ˆ ê°„ ì•ˆì „í•œ ìƒí˜¸ì‘ìš©ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ“¡ ê³ ê¸‰ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ

### ì´ë²¤íŠ¸ ì•„í‚¤í…ì²˜ íŒ¨í„´
```move
module advanced_events {
    use std::signer;
    use std::vector;
    use std::string::{Self, String};
    use aptos_framework::event::{Self, EventHandle};
    use aptos_framework::account;
    use aptos_framework::timestamp;
    use aptos_std::smart_table::{Self, SmartTable};
    
    /// ê³„ì¸µì  ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
    struct EventRegistry has key {
        // ë‹¤ì–‘í•œ ë ˆë²¨ì˜ ì´ë²¤íŠ¸ í•¸ë“¤
        system_events: EventHandle<SystemEvent>,
        user_events: EventHandle<UserEvent>,
        business_events: EventHandle<BusinessEvent>,
        error_events: EventHandle<ErrorEvent>,
        
        // ì´ë²¤íŠ¸ í•„í„°ë§ ë° ë¼ìš°íŒ…
        event_filters: SmartTable<String, EventFilter>,
        event_subscribers: SmartTable<String, vector<address>>,
        
        // í†µê³„ ë° ëª¨ë‹ˆí„°ë§
        event_stats: EventStatistics,
        
        // ì„¤ì •
        max_events_per_type: u64,
        enable_event_history: bool
    }
    
    /// ì‹œìŠ¤í…œ ë ˆë²¨ ì´ë²¤íŠ¸
    struct SystemEvent has drop, store {
        event_type: u8,        // 0: startup, 1: shutdown, 2: upgrade, 3: maintenance
        severity: u8,          // 0: info, 1: warning, 2: error, 3: critical
        message: String,
        timestamp: u64,
        module_address: address,
        additional_data: vector<u8>
    }
    
    /// ì‚¬ìš©ì ì•¡ì…˜ ì´ë²¤íŠ¸
    struct UserEvent has drop, store {
        user: address,
        action: String,        // "transfer", "mint", "burn", "approve" ë“±
        resource_type: String, // ì˜í–¥ë°›ì€ ë¦¬ì†ŒìŠ¤ íƒ€ì…
        before_state: vector<u8>,  // ì´ì „ ìƒíƒœ (ì„ íƒì )
        after_state: vector<u8>,   // ì´í›„ ìƒíƒœ (ì„ íƒì )
        transaction_hash: vector<u8>,
        gas_used: u64,
        timestamp: u64
    }
    
    /// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì´ë²¤íŠ¸
    struct BusinessEvent has drop, store {
        event_category: String,    // "defi", "nft", "governance" ë“±
        event_name: String,
        participants: vector<address>,
        amounts: vector<u64>,
        metadata: SmartTable<String, String>,
        correlation_id: String,    // ê´€ë ¨ ì´ë²¤íŠ¸ë“¤ ì—°ê²°
        timestamp: u64
    }
    
    /// ì—ëŸ¬ ì´ë²¤íŠ¸
    struct ErrorEvent has drop, store {
        error_code: u64,
        error_message: String,
        failed_function: String,
        user: address,
        context: vector<u8>,
        recovery_suggestions: vector<String>,
        timestamp: u64
    }
    
    /// ì´ë²¤íŠ¸ í•„í„°
    struct EventFilter has store, drop {
        filter_type: u8,       // 0: user, 1: event_type, 2: severity, 3: time_range
        criteria: vector<u8>,  // í•„í„° ì¡°ê±´
        is_active: bool
    }
    
    /// ì´ë²¤íŠ¸ í†µê³„
    struct EventStatistics has store, drop {
        total_events: u64,
        events_by_type: SmartTable<String, u64>,
        events_by_user: SmartTable<address, u64>,
        last_reset: u64
    }
    
    /// ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    public fun initialize_event_system(admin: &signer) {
        let event_registry = EventRegistry {
            system_events: account::new_event_handle<SystemEvent>(admin),
            user_events: account::new_event_handle<UserEvent>(admin),
            business_events: account::new_event_handle<BusinessEvent>(admin),
            error_events: account::new_event_handle<ErrorEvent>(admin),
            
            event_filters: smart_table::new(),
            event_subscribers: smart_table::new(),
            
            event_stats: EventStatistics {
                total_events: 0,
                events_by_type: smart_table::new(),
                events_by_user: smart_table::new(),
                last_reset: timestamp::now_seconds()
            },
            
            max_events_per_type: 10000,
            enable_event_history: true
        };
        
        move_to(admin, event_registry);
        
        // ì‹œìŠ¤í…œ ì‹œì‘ ì´ë²¤íŠ¸ ë°œìƒ
        emit_system_event(
            signer::address_of(admin),
            0, // startup
            0, // info
            string::utf8(b"Event system initialized"),
            vector::empty()
        );
    }
    
    /// ë³µí•© ì´ë²¤íŠ¸ ë°œìƒ (ì—¬ëŸ¬ ì´ë²¤íŠ¸ë¥¼ ì›ìì ìœ¼ë¡œ ì²˜ë¦¬)
    public fun emit_composite_event(
        user: &signer,
        registry_addr: address,
        events: vector<CompositeEventData>
    ) acquires EventRegistry {
        let user_addr = signer::address_of(user);
        let registry = borrow_global_mut<EventRegistry>(registry_addr);
        
        let correlation_id = generate_correlation_id(user_addr);
        let current_time = timestamp::now_seconds();
        
        let i = 0;
        while (i < vector::length(&events)) {
            let event_data = vector::borrow(&events, i);
            
            match (event_data.event_type) {
                0 => {  // User Event
                    let user_event = UserEvent {
                        user: user_addr,
                        action: event_data.action,
                        resource_type: event_data.resource_type,
                        before_state: event_data.before_state,
                        after_state: event_data.after_state,
                        transaction_hash: event_data.transaction_hash,
                        gas_used: event_data.gas_used,
                        timestamp: current_time
                    };
                    event::emit_event(&mut registry.user_events, user_event);
                },
                1 => {  // Business Event
                    let business_event = BusinessEvent {
                        event_category: event_data.category,
                        event_name: event_data.action,
                        participants: event_data.participants,
                        amounts: event_data.amounts,
                        metadata: create_metadata_table(event_data.metadata_pairs),
                        correlation_id,
                        timestamp: current_time
                    };
                    event::emit_event(&mut registry.business_events, business_event);
                },
                _ => {} // ë‹¤ë¥¸ ì´ë²¤íŠ¸ íƒ€ì…ë“¤
            };
            
            i = i + 1;
        };
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        update_event_statistics(&mut registry.event_stats, vector::length(&events));
    }
    
    struct CompositeEventData has drop {
        event_type: u8,
        action: String,
        resource_type: String,
        category: String,
        participants: vector<address>,
        amounts: vector<u64>,
        before_state: vector<u8>,
        after_state: vector<u8>,
        transaction_hash: vector<u8>,
        gas_used: u64,
        metadata_pairs: vector<(String, String)>
    }
    
    /// ì´ë²¤íŠ¸ êµ¬ë… ì‹œìŠ¤í…œ
    public fun subscribe_to_events(
        subscriber: &signer,
        registry_addr: address,
        event_types: vector<String>
    ) acquires EventRegistry {
        let subscriber_addr = signer::address_of(subscriber);
        let registry = borrow_global_mut<EventRegistry>(registry_addr);
        
        let i = 0;
        while (i < vector::length(&event_types)) {
            let event_type = *vector::borrow(&event_types, i);
            
            if (!smart_table::contains(&registry.event_subscribers, event_type)) {
                smart_table::add(&mut registry.event_subscribers, event_type, vector::empty());
            };
            
            let subscribers = smart_table::borrow_mut(&mut registry.event_subscribers, event_type);
            if (!vector::contains(subscribers, &subscriber_addr)) {
                vector::push_back(subscribers, subscriber_addr);
            };
            
            i = i + 1;
        }
    }
    
    /// ì¡°ê±´ë¶€ ì´ë²¤íŠ¸ ë°œìƒ
    public fun emit_conditional_event(
        user: &signer,
        registry_addr: address,
        condition: EventCondition,
        event_data: UserEvent
    ) acquires EventRegistry {
        if (evaluate_event_condition(&condition, &event_data)) {
            let registry = borrow_global_mut<EventRegistry>(registry_addr);
            event::emit_event(&mut registry.user_events, event_data);
        }
    }
    
    struct EventCondition has drop {
        condition_type: u8,    // 0: amount_threshold, 1: time_range, 2: user_type
        operator: u8,          // 0: gt, 1: lt, 2: eq, 3: between
        values: vector<u64>,
        string_values: vector<String>
    }
    
    /// ì´ë²¤íŠ¸ ë°°ì¹˜ ì²˜ë¦¬
    public fun batch_process_events(
        processor: &signer,
        registry_addr: address,
        event_batch: vector<PendingEvent>
    ) acquires EventRegistry {
        let registry = borrow_global_mut<EventRegistry>(registry_addr);
        let processed_count = 0;
        
        while (!vector::is_empty(&event_batch) && processed_count < 100) {  // ë°°ì¹˜ í¬ê¸° ì œí•œ
            let pending_event = vector::pop_back(&mut event_batch);
            
            // ì´ë²¤íŠ¸ ìœ íš¨ì„± ê²€ì‚¬
            if (validate_event(&pending_event)) {
                process_single_event(registry, pending_event);
                processed_count = processed_count + 1;
            }
        };
        
        vector::destroy_empty(event_batch);
    }
    
    struct PendingEvent has drop {
        event_type: u8,
        payload: vector<u8>,
        priority: u8,
        retry_count: u8,
        max_retries: u8
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun generate_correlation_id(user: address): String {
        // ì‚¬ìš©ì ì£¼ì†Œì™€ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ì¡°í•©í•œ ê³ ìœ  ID ìƒì„±
        string::utf8(b"corr_id_placeholder")
    }
    
    fun create_metadata_table(pairs: vector<(String, String)>): SmartTable<String, String> {
        let table = smart_table::new();
        let i = 0;
        
        while (i < vector::length(&pairs)) {
            let (key, value) = *vector::borrow(&pairs, i);
            smart_table::add(&mut table, key, value);
            i = i + 1;
        };
        
        table
    }
    
    fun update_event_statistics(stats: &mut EventStatistics, event_count: u64) {
        stats.total_events = stats.total_events + event_count;
    }
    
    fun evaluate_event_condition(condition: &EventCondition, event: &UserEvent): bool {
        // ì¡°ê±´ í‰ê°€ ë¡œì§
        true  // placeholder
    }
    
    fun validate_event(event: &PendingEvent): bool {
        // ì´ë²¤íŠ¸ ìœ íš¨ì„± ê²€ì‚¬
        true  // placeholder
    }
    
    fun process_single_event(registry: &mut EventRegistry, event: PendingEvent) {
        // ë‹¨ì¼ ì´ë²¤íŠ¸ ì²˜ë¦¬
    }
    
    fun emit_system_event(
        module_addr: address,
        event_type: u8,
        severity: u8,
        message: String,
        data: vector<u8>
    ) {
        // ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ë°œìƒ
    }
}
```

## ğŸ­ ê³ ê¸‰ Object ê´€ë¦¬

### Object ë¼ì´í”„ì‚¬ì´í´ ë° ì†Œìœ ê¶Œ ê´€ë¦¬
```move
module advanced_objects {
    use std::signer;
    use std::vector;
    use std::option::{Self, Option};
    use std::string::String;
    use aptos_framework::object::{Self, Object, ConstructorRef, DeleteRef};
    use aptos_framework::timestamp;
    use aptos_std::smart_table::{Self, SmartTable};
    
    /// ê³ ê¸‰ ê°ì²´ ê´€ë¦¬ì
    struct ObjectManager has key {
        objects: SmartTable<address, ManagedObject>,
        object_types: SmartTable<String, ObjectTypeConfig>,
        ownership_history: SmartTable<address, vector<OwnershipRecord>>,
        lifecycle_hooks: SmartTable<String, vector<HookFunction>>,
        total_objects: u64
    }
    
    /// ê´€ë¦¬ë˜ëŠ” ê°ì²´ ì •ë³´
    struct ManagedObject has store, drop {
        object_address: address,
        object_type: String,
        owner: address,
        created_at: u64,
        last_modified: u64,
        status: u8,           // 0: active, 1: suspended, 2: deprecated, 3: deleted
        metadata: SmartTable<String, String>,
        access_permissions: vector<address>,
        lifecycle_stage: u8   // 0: created, 1: initialized, 2: active, 3: archived
    }
    
    /// ê°ì²´ íƒ€ì… ì„¤ì •
    struct ObjectTypeConfig has store, drop {
        type_name: String,
        max_instances: Option<u64>,
        current_instances: u64,
        default_permissions: vector<address>,
        required_capabilities: vector<String>,
        lifecycle_rules: vector<LifecycleRule>
    }
    
    /// ì†Œìœ ê¶Œ ê¸°ë¡
    struct OwnershipRecord has store, drop, copy {
        previous_owner: address,
        new_owner: address,
        transfer_time: u64,
        transfer_reason: String,
        approved_by: Option<address>
    }
    
    /// ë¼ì´í”„ì‚¬ì´í´ ê·œì¹™
    struct LifecycleRule has store, drop, copy {
        stage: u8,            // ì ìš©í•  ë¼ì´í”„ì‚¬ì´í´ ë‹¨ê³„
        condition: RuleCondition,
        action: RuleAction,
        auto_execute: bool
    }
    
    struct RuleCondition has store, drop, copy {
        condition_type: u8,   // 0: time_based, 1: usage_based, 2: owner_based
        parameters: vector<u64>
    }
    
    struct RuleAction has store, drop, copy {
        action_type: u8,      // 0: transfer, 1: delete, 2: archive, 3: notify
        target: Option<address>,
        parameters: vector<u64>
    }
    
    /// í›… í•¨ìˆ˜ ì •ì˜
    struct HookFunction has store, drop, copy {
        hook_type: u8,        // 0: pre_create, 1: post_create, 2: pre_transfer, 3: post_transfer
        function_name: String,
        module_address: address
    }
    
    /// ê°ì²´ ê´€ë¦¬ì ì´ˆê¸°í™”
    public fun initialize_object_manager(admin: &signer) {
        move_to(admin, ObjectManager {
            objects: smart_table::new(),
            object_types: smart_table::new(),
            ownership_history: smart_table::new(),
            lifecycle_hooks: smart_table::new(),
            total_objects: 0
        });
    }
    
    /// ê³ ê¸‰ ê°ì²´ ìƒì„± (ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ í¬í•¨)
    public fun create_managed_object<T: key>(
        creator: &signer,
        manager_addr: address,
        object_type: String,
        initial_metadata: vector<(String, String)>,
        permissions: vector<address>
    ): Object<T> acquires ObjectManager {
        let creator_addr = signer::address_of(creator);
        let manager = borrow_global_mut<ObjectManager>(manager_addr);
        
        // ê°ì²´ íƒ€ì… ì œí•œ í™•ì¸
        if (smart_table::contains(&manager.object_types, object_type)) {
            let type_config = smart_table::borrow_mut(&mut manager.object_types, object_type);
            
            if (option::is_some(&type_config.max_instances)) {
                let max = *option::borrow(&type_config.max_instances);
                assert!(type_config.current_instances < max, E_OBJECT_LIMIT_EXCEEDED);
            };
            
            type_config.current_instances = type_config.current_instances + 1;
        };
        
        // í”„ë¦¬ ìƒì„± í›… ì‹¤í–‰
        execute_lifecycle_hooks(&manager.lifecycle_hooks, object_type, 0);  // pre_create
        
        // ê°ì²´ ìƒì„±
        let constructor_ref = object::create_object(creator_addr);
        let object_signer = object::generate_signer(&constructor_ref);
        let object_addr = signer::address_of(&object_signer);
        
        // ê°ì²´ ì •ë³´ ë“±ë¡
        let current_time = timestamp::now_seconds();
        let metadata_table = create_metadata_table(initial_metadata);
        
        let managed_obj = ManagedObject {
            object_address: object_addr,
            object_type,
            owner: creator_addr,
            created_at: current_time,
            last_modified: current_time,
            status: 0,  // active
            metadata: metadata_table,
            access_permissions: permissions,
            lifecycle_stage: 0  // created
        };
        
        smart_table::add(&mut manager.objects, object_addr, managed_obj);
        
        // ì†Œìœ ê¶Œ ê¸°ë¡ ì´ˆê¸°í™”
        smart_table::add(&mut manager.ownership_history, object_addr, vector::empty());
        
        manager.total_objects = manager.total_objects + 1;
        
        // í¬ìŠ¤íŠ¸ ìƒì„± í›… ì‹¤í–‰
        execute_lifecycle_hooks(&manager.lifecycle_hooks, object_type, 1);  // post_create
        
        object::object_from_constructor_ref<T>(&constructor_ref)
    }
    
    /// ì•ˆì „í•œ ê°ì²´ ì „ì†¡ (ë‹¤ë‹¨ê³„ ìŠ¹ì¸)
    public fun safe_transfer_object<T: key>(
        current_owner: &signer,
        manager_addr: address,
        object: Object<T>,
        new_owner: address,
        transfer_reason: String,
        require_approval: bool
    ) acquires ObjectManager {
        let current_owner_addr = signer::address_of(current_owner);
        let object_addr = object::object_address(&object);
        let manager = borrow_global_mut<ObjectManager>(manager_addr);
        
        assert!(smart_table::contains(&manager.objects, object_addr), E_OBJECT_NOT_FOUND);
        let managed_obj = smart_table::borrow_mut(&mut manager.objects, object_addr);
        
        // ì†Œìœ ê¶Œ í™•ì¸
        assert!(managed_obj.owner == current_owner_addr, E_NOT_OWNER);
        assert!(managed_obj.status == 0, E_OBJECT_NOT_ACTIVE);
        
        // í”„ë¦¬ ì „ì†¡ í›… ì‹¤í–‰
        execute_lifecycle_hooks(&manager.lifecycle_hooks, managed_obj.object_type, 2);  // pre_transfer
        
        if (require_approval) {
            // ìŠ¹ì¸ ëŒ€ê¸° ìƒíƒœë¡œ ì„¤ì •
            managed_obj.status = 1;  // suspended
            create_transfer_approval_request(manager, object_addr, new_owner, transfer_reason);
        } else {
            // ì¦‰ì‹œ ì „ì†¡ ì‹¤í–‰
            execute_transfer(manager, object_addr, current_owner_addr, new_owner, transfer_reason);
        }
    }
    
    /// ì „ì†¡ ìŠ¹ì¸ ì²˜ë¦¬
    public fun approve_transfer(
        approver: &signer,
        manager_addr: address,
        object_addr: address
    ) acquires ObjectManager {
        let approver_addr = signer::address_of(approver);
        let manager = borrow_global_mut<ObjectManager>(manager_addr);
        
        // ìŠ¹ì¸ ê¶Œí•œ í™•ì¸ (ì˜ˆ: ê´€ë¦¬ì ë˜ëŠ” ì§€ì •ëœ ìŠ¹ì¸ì)
        assert!(has_approval_permission(approver_addr), E_NO_APPROVAL_PERMISSION);
        
        let managed_obj = smart_table::borrow(&manager.objects, object_addr);
        assert!(managed_obj.status == 1, E_NOT_PENDING_APPROVAL);
        
        // ìŠ¹ì¸ ì²˜ë¦¬ ë¡œì§ êµ¬í˜„ í•„ìš”
        // execute_pending_transfer(manager, object_addr, approver_addr);
    }
    
    /// ê°ì²´ ì•„ì¹´ì´ë¸Œ (ì†Œí”„íŠ¸ ì‚­ì œ)
    public fun archive_object<T: key>(
        owner: &signer,
        manager_addr: address,
        object: Object<T>,
        archive_reason: String
    ) acquires ObjectManager {
        let owner_addr = signer::address_of(owner);
        let object_addr = object::object_address(&object);
        let manager = borrow_global_mut<ObjectManager>(manager_addr);
        
        assert!(smart_table::contains(&manager.objects, object_addr), E_OBJECT_NOT_FOUND);
        let managed_obj = smart_table::borrow_mut(&mut manager.objects, object_addr);
        
        assert!(managed_obj.owner == owner_addr, E_NOT_OWNER);
        assert!(managed_obj.status == 0, E_OBJECT_NOT_ACTIVE);
        
        // ì•„ì¹´ì´ë¸Œ ì²˜ë¦¬
        managed_obj.status = 3;  // archived
        managed_obj.lifecycle_stage = 3;  // archived
        managed_obj.last_modified = timestamp::now_seconds();
        
        // ì•„ì¹´ì´ë¸Œ ë©”íƒ€ë°ì´í„° ì¶”ê°€
        smart_table::add(&mut managed_obj.metadata, 
                        string::utf8(b"archive_reason"), 
                        archive_reason);
        smart_table::add(&mut managed_obj.metadata, 
                        string::utf8(b"archived_at"), 
                        u64_to_string(timestamp::now_seconds()));
    }
    
    /// ë¼ì´í”„ì‚¬ì´í´ ìë™í™” ì‹¤í–‰
    public fun execute_lifecycle_automation(
        executor: &signer,
        manager_addr: address
    ) acquires ObjectManager {
        let manager = borrow_global_mut<ObjectManager>(manager_addr);
        let current_time = timestamp::now_seconds();
        
        // ëª¨ë“  ê°ì²´ì— ëŒ€í•´ ë¼ì´í”„ì‚¬ì´í´ ê·œì¹™ í™•ì¸
        smart_table::for_each_mut(&mut manager.objects, |object_addr, managed_obj| {
            let object_type = managed_obj.object_type;
            
            if (smart_table::contains(&manager.object_types, object_type)) {
                let type_config = smart_table::borrow(&manager.object_types, object_type);
                
                // ê° ë¼ì´í”„ì‚¬ì´í´ ê·œì¹™ í‰ê°€
                let i = 0;
                while (i < vector::length(&type_config.lifecycle_rules)) {
                    let rule = vector::borrow(&type_config.lifecycle_rules, i);
                    
                    if (rule.auto_execute && 
                        managed_obj.lifecycle_stage == rule.stage &&
                        evaluate_rule_condition(&rule.condition, managed_obj, current_time)) {
                        
                        execute_rule_action(&rule.action, managed_obj, *object_addr);
                    };
                    
                    i = i + 1;
                }
            }
        });
    }
    
    /// ê°ì²´ ì¿¼ë¦¬ ì‹œìŠ¤í…œ
    public fun query_objects(
        manager_addr: address,
        filters: vector<ObjectFilter>
    ): vector<address> acquires ObjectManager {
        let manager = borrow_global<ObjectManager>(manager_addr);
        let results = vector::empty();
        
        smart_table::for_each_ref(&manager.objects, |object_addr, managed_object| {
            if (matches_all_filters(managed_object, &filters)) {
                vector::push_back(&mut results, *object_addr);
            }
        });
        
        results
    }
    
    struct ObjectFilter has drop {
        field: String,        // "object_type", "owner", "status", "created_at" ë“±
        operator: u8,         // 0: eq, 1: gt, 2: lt, 3: contains
        value: vector<u8>
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun create_metadata_table(pairs: vector<(String, String)>): SmartTable<String, String> {
        let table = smart_table::new();
        let i = 0;
        
        while (i < vector::length(&pairs)) {
            let (key, value) = *vector::borrow(&pairs, i);
            smart_table::add(&mut table, key, value);
            i = i + 1;
        };
        
        table
    }
    
    fun execute_lifecycle_hooks(
        hooks: &SmartTable<String, vector<HookFunction>>,
        object_type: String,
        hook_type: u8
    ) {
        // ë¼ì´í”„ì‚¬ì´í´ í›… ì‹¤í–‰
    }
    
    fun create_transfer_approval_request(
        manager: &mut ObjectManager,
        object_addr: address,
        new_owner: address,
        reason: String
    ) {
        // ì „ì†¡ ìŠ¹ì¸ ìš”ì²­ ìƒì„±
    }
    
    fun execute_transfer(
        manager: &mut ObjectManager,
        object_addr: address,
        old_owner: address,
        new_owner: address,
        reason: String
    ) {
        let managed_obj = smart_table::borrow_mut(&mut manager.objects, object_addr);
        managed_obj.owner = new_owner;
        managed_obj.last_modified = timestamp::now_seconds();
        managed_obj.status = 0;  // active
        
        // ì†Œìœ ê¶Œ ê¸°ë¡ ì¶”ê°€
        let ownership_record = OwnershipRecord {
            previous_owner: old_owner,
            new_owner,
            transfer_time: timestamp::now_seconds(),
            transfer_reason: reason,
            approved_by: option::none()
        };
        
        let history = smart_table::borrow_mut(&mut manager.ownership_history, object_addr);
        vector::push_back(history, ownership_record);
        
        // í¬ìŠ¤íŠ¸ ì „ì†¡ í›… ì‹¤í–‰
        execute_lifecycle_hooks(&manager.lifecycle_hooks, managed_obj.object_type, 3);  // post_transfer
    }
    
    fun has_approval_permission(addr: address): bool {
        // ìŠ¹ì¸ ê¶Œí•œ í™•ì¸
        true  // placeholder
    }
    
    fun evaluate_rule_condition(
        condition: &RuleCondition,
        object: &ManagedObject,
        current_time: u64
    ): bool {
        match (condition.condition_type) {
            0 => {  // time_based
                let threshold = *vector::borrow(&condition.parameters, 0);
                current_time - object.created_at >= threshold
            },
            1 => {  // usage_based
                // ì‚¬ìš©ëŸ‰ ê¸°ë°˜ ì¡°ê±´ í‰ê°€
                true  // placeholder
            },
            2 => {  // owner_based
                // ì†Œìœ ì ê¸°ë°˜ ì¡°ê±´ í‰ê°€
                true  // placeholder
            },
            _ => false
        }
    }
    
    fun execute_rule_action(
        action: &RuleAction,
        object: &mut ManagedObject,
        object_addr: address
    ) {
        match (action.action_type) {
            0 => {  // transfer
                // ìë™ ì „ì†¡ ì‹¤í–‰
            },
            1 => {  // delete
                object.status = 3;  // deleted
            },
            2 => {  // archive
                object.status = 2;  // archived
                object.lifecycle_stage = 3;
            },
            3 => {  // notify
                // ì•Œë¦¼ ë°œì†¡
            },
            _ => {}
        }
    }
    
    fun matches_all_filters(object: &ManagedObject, filters: &vector<ObjectFilter>): bool {
        let i = 0;
        while (i < vector::length(filters)) {
            let filter = vector::borrow(filters, i);
            if (!matches_filter(object, filter)) {
                return false
            };
            i = i + 1;
        };
        true
    }
    
    fun matches_filter(object: &ManagedObject, filter: &ObjectFilter): bool {
        // í•„í„° ë§¤ì¹­ ë¡œì§
        true  // placeholder
    }
    
    fun u64_to_string(value: u64): String {
        // u64ë¥¼ Stringìœ¼ë¡œ ë³€í™˜
        string::utf8(b"placeholder")
    }
}
```

## ğŸ‘¤ ê³ ê¸‰ Signer íŒ¨í„´

### ë‹¤ì¤‘ ì„œëª…ì ë° ìœ„ì„ íŒ¨í„´
```move
module advanced_signer {
    use std::signer;
    use std::vector;
    use std::option::{Self, Option};
    use aptos_framework::account::{Self, SignerCapability};
    use aptos_framework::timestamp;
    use aptos_std::smart_table::{Self, SmartTable};
    
    /// ê³ ê¸‰ ì„œëª…ì ê´€ë¦¬ ì‹œìŠ¤í…œ
    struct SignerManager has key {
        // ì„œëª…ì ê³„ì¸µ êµ¬ì¡°
        signer_hierarchy: SmartTable<address, SignerNode>,
        
        // ìœ„ì„ëœ ì„œëª… ê¶Œí•œ
        delegated_capabilities: SmartTable<address, vector<DelegatedSigner>>,
        
        // ë‹¤ì¤‘ ì„œëª… êµ¬ì„±
        multisig_configs: SmartTable<String, MultiSigConfig>,
        
        // ì¡°ê±´ë¶€ ì„œëª…ì
        conditional_signers: SmartTable<address, vector<ConditionalSigner>>,
        
        // ì„œëª… ì„¸ì…˜ ê´€ë¦¬
        active_sessions: SmartTable<String, SigningSession>
    }
    
    /// ì„œëª…ì ë…¸ë“œ (ê³„ì¸µ êµ¬ì¡°)
    struct SignerNode has store, drop {
        address: address,
        level: u8,              // ê¶Œí•œ ë ˆë²¨ (0ì´ ìµœê³ )
        parent: Option<address>,
        children: vector<address>,
        permissions: vector<String>,
        is_active: bool
    }
    
    /// ìœ„ì„ëœ ì„œëª…ì
    struct DelegatedSigner has store, drop {
        delegate: address,
        delegator: address,
        permissions: vector<String>,
        start_time: u64,
        end_time: u64,
        usage_limit: Option<u64>,
        current_usage: u64,
        conditions: vector<DelegationCondition>
    }
    
    /// ìœ„ì„ ì¡°ê±´
    struct DelegationCondition has store, drop, copy {
        condition_type: u8,     // 0: amount_limit, 1: time_window, 2: resource_type
        parameters: vector<u64>,
        string_params: vector<String>
    }
    
    /// ë‹¤ì¤‘ ì„œëª… êµ¬ì„±
    struct MultiSigConfig has store, drop {
        name: String,
        required_signatures: u64,
        authorized_signers: vector<address>,
        signer_weights: SmartTable<address, u64>,  // ê°€ì¤‘ ì„œëª…
        total_weight: u64,
        required_weight: u64,
        timeout_seconds: u64
    }
    
    /// ì¡°ê±´ë¶€ ì„œëª…ì
    struct ConditionalSigner has store, drop {
        signer_addr: address,
        conditions: vector<SignerCondition>,
        fallback_signer: Option<address>,
        max_attempts: u64,
        current_attempts: u64
    }
    
    struct SignerCondition has store, drop, copy {
        condition_type: u8,     // 0: time_based, 1: amount_based, 2: frequency_based
        operator: u8,           // 0: eq, 1: gt, 2: lt, 3: between
        threshold: u64,
        timeframe: Option<u64>
    }
    
    /// ì„œëª… ì„¸ì…˜
    struct SigningSession has store, drop {
        session_id: String,
        initiator: address,
        required_signers: vector<address>,
        received_signatures: SmartTable<address, Signature>,
        operation_data: vector<u8>,
        created_at: u64,
        expires_at: u64,
        status: u8              // 0: pending, 1: completed, 2: expired, 3: cancelled
    }
    
    struct Signature has store, drop, copy {
        signer: address,
        signature_data: vector<u8>,
        signed_at: u64,
        conditions_met: bool
    }
    
    /// ì„œëª…ì ê´€ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    public fun initialize_signer_manager(admin: &signer) {
        move_to(admin, SignerManager {
            signer_hierarchy: smart_table::new(),
            delegated_capabilities: smart_table::new(),
            multisig_configs: smart_table::new(),
            conditional_signers: smart_table::new(),
            active_sessions: smart_table::new()
        });
    }
    
    /// ê³„ì¸µì  ì„œëª…ì ë“±ë¡
    public fun register_hierarchical_signer(
        admin: &signer,
        manager_addr: address,
        signer_addr: address,
        level: u8,
        parent: Option<address>,
        permissions: vector<String>
    ) acquires SignerManager {
        let manager = borrow_global_mut<SignerManager>(manager_addr);
        
        // ë¶€ëª¨ ë…¸ë“œ í™•ì¸ ë° ì—…ë°ì´íŠ¸
        if (option::is_some(&parent)) {
            let parent_addr = *option::borrow(&parent);
            assert!(smart_table::contains(&manager.signer_hierarchy, parent_addr), E_PARENT_NOT_FOUND);
            
            let parent_node = smart_table::borrow_mut(&mut manager.signer_hierarchy, parent_addr);
            vector::push_back(&mut parent_node.children, signer_addr);
        };
        
        let signer_node = SignerNode {
            address: signer_addr,
            level,
            parent,
            children: vector::empty(),
            permissions,
            is_active: true
        };
        
        smart_table::add(&mut manager.signer_hierarchy, signer_addr, signer_node);
    }
    
    /// ì¡°ê±´ë¶€ ì„œëª… ì‹¤í–‰
    public fun conditional_sign<T>(
        signer: &signer,
        manager_addr: address,
        operation: |&signer|T,
        context: vector<u64>
    ): T acquires SignerManager {
        let signer_addr = signer::address_of(signer);
        let manager = borrow_global_mut<SignerManager>(manager_addr);
        
        // ì¡°ê±´ë¶€ ì„œëª…ì í™•ì¸
        if (smart_table::contains(&manager.conditional_signers, signer_addr)) {
            let conditional_signers = smart_table::borrow_mut(&mut manager.conditional_signers, signer_addr);
            let i = 0;
            
            while (i < vector::length(conditional_signers)) {
                let conditional_signer = vector::borrow_mut(conditional_signers, i);
                
                // ìµœëŒ€ ì‹œë„ íšŸìˆ˜ í™•ì¸
                if (conditional_signer.current_attempts >= conditional_signer.max_attempts) {
                    // í´ë°± ì„œëª…ì ì‚¬ìš©
                    if (option::is_some(&conditional_signer.fallback_signer)) {
                        let fallback_addr = *option::borrow(&conditional_signer.fallback_signer);
                        let fallback_signer = create_signer_from_address(fallback_addr);
                        return operation(&fallback_signer)
                    };
                    
                    abort E_MAX_ATTEMPTS_EXCEEDED
                };
                
                // ì¡°ê±´ í™•ì¸
                if (evaluate_signer_conditions(&conditional_signer.conditions, &context)) {
                    conditional_signer.current_attempts = conditional_signer.current_attempts + 1;
                    return operation(signer)
                };
                
                i = i + 1;
            }
        };
        
        // ì¼ë°˜ ì„œëª… ì‹¤í–‰
        operation(signer)
    }
    
    /// ë‹¤ì¤‘ ì„œëª… ì„¸ì…˜ ì‹œì‘
    public fun start_multisig_session(
        initiator: &signer,
        manager_addr: address,
        config_name: String,
        operation_data: vector<u8>,
        timeout_seconds: u64
    ): String acquires SignerManager {
        let initiator_addr = signer::address_of(initiator);
        let manager = borrow_global_mut<SignerManager>(manager_addr);
        
        assert!(smart_table::contains(&manager.multisig_configs, config_name), E_CONFIG_NOT_FOUND);
        let config = smart_table::borrow(&manager.multisig_configs, config_name);
        
        // ì„¸ì…˜ ID ìƒì„±
        let session_id = generate_session_id(initiator_addr, config_name);
        let current_time = timestamp::now_seconds();
        
        let session = SigningSession {
            session_id,
            initiator: initiator_addr,
            required_signers: config.authorized_signers,
            received_signatures: smart_table::new(),
            operation_data,
            created_at: current_time,
            expires_at: current_time + timeout_seconds,
            status: 0  // pending
        };
        
        smart_table::add(&mut manager.active_sessions, session_id, session);
        session_id
    }
    
    /// ë‹¤ì¤‘ ì„œëª… ì„¸ì…˜ì— ì„œëª…
    public fun sign_multisig_session(
        signer: &signer,
        manager_addr: address,
        session_id: String,
        signature_data: vector<u8>
    ): bool acquires SignerManager {
        let signer_addr = signer::address_of(signer);
        let manager = borrow_global_mut<SignerManager>(manager_addr);
        
        assert!(smart_table::contains(&manager.active_sessions, session_id), E_SESSION_NOT_FOUND);
        let session = smart_table::borrow_mut(&mut manager.active_sessions, session_id);
        
        // ì„¸ì…˜ ìƒíƒœ í™•ì¸
        assert!(session.status == 0, E_SESSION_NOT_PENDING);
        assert!(timestamp::now_seconds() <= session.expires_at, E_SESSION_EXPIRED);
        
        // ì„œëª…ì ê¶Œí•œ í™•ì¸
        assert!(vector::contains(&session.required_signers, &signer_addr), E_NOT_AUTHORIZED_SIGNER);
        assert!(!smart_table::contains(&session.received_signatures, signer_addr), E_ALREADY_SIGNED);
        
        // ì„œëª… ì¶”ê°€
        let signature = Signature {
            signer: signer_addr,
            signature_data,
            signed_at: timestamp::now_seconds(),
            conditions_met: true  // ì¡°ê±´ ê²€ì¦ ê²°ê³¼
        };
        
        smart_table::add(&mut session.received_signatures, signer_addr, signature);
        
        // ì™„ë£Œ ì¡°ê±´ í™•ì¸
        check_multisig_completion(manager, session_id)
    }
    
    /// ê°€ì¤‘ ë‹¤ì¤‘ ì„œëª… ì²˜ë¦¬
    public fun weighted_multisig_sign(
        signer: &signer,
        manager_addr: address,
        config_name: String,
        session_id: String,
        signature_data: vector<u8>
    ): bool acquires SignerManager {
        let signer_addr = signer::address_of(signer);
        let manager = borrow_global_mut<SignerManager>(manager_addr);
        
        assert!(smart_table::contains(&manager.multisig_configs, config_name), E_CONFIG_NOT_FOUND);
        let config = smart_table::borrow(&manager.multisig_configs, config_name);
        
        // ì„œëª…ì ê°€ì¤‘ì¹˜ í™•ì¸
        assert!(smart_table::contains(&config.signer_weights, signer_addr), E_NO_WEIGHT_ASSIGNED);
        let signer_weight = *smart_table::borrow(&config.signer_weights, signer_addr);
        
        // ì„¸ì…˜ì— ì„œëª… ì¶”ê°€
        let success = sign_multisig_session(signer, manager_addr, session_id, signature_data);
        
        if (success) {
            // ê°€ì¤‘ì¹˜ ê¸°ë°˜ ì™„ë£Œ í™•ì¸
            check_weighted_completion(manager, session_id, config)
        } else {
            false
        }
    }
    
    /// ì„œëª… ìœ„ì„ ìƒì„±
    public fun create_signing_delegation(
        delegator: &signer,
        manager_addr: address,
        delegate: address,
        permissions: vector<String>,
        duration_seconds: u64,
        usage_limit: Option<u64>,
        conditions: vector<DelegationCondition>
    ) acquires SignerManager {
        let delegator_addr = signer::address_of(delegator);
        let manager = borrow_global_mut<SignerManager>(manager_addr);
        let current_time = timestamp::now_seconds();
        
        let delegated_signer = DelegatedSigner {
            delegate,
            delegator: delegator_addr,
            permissions,
            start_time: current_time,
            end_time: current_time + duration_seconds,
            usage_limit,
            current_usage: 0,
            conditions
        };
        
        if (!smart_table::contains(&manager.delegated_capabilities, delegate)) {
            smart_table::add(&mut manager.delegated_capabilities, delegate, vector::empty());
        };
        
        let delegations = smart_table::borrow_mut(&mut manager.delegated_capabilities, delegate);
        vector::push_back(delegations, delegated_signer);
    }
    
    /// ìœ„ì„ëœ ê¶Œí•œìœ¼ë¡œ ì„œëª… ì‹¤í–‰
    public fun execute_delegated_signing<T>(
        delegate: &signer,
        manager_addr: address,
        permission: String,
        operation: |&signer|T,
        context: vector<u64>
    ): T acquires SignerManager {
        let delegate_addr = signer::address_of(delegate);
        let manager = borrow_global_mut<SignerManager>(manager_addr);
        
        assert!(smart_table::contains(&manager.delegated_capabilities, delegate_addr), E_NO_DELEGATION);
        let delegations = smart_table::borrow_mut(&mut manager.delegated_capabilities, delegate_addr);
        
        let i = 0;
        while (i < vector::length(delegations)) {
            let delegation = vector::borrow_mut(delegations, i);
            
            // ê¶Œí•œ ë° ì‹œê°„ í™•ì¸
            if (vector::contains(&delegation.permissions, &permission) &&
                is_delegation_valid(delegation, &context)) {
                
                // ì‚¬ìš©ëŸ‰ ì œí•œ í™•ì¸
                if (option::is_some(&delegation.usage_limit)) {
                    let limit = *option::borrow(&delegation.usage_limit);
                    assert!(delegation.current_usage < limit, E_USAGE_LIMIT_EXCEEDED);
                };
                
                delegation.current_usage = delegation.current_usage + 1;
                
                // ì›ë˜ ìœ„ì„ìì˜ ì„œëª…ìë¡œ ì‘ì—… ì‹¤í–‰
                let delegator_signer = create_signer_from_address(delegation.delegator);
                return operation(&delegator_signer)
            };
            
            i = i + 1;
        };
        
        abort E_NO_VALID_DELEGATION
    }
    
    /// ì„œëª… ì²´ì¸ ì‹¤í–‰ (ì—°ì†ì  ì„œëª…)
    public fun execute_signature_chain<T>(
        initiator: &signer,
        manager_addr: address,
        chain_config: SignatureChain,
        operation: |vector<&signer>|T
    ): T acquires SignerManager {
        let manager = borrow_global<SignerManager>(manager_addr);
        let signers = vector::empty();
        
        let i = 0;
        while (i < vector::length(&chain_config.required_signers)) {
            let signer_addr = *vector::borrow(&chain_config.required_signers, i);
            
            // ê° ë‹¨ê³„ë³„ ì¡°ê±´ í™•ì¸
            let stage_conditions = *vector::borrow(&chain_config.stage_conditions, i);
            assert!(evaluate_chain_conditions(&stage_conditions), E_CHAIN_CONDITION_FAILED);
            
            // ì„œëª…ì ìƒì„± (ì‹¤ì œë¡œëŠ” ê° ì„œëª…ìì˜ ìŠ¹ì¸ í•„ìš”)
            let stage_signer = get_authorized_signer(manager, signer_addr, i);
            vector::push_back(&mut signers, stage_signer);
            
            i = i + 1;
        };
        
        operation(signers)
    }
    
    struct SignatureChain has drop {
        required_signers: vector<address>,
        stage_conditions: vector<vector<u64>>,
        execution_order: u8,  // 0: sequential, 1: parallel
        timeout_per_stage: u64
    }
    
    /// ì„œëª… ê°ì‚¬ ë° ì¶”ì 
    public fun audit_signing_activity(
        auditor: &signer,
        manager_addr: address,
        target_signer: address,
        time_range: (u64, u64)
    ): SigningAuditReport acquires SignerManager {
        let manager = borrow_global<SignerManager>(manager_addr);
        let (start_time, end_time) = time_range;
        
        // ì„œëª… í™œë™ ìˆ˜ì§‘
        let activities = vector::empty();
        
        // ë‹¤ì¤‘ ì„œëª… ì°¸ì—¬ ê¸°ë¡
        smart_table::for_each_ref(&manager.active_sessions, |session_id, session| {
            if (session.created_at >= start_time && session.created_at <= end_time) {
                if (smart_table::contains(&session.received_signatures, target_signer)) {
                    let signature = smart_table::borrow(&session.received_signatures, target_signer);
                    let activity = SigningActivity {
                        activity_type: 0,  // multisig
                        timestamp: signature.signed_at,
                        session_id: *session_id,
                        success: signature.conditions_met
                    };
                    vector::push_back(&mut activities, activity);
                }
            }
        });
        
        // ìœ„ì„ í™œë™ ê¸°ë¡
        if (smart_table::contains(&manager.delegated_capabilities, target_signer)) {
            let delegations = smart_table::borrow(&manager.delegated_capabilities, target_signer);
            let i = 0;
            while (i < vector::length(delegations)) {
                let delegation = vector::borrow(delegations, i);
                if (delegation.current_usage > 0) {
                    let activity = SigningActivity {
                        activity_type: 1,  // delegation
                        timestamp: delegation.start_time,
                        session_id: string::utf8(b"delegation"),
                        success: true
                    };
                    vector::push_back(&mut activities, activity);
                };
                i = i + 1;
            }
        };
        
        SigningAuditReport {
            target_signer,
            audit_period: time_range,
            activities,
            total_activities: vector::length(&activities),
            risk_assessment: calculate_signing_risk(&activities)
        }
    }
    
    struct SigningActivity has store, drop {
        activity_type: u8,     // 0: multisig, 1: delegation, 2: conditional
        timestamp: u64,
        session_id: String,
        success: bool
    }
    
    struct SigningAuditReport has drop {
        target_signer: address,
        audit_period: (u64, u64),
        activities: vector<SigningActivity>,
        total_activities: u64,
        risk_assessment: u8    // 0: low, 1: medium, 2: high, 3: critical
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun evaluate_signer_conditions(
        conditions: &vector<SignerCondition>,
        context: &vector<u64>
    ): bool {
        let i = 0;
        while (i < vector::length(conditions)) {
            let condition = vector::borrow(conditions, i);
            if (!evaluate_single_signer_condition(condition, context)) {
                return false
            };
            i = i + 1;
        };
        true
    }
    
    fun evaluate_single_signer_condition(
        condition: &SignerCondition,
        context: &vector<u64>
    ): bool {
        if (condition.condition_type == 0) {  // time_based
            let current_time = timestamp::now_seconds();
            match (condition.operator) {
                1 => current_time > condition.threshold,  // gt
                2 => current_time < condition.threshold,  // lt
                _ => current_time == condition.threshold  // eq
            }
        } else if (condition.condition_type == 1) {  // amount_based
            if (vector::is_empty(context)) return false;
            let amount = *vector::borrow(context, 0);
            match (condition.operator) {
                1 => amount > condition.threshold,
                2 => amount < condition.threshold,
                _ => amount == condition.threshold
            }
        } else {
            true  // ê¸°íƒ€ ì¡°ê±´ì€ í†µê³¼
        }
    }
    
    fun generate_session_id(initiator: address, config_name: String): String {
        // ê³ ìœ  ì„¸ì…˜ ID ìƒì„±
        string::utf8(b"session_placeholder")
    }
    
    fun check_multisig_completion(
        manager: &mut SignerManager,
        session_id: String
    ): bool {
        let session = smart_table::borrow_mut(&mut manager.active_sessions, session_id);
        let signature_count = smart_table::length(&session.received_signatures);
        
        // í•„ìš”í•œ ì„œëª… ìˆ˜ í™•ì¸ (ì‹¤ì œë¡œëŠ” ì„¤ì •ì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨)
        let required_count = vector::length(&session.required_signers);
        
        if (signature_count >= required_count) {
            session.status = 1;  // completed
            true
        } else {
            false
        }
    }
    
    fun check_weighted_completion(
        manager: &mut SignerManager,
        session_id: String,
        config: &MultiSigConfig
    ): bool {
        let session = smart_table::borrow(&manager.active_sessions, session_id);
        let mut total_weight = 0;
        
        smart_table::for_each_ref(&session.received_signatures, |signer_addr, _signature| {
            if (smart_table::contains(&config.signer_weights, *signer_addr)) {
                let weight = *smart_table::borrow(&config.signer_weights, *signer_addr);
                total_weight = total_weight + weight;
            }
        });
        
        total_weight >= config.required_weight
    }
    
    fun is_delegation_valid(
        delegation: &DelegatedSigner,
        context: &vector<u64>
    ): bool {
        let current_time = timestamp::now_seconds();
        
        // ì‹œê°„ ë²”ìœ„ í™•ì¸
        if (current_time < delegation.start_time || current_time > delegation.end_time) {
            return false
        };
        
        // ì¡°ê±´ í™•ì¸
        let i = 0;
        while (i < vector::length(&delegation.conditions)) {
            let condition = vector::borrow(&delegation.conditions, i);
            if (!evaluate_delegation_condition(condition, context)) {
                return false
            };
            i = i + 1;
        };
        
        true
    }
    
    fun evaluate_delegation_condition(
        condition: &DelegationCondition,
        context: &vector<u64>
    ): bool {
        // ìœ„ì„ ì¡°ê±´ í‰ê°€
        true  // placeholder
    }
    
    fun evaluate_chain_conditions(conditions: &vector<u64>): bool {
        // ì²´ì¸ ì¡°ê±´ í‰ê°€
        true  // placeholder
    }
    
    fun get_authorized_signer(
        manager: &SignerManager,
        signer_addr: address,
        stage: u64
    ): &signer {
        // ìŠ¹ì¸ëœ ì„œëª…ì íšë“
        abort 0  // placeholder - ì‹¤ì œë¡œëŠ” ì ì ˆí•œ ì„œëª…ì ë°˜í™˜
    }
    
    fun create_signer_from_address(addr: address): signer {
        // ì£¼ì†Œì—ì„œ ì„œëª…ì ìƒì„± (ì‹¤ì œë¡œëŠ” ê¶Œí•œ í™•ì¸ í•„ìš”)
        abort 0  // placeholder
    }
    
    fun calculate_signing_risk(activities: &vector<SigningActivity>): u8 {
        // ì„œëª… í™œë™ ê¸°ë°˜ ìœ„í—˜ë„ ê³„ì‚°
        let activity_count = vector::length(activities);
        
        if (activity_count > 100) {
            3  // critical
        } else if (activity_count > 50) {
            2  // high
        } else if (activity_count > 10) {
            1  // medium
        } else {
            0  // low
        }
    }
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

Event, Object, Signer ì‹¬í™”ë¥¼ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[Access Control & Security â†’](/advanced-concepts/access-control-security)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Move ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ](https://docs.movementnetwork.xyz/events)
- [Object ëª¨ë¸ ê°€ì´ë“œ](https://docs.movementnetwork.xyz/objects)
- [Signer íŒ¨í„´ ë¬¸ì„œ](https://docs.movementnetwork.xyz/signers)

---

*ê³ ê¸‰ Move ê°œë…ìœ¼ë¡œ ì •êµí•˜ê³  ì•ˆì „í•œ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ“¡ğŸ­*