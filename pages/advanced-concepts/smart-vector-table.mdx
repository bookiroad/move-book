# ğŸ“Š Smart Vector & Smart Table

Move ì–¸ì–´ì˜ ê³ ê¸‰ ë°ì´í„° êµ¬ì¡°ì¸ Smart Vectorì™€ Smart Tableì„ ì‹¬ì¸µì ìœ¼ë¡œ ë‹¤ë£¹ë‹ˆë‹¤. íš¨ìœ¨ì ì¸ ë°ì´í„° ê´€ë¦¬ì™€ ê°€ìŠ¤ ìµœì í™”ë¥¼ ìœ„í•œ ê³ ê¸‰ íŒ¨í„´ë“¤ì„ í•™ìŠµí•©ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- Smart Vectorì˜ ê³ ê¸‰ í™œìš© íŒ¨í„´ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Smart Tableì„ ì´ìš©í•œ íš¨ìœ¨ì ì¸ ë°ì´í„° ë§¤í•‘ì„ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ê°€ìŠ¤ íš¨ìœ¨ì ì¸ ë°ì´í„° êµ¬ì¡°ë¥¼ ì„ íƒí•˜ê³  ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•œ ë°°ì¹˜ ì—°ì‚°ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ“‹ Smart Vector ì‹¬í™”

### Vector vs Smart Vector ë¹„êµ
```move
// ê¸°ë³¸ Vector (ë‹¨ìˆœ)
module basic_example {
    use std::vector;
    
    struct SimpleList has key {
        items: vector<u64>
    }
    
    // ë¬¸ì œ: ê°€ìŠ¤ ë¹„ìš©ì´ ë†’ìŒ, ê²€ìƒ‰ ë¹„íš¨ìœ¨
    public fun find_item(list: &SimpleList, target: u64): bool {
        vector::contains(&list.items, &target)  // O(n) ê²€ìƒ‰
    }
}

// Smart Vector (ìµœì í™”)
module advanced_example {
    use std::vector;
    use aptos_std::smart_vector::{Self, SmartVector};
    
    struct OptimizedList has key {
        items: SmartVector<u64>,
        sorted: bool,
        index_map: SmartVector<u64>  // ì¸ë±ìŠ¤ ë§¤í•‘
    }
    
    // ì¥ì : íš¨ìœ¨ì  ë©”ëª¨ë¦¬ ì‚¬ìš©, ë¹ ë¥¸ ì ‘ê·¼
    public fun binary_search(list: &OptimizedList, target: u64): bool {
        if (list.sorted) {
            binary_search_impl(&list.items, target)  // O(log n) ê²€ìƒ‰
        } else {
            smart_vector::contains(&list.items, &target)
        }
    }
}
```

### Smart Vector ê³ ê¸‰ íŒ¨í„´

#### 1. ë™ì  í¬ê¸° ì¡°ì ˆê³¼ ë©”ëª¨ë¦¬ ìµœì í™”
```move
module dynamic_vector {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::option::{Self, Option};
    
    /// ë™ì ìœ¼ë¡œ í¬ê¸°ê°€ ë³€í•˜ëŠ” ìŠ¤ë§ˆíŠ¸ ë²¡í„°
    struct DynamicContainer<T: store> has key {
        data: SmartVector<T>,
        capacity: u64,
        auto_resize: bool,
        growth_factor: u64  // ì„±ì¥ ë¹„ìœ¨ (ì˜ˆ: 150 = 1.5ë°°)
    }
    
    /// ì»¨í…Œì´ë„ˆ ì´ˆê¸°í™”
    public fun create<T: store>(
        initial_capacity: u64,
        auto_resize: bool,
        growth_factor: u64
    ): DynamicContainer<T> {
        DynamicContainer {
            data: smart_vector::new(),
            capacity: initial_capacity,
            auto_resize,
            growth_factor
        }
    }
    
    /// ìŠ¤ë§ˆíŠ¸ ì¶”ê°€ (ìë™ ë¦¬ì‚¬ì´ì§•)
    public fun smart_push_back<T: store>(
        container: &mut DynamicContainer<T>,
        item: T
    ) {
        let current_size = smart_vector::length(&container.data);
        
        // ìš©ëŸ‰ í™•ì¸ ë° ìë™ í™•ì¥
        if (current_size >= container.capacity && container.auto_resize) {
            container.capacity = (container.capacity * container.growth_factor) / 100;
        };
        
        smart_vector::push_back(&mut container.data, item);
    }
    
    /// ë°°ì¹˜ ì¶”ê°€ (ê°€ìŠ¤ íš¨ìœ¨ì )
    public fun batch_push<T: store>(
        container: &mut DynamicContainer<T>,
        items: vector<T>
    ) {
        let items_len = vector::length(&items);
        let current_size = smart_vector::length(&container.data);
        
        // í•„ìš” ìš©ëŸ‰ ë¯¸ë¦¬ ê³„ì‚°
        if (current_size + items_len > container.capacity) {
            let new_capacity = current_size + items_len;
            new_capacity = (new_capacity * container.growth_factor) / 100;
            container.capacity = new_capacity;
        };
        
        // ë°°ì¹˜ë¡œ ì¶”ê°€ (ê°€ìŠ¤ ì ˆì•½)
        while (!vector::is_empty(&items)) {
            let item = vector::pop_back(&mut items);
            smart_vector::push_back(&mut container.data, item);
        };
        
        vector::destroy_empty(items);
    }
    
    /// ì¡°ê±´ë¶€ ì œê±° (í•„í„°ë§)
    public fun filter_remove<T: store + drop + copy>(
        container: &mut DynamicContainer<T>,
        predicate: |&T|bool
    ): vector<T> {
        let removed_items = vector::empty();
        let i = 0;
        let len = smart_vector::length(&container.data);
        
        while (i < len) {
            let item = smart_vector::borrow(&container.data, i);
            if (predicate(item)) {
                let removed = smart_vector::swap_remove(&mut container.data, i);
                vector::push_back(&mut removed_items, removed);
                len = len - 1;  // ê¸¸ì´ ê°ì†Œ
            } else {
                i = i + 1;
            }
        };
        
        removed_items
    }
}
```

#### 2. ì •ë ¬ ë° ê²€ìƒ‰ ìµœì í™”
```move
module sorted_vector {
    use aptos_std::smart_vector::{Self, SmartVector};
    use std::vector;
    
    /// ì •ë ¬ëœ ìŠ¤ë§ˆíŠ¸ ë²¡í„°
    struct SortedSmartVector<T: store + copy + drop> has key {
        data: SmartVector<T>,
        comparator: u8,  // 0: ascending, 1: descending
        allow_duplicates: bool
    }
    
    /// ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ì‚½ì… ìœ„ì¹˜ ì°¾ê¸°
    fun find_insert_position<T: store + copy + drop>(
        vec: &SmartVector<T>,
        item: &T,
        ascending: bool
    ): u64 {
        let len = smart_vector::length(vec);
        if (len == 0) return 0;
        
        let left = 0;
        let right = len;
        
        while (left < right) {
            let mid = (left + right) / 2;
            let mid_item = smart_vector::borrow(vec, mid);
            
            let should_go_right = if (ascending) {
                compare_items(mid_item, item) <= 0
            } else {
                compare_items(mid_item, item) >= 0
            };
            
            if (should_go_right) {
                left = mid + 1;
            } else {
                right = mid;
            }
        };
        
        left
    }
    
    /// ì •ë ¬ ìƒíƒœ ìœ ì§€í•˜ë©° ì‚½ì…
    public fun sorted_insert<T: store + copy + drop>(
        sorted_vec: &mut SortedSmartVector<T>,
        item: T
    ): bool {
        let position = find_insert_position(
            &sorted_vec.data,
            &item,
            sorted_vec.comparator == 0
        );
        
        // ì¤‘ë³µ ì²´í¬
        if (!sorted_vec.allow_duplicates && position > 0) {
            let existing = smart_vector::borrow(&sorted_vec.data, position - 1);
            if (compare_items(existing, &item) == 0) {
                return false  // ì¤‘ë³µì´ë¯€ë¡œ ì‚½ì…í•˜ì§€ ì•ŠìŒ
            }
        };
        
        smart_vector::insert(&mut sorted_vec.data, position, item);
        true
    }
    
    /// ì´ì§„ íƒìƒ‰
    public fun binary_search<T: store + copy + drop>(
        sorted_vec: &SortedSmartVector<T>,
        target: &T
    ): Option<u64> {
        let len = smart_vector::length(&sorted_vec.data);
        if (len == 0) return option::none();
        
        let left = 0;
        let right = len - 1;
        
        while (left <= right) {
            let mid = (left + right) / 2;
            let mid_item = smart_vector::borrow(&sorted_vec.data, mid);
            let cmp = compare_items(mid_item, target);
            
            if (cmp == 0) {
                return option::some(mid)
            } else if (cmp < 0) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        };
        
        option::none()
    }
    
    /// ë²”ìœ„ ê²€ìƒ‰ (ë‘ ê°’ ì‚¬ì´ì˜ ëª¨ë“  í•­ëª©)
    public fun range_search<T: store + copy + drop>(
        sorted_vec: &SortedSmartVector<T>,
        start: &T,
        end: &T
    ): vector<T> {
        let result = vector::empty();
        let len = smart_vector::length(&sorted_vec.data);
        let i = 0;
        
        while (i < len) {
            let item = smart_vector::borrow(&sorted_vec.data, i);
            let cmp_start = compare_items(item, start);
            let cmp_end = compare_items(item, end);
            
            if (cmp_start >= 0 && cmp_end <= 0) {
                vector::push_back(&mut result, *item);
            };
            
            i = i + 1;
        };
        
        result
    }
    
    // ë¹„êµ í•¨ìˆ˜ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì œë„¤ë¦­ ë¹„êµ ë¡œì§ í•„ìš”)
    fun compare_items<T>(a: &T, b: &T): u8 {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” T íƒ€ì…ì— ë”°ë¥¸ ë¹„êµ ë¡œì§
        0  // placeholder
    }
}
```

## ğŸ—ƒï¸ Smart Table ì‹¬í™”

### Smart Table ê³ ê¸‰ í™œìš©
```move
module advanced_table {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::string::{Self, String};
    use std::vector;
    use std::option::{Self, Option};
    
    /// ê³ ê¸‰ ì‚¬ìš©ì ë ˆì§€ìŠ¤íŠ¸ë¦¬
    struct UserRegistry has key {
        // ê¸°ë³¸ ë§¤í•‘: ì£¼ì†Œ -> ì‚¬ìš©ì ì •ë³´
        users: SmartTable<address, UserInfo>,
        
        // ë³´ì¡° ì¸ë±ìŠ¤ë“¤
        username_to_address: SmartTable<String, address>,
        email_to_address: SmartTable<String, address>,
        
        // í†µê³„ ì •ë³´
        total_users: u64,
        active_users: u64,
        
        // ì„¤ì •
        max_users: Option<u64>,
        require_email_verification: bool
    }
    
    struct UserInfo has store, copy, drop {
        username: String,
        email: String,
        is_active: bool,
        registration_time: u64,
        last_login: u64,
        metadata: SmartTable<String, String>  // í™•ì¥ ê°€ëŠ¥í•œ ë©”íƒ€ë°ì´í„°
    }
    
    /// ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì´ˆê¸°í™”
    public fun initialize_registry(
        admin: &signer,
        max_users: Option<u64>,
        require_email_verification: bool
    ) {
        move_to(admin, UserRegistry {
            users: smart_table::new(),
            username_to_address: smart_table::new(),
            email_to_address: smart_table::new(),
            total_users: 0,
            active_users: 0,
            max_users,
            require_email_verification
        });
    }
    
    /// ì‚¬ìš©ì ë“±ë¡ (íŠ¸ëœì­ì…˜ ì•ˆì „ì„± ë³´ì¥)
    public fun register_user(
        user: &signer,
        registry_addr: address,
        username: String,
        email: String
    ) acquires UserRegistry {
        let user_addr = signer::address_of(user);
        let registry = borrow_global_mut<UserRegistry>(registry_addr);
        
        // ìš©ëŸ‰ ì œí•œ í™•ì¸
        if (option::is_some(&registry.max_users)) {
            let max = *option::borrow(&registry.max_users);
            assert!(registry.total_users < max, E_REGISTRY_FULL);
        };
        
        // ì¤‘ë³µ í™•ì¸ (ì›ìì  ì²´í¬)
        assert!(!smart_table::contains(&registry.users, user_addr), E_USER_EXISTS);
        assert!(!smart_table::contains(&registry.username_to_address, username), E_USERNAME_TAKEN);
        assert!(!smart_table::contains(&registry.email_to_address, email), E_EMAIL_TAKEN);
        
        // ì‚¬ìš©ì ì •ë³´ ìƒì„±
        let user_info = UserInfo {
            username,
            email,
            is_active: !registry.require_email_verification,
            registration_time: timestamp::now_seconds(),
            last_login: 0,
            metadata: smart_table::new()
        };
        
        // ëª¨ë“  í…Œì´ë¸”ì— ì›ìì ìœ¼ë¡œ ì¶”ê°€
        smart_table::add(&mut registry.users, user_addr, user_info);
        smart_table::add(&mut registry.username_to_address, username, user_addr);
        smart_table::add(&mut registry.email_to_address, email, user_addr);
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        registry.total_users = registry.total_users + 1;
        if (!registry.require_email_verification) {
            registry.active_users = registry.active_users + 1;
        };
    }
    
    /// ë°°ì¹˜ ì‚¬ìš©ì ì¡°íšŒ (ê°€ìŠ¤ íš¨ìœ¨ì )
    public fun batch_get_users(
        registry_addr: address,
        addresses: vector<address>
    ): vector<Option<UserInfo>> acquires UserRegistry {
        let registry = borrow_global<UserRegistry>(registry_addr);
        let results = vector::empty();
        
        let i = 0;
        let len = vector::length(&addresses);
        
        while (i < len) {
            let addr = *vector::borrow(&addresses, i);
            let user_info = if (smart_table::contains(&registry.users, addr)) {
                option::some(*smart_table::borrow(&registry.users, addr))
            } else {
                option::none()
            };
            
            vector::push_back(&mut results, user_info);
            i = i + 1;
        };
        
        results
    }
    
    /// ì¡°ê±´ë¶€ ì‚¬ìš©ì ê²€ìƒ‰
    public fun find_users_by_criteria(
        registry_addr: address,
        active_only: bool,
        min_registration_time: Option<u64>,
        max_registration_time: Option<u64>
    ): vector<address> acquires UserRegistry {
        let registry = borrow_global<UserRegistry>(registry_addr);
        let results = vector::empty();
        
        // SmartTable ë°˜ë³µ (ë‚´ë¶€ì ìœ¼ë¡œ ìµœì í™”ë¨)
        smart_table::for_each_ref(&registry.users, |addr, user_info| {
            let matches = true;
            
            // í™œì„± ìƒíƒœ í•„í„°
            if (active_only && !user_info.is_active) {
                matches = false;
            };
            
            // ë“±ë¡ ì‹œê°„ ë²”ìœ„ í•„í„°
            if (matches && option::is_some(&min_registration_time)) {
                let min_time = *option::borrow(&min_registration_time);
                if (user_info.registration_time < min_time) {
                    matches = false;
                }
            };
            
            if (matches && option::is_some(&max_registration_time)) {
                let max_time = *option::borrow(&max_registration_time);
                if (user_info.registration_time > max_time) {
                    matches = false;
                }
            };
            
            if (matches) {
                vector::push_back(&mut results, *addr);
            }
        });
        
        results
    }
    
    /// ì‚¬ìš©ì ë©”íƒ€ë°ì´í„° ê´€ë¦¬
    public fun set_user_metadata(
        user: &signer,
        registry_addr: address,
        key: String,
        value: String
    ) acquires UserRegistry {
        let user_addr = signer::address_of(user);
        let registry = borrow_global_mut<UserRegistry>(registry_addr);
        
        assert!(smart_table::contains(&registry.users, user_addr), E_USER_NOT_FOUND);
        
        let user_info = smart_table::borrow_mut(&mut registry.users, user_addr);
        
        if (smart_table::contains(&user_info.metadata, key)) {
            *smart_table::borrow_mut(&mut user_info.metadata, key) = value;
        } else {
            smart_table::add(&mut user_info.metadata, key, value);
        }
    }
    
    /// í†µê³„ ì •ë³´ ì¡°íšŒ
    public fun get_registry_stats(registry_addr: address): (u64, u64, u64) acquires UserRegistry {
        let registry = borrow_global<UserRegistry>(registry_addr);
        (
            registry.total_users,
            registry.active_users,
            smart_table::length(&registry.users)  // ì‹¤ì œ í…Œì´ë¸” í¬ê¸°
        )
    }
}
```

## âš¡ ì„±ëŠ¥ ìµœì í™” íŒ¨í„´

### ê°€ìŠ¤ íš¨ìœ¨ì ì¸ ë°ì´í„° êµ¬ì¡° ì„ íƒ
```move
module performance_patterns {
    use aptos_std::smart_vector::{Self, SmartVector};
    use aptos_std::smart_table::{Self, SmartTable};
    use std::vector;
    
    /// ë°ì´í„° í¬ê¸°ì— ë”°ë¥¸ ìµœì  êµ¬ì¡° ì„ íƒ
    struct AdaptiveDataStructure<T: store> has key {
        small_data: vector<T>,           // < 100 items
        medium_data: SmartVector<T>,     // 100-10000 items  
        large_data: SmartTable<u64, T>,  // > 10000 items
        current_mode: u8,  // 0: small, 1: medium, 2: large
        size: u64
    }
    
    const SMALL_THRESHOLD: u64 = 100;
    const LARGE_THRESHOLD: u64 = 10000;
    
    /// ë°ì´í„° ì¶”ê°€ ì‹œ ìë™ êµ¬ì¡° ì „í™˜
    public fun adaptive_add<T: store + copy + drop>(
        container: &mut AdaptiveDataStructure<T>,
        item: T
    ) {
        container.size = container.size + 1;
        
        // êµ¬ì¡° ì „í™˜ í•„ìš”ì„± ì²´í¬
        if (container.current_mode == 0 && container.size >= SMALL_THRESHOLD) {
            migrate_to_medium(container);
            container.current_mode = 1;
        } else if (container.current_mode == 1 && container.size >= LARGE_THRESHOLD) {
            migrate_to_large(container);
            container.current_mode = 2;
        };
        
        // í˜„ì¬ ëª¨ë“œì— ë”°ë¼ ì¶”ê°€
        if (container.current_mode == 0) {
            vector::push_back(&mut container.small_data, item);
        } else if (container.current_mode == 1) {
            smart_vector::push_back(&mut container.medium_data, item);
        } else {
            smart_table::add(&mut container.large_data, container.size - 1, item);
        }
    }
    
    /// ë°°ì¹˜ ì—°ì‚° ìµœì í™”
    public fun batch_operations<T: store + copy + drop>(
        container: &mut AdaptiveDataStructure<T>,
        operations: vector<BatchOperation<T>>
    ) {
        // ì—°ì‚°ë“¤ì„ íƒ€ì…ë³„ë¡œ ê·¸ë£¹í™”
        let adds = vector::empty();
        let removes = vector::empty();
        let updates = vector::empty();
        
        while (!vector::is_empty(&operations)) {
            let op = vector::pop_back(&mut operations);
            match (op.op_type) {
                0 => vector::push_back(&mut adds, op),
                1 => vector::push_back(&mut removes, op),
                2 => vector::push_back(&mut updates, op),
                _ => {} // ë¬´ì‹œ
            }
        };
        
        // ë°°ì¹˜ë¡œ ì‹¤í–‰ (ê°€ìŠ¤ íš¨ìœ¨ì„±)
        batch_add_items(container, adds);
        batch_remove_items(container, removes);
        batch_update_items(container, updates);
    }
    
    struct BatchOperation<T: store> has drop {
        op_type: u8,  // 0: add, 1: remove, 2: update
        index: Option<u64>,
        item: Option<T>
    }
    
    fun migrate_to_medium<T: store + copy + drop>(
        container: &mut AdaptiveDataStructure<T>
    ) {
        // vectorì—ì„œ SmartVectorë¡œ ë°ì´í„° ì´ì „
        while (!vector::is_empty(&container.small_data)) {
            let item = vector::pop_back(&mut container.small_data);
            smart_vector::push_back(&mut container.medium_data, item);
        }
    }
    
    fun migrate_to_large<T: store + copy + drop>(
        container: &mut AdaptiveDataStructure<T>
    ) {
        // SmartVectorì—ì„œ SmartTableë¡œ ë°ì´í„° ì´ì „
        let i = 0;
        let len = smart_vector::length(&container.medium_data);
        
        while (i < len) {
            let item = *smart_vector::borrow(&container.medium_data, i);
            smart_table::add(&mut container.large_data, i, item);
            i = i + 1;
        };
        
        // SmartVector ì •ë¦¬
        smart_vector::clear(&mut container.medium_data);
    }
}
```

### ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ íŒ¨í„´
```move
module memory_optimization {
    use aptos_std::smart_table::{Self, SmartTable};
    use std::option::{Self, Option};
    use std::string::String;
    
    /// ë©”ëª¨ë¦¬ í’€ íŒ¨í„´ (ê°ì²´ ì¬ì‚¬ìš©)
    struct ObjectPool<T: store> has key {
        available: SmartVector<T>,
        in_use: SmartTable<u64, T>,
        next_id: u64,
        max_pool_size: u64
    }
    
    /// ê°ì²´ ëŒ€ì—¬ (ë©”ëª¨ë¦¬ ì¬ì‚¬ìš©)
    public fun borrow_object<T: store>(
        pool: &mut ObjectPool<T>
    ): (u64, Option<T>) {
        let id = pool.next_id;
        pool.next_id = pool.next_id + 1;
        
        // ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ê°ì²´ê°€ ìˆìœ¼ë©´ ì‚¬ìš©
        if (smart_vector::length(&pool.available) > 0) {
            let obj = smart_vector::pop_back(&mut pool.available);
            smart_table::add(&mut pool.in_use, id, obj);
            (id, option::none())  // ì¬ì‚¬ìš©ëœ ê°ì²´ëŠ” ë°˜í™˜í•˜ì§€ ì•ŠìŒ
        } else {
            // ìƒˆ ê°ì²´ í•„ìš”
            (id, option::some(create_new_object()))
        }
    }
    
    /// ê°ì²´ ë°˜ë‚© (í’€ë¡œ ë³µê·€)
    public fun return_object<T: store>(
        pool: &mut ObjectPool<T>,
        id: u64
    ) {
        if (smart_table::contains(&pool.in_use, id)) {
            let obj = smart_table::remove(&mut pool.in_use, id);
            
            // í’€ í¬ê¸° ì œí•œ í™•ì¸
            if (smart_vector::length(&pool.available) < pool.max_pool_size) {
                reset_object(&mut obj);  // ê°ì²´ ì´ˆê¸°í™”
                smart_vector::push_back(&mut pool.available, obj);
            }
            // í’€ì´ ê°€ë“ ì°¬ ê²½ìš° ê°ì²´ëŠ” ìë™ìœ¼ë¡œ dropë¨
        }
    }
    
    /// ì§€ì—° ë¡œë”© íŒ¨í„´ (í•„ìš”í•  ë•Œë§Œ ë¡œë“œ)
    struct LazyLoadedData<T: store> has key {
        data: SmartTable<String, T>,
        loaded_keys: SmartVector<String>,
        loader_function: String,  // ë¡œë” í•¨ìˆ˜ ì‹ë³„ì
        max_cache_size: u64
    }
    
    /// ì§€ì—° ë¡œë”©ìœ¼ë¡œ ë°ì´í„° ì¡°íšŒ
    public fun get_lazy<T: store + copy>(
        lazy_data: &mut LazyLoadedData<T>,
        key: String
    ): T {
        // ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ë°˜í™˜
        if (smart_table::contains(&lazy_data.data, key)) {
            return *smart_table::borrow(&lazy_data.data, key)
        };
        
        // ë°ì´í„° ë¡œë“œ (ì‹¤ì œë¡œëŠ” ì™¸ë¶€ í•¨ìˆ˜ í˜¸ì¶œ)
        let loaded_data = load_data_by_key<T>(key, lazy_data.loader_function);
        
        // ìºì‹œ í¬ê¸° ê´€ë¦¬ (LRU ì œê±°)
        if (smart_vector::length(&lazy_data.loaded_keys) >= lazy_data.max_cache_size) {
            let oldest_key = smart_vector::remove(&mut lazy_data.loaded_keys, 0);
            smart_table::remove(&mut lazy_data.data, oldest_key);
        };
        
        // ìƒˆ ë°ì´í„° ìºì‹œì— ì¶”ê°€
        smart_table::add(&mut lazy_data.data, key, loaded_data);
        smart_vector::push_back(&mut lazy_data.loaded_keys, key);
        
        loaded_data
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun create_new_object<T: store>(): T {
        // ìƒˆ ê°ì²´ ìƒì„± ë¡œì§
        abort 0  // placeholder
    }
    
    fun reset_object<T: store>(obj: &mut T) {
        // ê°ì²´ ì´ˆê¸°í™” ë¡œì§
    }
    
    fun load_data_by_key<T: store>(key: String, loader: String): T {
        // ì™¸ë¶€ì—ì„œ ë°ì´í„° ë¡œë“œ
        abort 0  // placeholder
    }
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

Smart Vectorì™€ Smart Tableì„ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[Resource Account & Capability â†’](/advanced-concepts/resource-account-capability)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Smart Table API ë¬¸ì„œ](https://docs.movementnetwork.xyz/api/smart-table)
- [ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œ](https://docs.movementnetwork.xyz/performance)

---

*íš¨ìœ¨ì ì¸ ë°ì´í„° êµ¬ì¡°ë¡œ ê³ ì„±ëŠ¥ dAppì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ“Šâš¡*