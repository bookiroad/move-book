# ğŸ”— RPC & Indexer ì—”ë“œí¬ì¸íŠ¸

Movement Networkì™€ ìƒí˜¸ì‘ìš©í•˜ê¸° ìœ„í•œ RPC ì„œë¹„ìŠ¤ì™€ ë°ì´í„° ì¸ë±ì‹± ì„œë¹„ìŠ¤ë¥¼ í™œìš©í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. íš¨ìœ¨ì ì¸ API ì‚¬ìš©ë²•ë¶€í„° ê³ ê¸‰ ìµœì í™”ê¹Œì§€ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- Movement RPCì˜ ëª¨ë“  ì—”ë“œí¬ì¸íŠ¸ë¥¼ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Indexer ì„œë¹„ìŠ¤ë¡œ íš¨ìœ¨ì ì¸ ë°ì´í„° ì¿¼ë¦¬ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Rate limitingê³¼ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ ì ì ˆíˆ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì¨ë“œíŒŒí‹° RPC ì„œë¹„ìŠ¤ë¥¼ ì„ íƒí•˜ê³  í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸŒ RPC ì„œë¹„ìŠ¤ ê°œìš”

### RPC (Remote Procedure Call)ë€?
```
RPC = ì›ê²© í”„ë¡œì‹œì € í˜¸ì¶œ

í´ë¼ì´ì–¸íŠ¸ â†â”€â”€HTTP/HTTPSâ”€â”€â†’ RPC ì„œë²„ â†â”€â”€â†’ Movement Node
    â”‚                                           â”‚
    â””â”€â”€ JSON-RPC ìš”ì²­/ì‘ë‹µ              â””â”€â”€ ë¸”ë¡ì²´ì¸ ìƒíƒœ
```

### Movement RPC ì•„í‚¤í…ì²˜
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Client Apps                â”‚
â”‚   (Wallets, dApps, Analytics)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              RPC Layer                  â”‚
â”‚    (REST API, JSON-RPC, GraphQL)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            Indexer Layer                â”‚
â”‚  (Event Processing, Data Aggregation)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Movement Nodes                â”‚
â”‚      (Validators, Full Nodes)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”— ê³µì‹ RPC ì—”ë“œí¬ì¸íŠ¸

### ë„¤íŠ¸ì›Œí¬ë³„ RPC URL
```typescript
export const MOVEMENT_RPC_ENDPOINTS = {
  mainnet: {
    rest: 'https://mainnet.movementnetwork.xyz/v1',
    websocket: 'wss://mainnet.movementnetwork.xyz/ws',
    graphql: 'https://indexer.mainnet.movementnetwork.xyz/v1/graphql'
  },
  testnet: {
    rest: 'https://testnet.bardock.movementnetwork.xyz/v1',
    websocket: 'wss://testnet.bardock.movementnetwork.xyz/ws', 
    graphql: 'https://indexer.testnet.bardock.movementnetwork.xyz/v1/graphql'
  },
  devnet: {
    rest: 'https://devnet.suzuka.movementnetwork.xyz/v1',
    websocket: 'wss://devnet.suzuka.movementnetwork.xyz/ws',
    graphql: 'https://indexer.devnet.suzuka.movementnetwork.xyz/v1/graphql'
  }
};
```

### ê¸°ë³¸ RPC í˜¸ì¶œ ì˜ˆì‹œ
```typescript
// ê¸°ë³¸ RPC í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
class MovementRPCClient {
  constructor(private rpcUrl: string) {}
  
  async call(method: string, params: any = []) {
    const response = await fetch(this.rpcUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        method,
        params,
        id: Date.now()
      })
    });
    
    const data = await response.json();
    
    if (data.error) {
      throw new Error(`RPC Error: ${data.error.message}`);
    }
    
    return data.result;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const client = new MovementRPCClient(MOVEMENT_RPC_ENDPOINTS.testnet.rest);

// ë„¤íŠ¸ì›Œí¬ ì •ë³´ ì¡°íšŒ
const ledgerInfo = await client.call('get_ledger_info');
console.log('Current block height:', ledgerInfo.block_height);
```

## ğŸ“¡ í•µì‹¬ RPC ë©”ì†Œë“œë“¤

### 1. ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ì¡°íšŒ
```typescript
// í˜„ì¬ ë„¤íŠ¸ì›Œí¬ ì •ë³´
async function getNetworkStatus() {
  const client = new MovementRPCClient(RPC_URL);
  
  // ì›ì¥ ì •ë³´ (ë¸”ë¡ ë†’ì´, ì²´ì¸ ID ë“±)
  const ledgerInfo = await client.call('get_ledger_info');
  
  // ë„¤íŠ¸ì›Œí¬ ì‹ë³„ì  
  const chainId = await client.call('get_chain_id');
  
  // ê°€ìŠ¤ ê°€ê²© ì •ë³´
  const gasEstimate = await client.call('estimate_gas_price');
  
  return {
    blockHeight: ledgerInfo.block_height,
    chainId: chainId.chain_id,
    timestamp: ledgerInfo.timestamp,
    gasPrice: gasEstimate.gas_estimate
  };
}
```

### 2. ê³„ì • ì •ë³´ ì¡°íšŒ
```typescript
// ê³„ì • ìƒíƒœ ë° ë¦¬ì†ŒìŠ¤ ì¡°íšŒ
async function getAccountInfo(address: string) {
  const client = new MovementRPCClient(RPC_URL);
  
  // ê¸°ë³¸ ê³„ì • ì •ë³´
  const account = await client.call('get_account', [address]);
  
  // ê³„ì • ë¦¬ì†ŒìŠ¤ ëª©ë¡
  const resources = await client.call('get_account_resources', [address]);
  
  // ê³„ì • ëª¨ë“ˆ ëª©ë¡
  const modules = await client.call('get_account_modules', [address]);
  
  // ì½”ì¸ ì”ì•¡ (íŠ¹ë³„ ì¡°íšŒ)
  const balance = await client.call('get_account_balance', [address]);
  
  return {
    address: account.address,
    sequenceNumber: account.sequence_number,
    authenticationKey: account.authentication_key,
    resources: resources,
    modules: modules,
    balance: balance
  };
}
```

### 3. íŠ¸ëœì­ì…˜ ì²˜ë¦¬
```typescript
// íŠ¸ëœì­ì…˜ ì œì¶œ ë° ì¶”ì 
async function submitTransaction(signedTxn: any) {
  const client = new MovementRPCClient(RPC_URL);
  
  // íŠ¸ëœì­ì…˜ ì‹œë®¬ë ˆì´ì…˜ (ì„ íƒì‚¬í•­)
  const simulation = await client.call('simulate_transaction', [signedTxn]);
  console.log('Gas estimate:', simulation.gas_used);
  
  // ì‹¤ì œ íŠ¸ëœì­ì…˜ ì œì¶œ
  const result = await client.call('submit_transaction', [signedTxn]);
  console.log('Transaction hash:', result.hash);
  
  // íŠ¸ëœì­ì…˜ ì™„ë£Œ ëŒ€ê¸°
  const confirmedTxn = await waitForTransaction(result.hash);
  return confirmedTxn;
}

async function waitForTransaction(txnHash: string) {
  const client = new MovementRPCClient(RPC_URL);
  let attempts = 0;
  const maxAttempts = 30;
  
  while (attempts < maxAttempts) {
    try {
      const txn = await client.call('get_transaction_by_hash', [txnHash]);
      if (txn.success !== undefined) {
        return txn; // íŠ¸ëœì­ì…˜ ì™„ë£Œ
      }
    } catch (error) {
      // ì•„ì§ ì²˜ë¦¬ë˜ì§€ ì•Šì€ ê²½ìš°
    }
    
    await new Promise(resolve => setTimeout(resolve, 1000));
    attempts++;
  }
  
  throw new Error('Transaction timeout');
}
```

### 4. ì´ë²¤íŠ¸ ì¡°íšŒ
```typescript
// ê³„ì • ì´ë²¤íŠ¸ ì¡°íšŒ
async function getAccountEvents(address: string, eventType?: string) {
  const client = new MovementRPCClient(RPC_URL);
  
  // ëª¨ë“  ì´ë²¤íŠ¸ ì¡°íšŒ
  const events = await client.call('get_account_events', [
    address,
    eventType || 'creation_number', // ì´ë²¤íŠ¸ íƒ€ì…
    0, // ì‹œì‘ ì‹œí€€ìŠ¤ ë²ˆí˜¸
    100 // ìµœëŒ€ ê²°ê³¼ ìˆ˜
  ]);
  
  return events.map(event => ({
    type: event.type,
    sequence: event.sequence_number,
    data: event.data,
    timestamp: event.timestamp
  }));
}

// íŠ¹ì • ëª¨ë“ˆì˜ ì´ë²¤íŠ¸ ì¡°íšŒ
async function getModuleEvents(moduleAddress: string, moduleName: string) {
  const client = new MovementRPCClient(RPC_URL);
  
  const events = await client.call('get_events_by_creation_number', [
    moduleAddress,
    moduleName,
    0, // ì‹œì‘ ë²ˆí˜¸
    100 // ê°œìˆ˜
  ]);
  
  return events;
}
```

## ğŸ“Š GraphQL Indexer í™œìš©

### GraphQLì˜ ì¥ì 
- **ìœ ì—°í•œ ì¿¼ë¦¬**: í•„ìš”í•œ ë°ì´í„°ë§Œ ì •í™•íˆ ìš”ì²­
- **íƒ€ì… ì•ˆì „ì„±**: ìŠ¤í‚¤ë§ˆ ê¸°ë°˜ íƒ€ì… ê²€ì¦
- **íš¨ìœ¨ì **: ì—¬ëŸ¬ ë¦¬ì†ŒìŠ¤ë¥¼ í•œ ë²ˆì˜ ìš”ì²­ìœ¼ë¡œ ì¡°íšŒ
- **ì‹¤ì‹œê°„**: êµ¬ë…(Subscription)ì„ í†µí•œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸

### ê¸°ë³¸ GraphQL ì¿¼ë¦¬
```typescript
// GraphQL í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const graphqlClient = new ApolloClient({
  uri: MOVEMENT_RPC_ENDPOINTS.testnet.graphql,
  cache: new InMemoryCache()
});

// ê³„ì • ì •ë³´ì™€ íŠ¸ëœì­ì…˜ì„ í•œ ë²ˆì— ì¡°íšŒ
const GET_ACCOUNT_WITH_TRANSACTIONS = gql`
  query GetAccountWithTransactions($address: String!, $limit: Int = 10) {
    accounts_by_pk(address: $address) {
      address
      coin_balance
      sequence_number
      
      # ìµœê·¼ íŠ¸ëœì­ì…˜ë“¤
      account_transactions(
        limit: $limit
        order_by: { transaction_version: desc }
      ) {
        transaction_version
        transaction {
          hash
          success
          gas_used
          timestamp
        }
      }
      
      # ë³´ìœ  ì½”ì¸ë“¤
      coin_balances {
        coin_type
        amount
      }
    }
  }
`;

// ì¿¼ë¦¬ ì‹¤í–‰
async function getAccountDetails(address: string) {
  const { data } = await graphqlClient.query({
    query: GET_ACCOUNT_WITH_TRANSACTIONS,
    variables: { address, limit: 20 }
  });
  
  return data.accounts_by_pk;
}
```

### ê³ ê¸‰ GraphQL ì¿¼ë¦¬
```typescript
// í† í° ì „ì†¡ ì´ë²¤íŠ¸ ì¡°íšŒ
const GET_TOKEN_TRANSFERS = gql`
  query GetTokenTransfers($limit: Int = 50, $offset: Int = 0) {
    coin_activities(
      limit: $limit
      offset: $offset
      order_by: { transaction_version: desc }
      where: { 
        activity_type: { _eq: "0x1::coin::WithdrawEvent" }
      }
    ) {
      transaction_version
      amount
      coin_type
      owner_address
      transaction_timestamp
      
      # ê´€ë ¨ íŠ¸ëœì­ì…˜ ì •ë³´
      transaction {
        hash
        sender
        success
        gas_used
      }
    }
  }
`;

// NFT í™œë™ ì¡°íšŒ
const GET_NFT_ACTIVITIES = gql`
  query GetNFTActivities($collectionName: String!) {
    token_activities(
      where: {
        current_token_data: {
          collection_name: { _eq: $collectionName }
        }
      }
      order_by: { transaction_version: desc }
      limit: 100
    ) {
      transaction_version
      creator_address
      collection_name
      token_name
      property_version
      transfer_type
      from_address
      to_address
      token_amount
      transaction_timestamp
    }
  }
`;
```

### GraphQL êµ¬ë… (ì‹¤ì‹œê°„ ë°ì´í„°)
```typescript
// ì‹¤ì‹œê°„ ìƒˆë¡œìš´ íŠ¸ëœì­ì…˜ êµ¬ë…
const SUBSCRIBE_NEW_TRANSACTIONS = gql`
  subscription SubscribeNewTransactions {
    transactions(
      limit: 1
      order_by: { version: desc }
    ) {
      version
      hash
      sender
      success
      gas_used
      timestamp
    }
  }
`;

// Reactì—ì„œ êµ¬ë… ì‚¬ìš©
function RealTimeTransactions() {
  const { data, loading } = useSubscription(SUBSCRIBE_NEW_TRANSACTIONS);
  
  return (
    <div>
      <h3>Latest Transaction</h3>
      {loading ? (
        <p>Loading...</p>
      ) : (
        <div>
          <p>Hash: {data?.transactions[0]?.hash}</p>
          <p>Sender: {data?.transactions[0]?.sender}</p>
          <p>Gas Used: {data?.transactions[0]?.gas_used}</p>
        </div>
      )}
    </div>
  );
}
```

## ğŸ¢ ì¨ë“œíŒŒí‹° RPC ì„œë¹„ìŠ¤

### Alchemy Movement
```typescript
// Alchemy RPC ì„¤ì •
const ALCHEMY_CONFIG = {
  mainnet: 'https://movement-mainnet.g.alchemy.com/v2/YOUR_API_KEY',
  testnet: 'https://movement-testnet.g.alchemy.com/v2/YOUR_API_KEY'
};

class AlchemyClient extends MovementRPCClient {
  constructor(network: 'mainnet' | 'testnet', apiKey: string) {
    const url = ALCHEMY_CONFIG[network].replace('YOUR_API_KEY', apiKey);
    super(url);
  }
  
  // Alchemy íŠ¹í™” ë©”ì†Œë“œë“¤
  async getEnhancedAccountInfo(address: string) {
    // í™•ì¥ëœ ê³„ì • ì •ë³´ ì¡°íšŒ
    return this.call('alchemy_getAccount', [address, { includeNFTs: true }]);
  }
  
  async getBatchAccountBalances(addresses: string[]) {
    // ë°°ì¹˜ ì”ì•¡ ì¡°íšŒ
    return this.call('alchemy_getAccountBalances', [addresses]);
  }
}
```

### QuickNode
```typescript
// QuickNode ì„¤ì •
class QuickNodeClient extends MovementRPCClient {
  constructor(endpointUrl: string) {
    super(endpointUrl);
  }
  
  // QuickNode ê³ ê¸‰ ê¸°ëŠ¥
  async getAccountNFTs(address: string) {
    return this.call('qn_getAccountNFTs', [address]);
  }
  
  async getTokenBalances(address: string) {
    return this.call('qn_getTokenBalances', [address]);
  }
}
```

## âš¡ ì„±ëŠ¥ ìµœì í™”

### 1. ì—°ê²° í’€ë§
```typescript
// HTTP ì—°ê²° ì¬ì‚¬ìš©
import { Agent } from 'https';

class OptimizedRPCClient {
  private agent: Agent;
  
  constructor(private rpcUrl: string) {
    this.agent = new Agent({
      keepAlive: true,
      maxSockets: 10,
      timeout: 30000
    });
  }
  
  async call(method: string, params: any = []) {
    const response = await fetch(this.rpcUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        method,
        params,
        id: Date.now()
      }),
      // @ts-ignore
      agent: this.agent
    });
    
    return response.json();
  }
}
```

### 2. ìºì‹± ì „ëµ
```typescript
// Redis ìºì‹±
import Redis from 'ioredis';

class CachedRPCClient extends MovementRPCClient {
  private redis: Redis;
  
  constructor(rpcUrl: string, redisUrl: string) {
    super(rpcUrl);
    this.redis = new Redis(redisUrl);
  }
  
  async call(method: string, params: any = []) {
    const cacheKey = `rpc:${method}:${JSON.stringify(params)}`;
    
    // ìºì‹œ í™•ì¸
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // RPC í˜¸ì¶œ
    const result = await super.call(method, params);
    
    // ê²°ê³¼ ìºì‹± (TTL: 5ì´ˆ)
    await this.redis.setex(cacheKey, 5, JSON.stringify(result));
    
    return result;
  }
}
```

### 3. ë°°ì¹˜ ìš”ì²­
```typescript
// ì—¬ëŸ¬ RPC í˜¸ì¶œì„ ë°°ì¹˜ë¡œ ì²˜ë¦¬
class BatchRPCClient extends MovementRPCClient {
  async batchCall(requests: Array<{method: string, params: any}>) {
    const batchRequest = requests.map((req, index) => ({
      jsonrpc: '2.0',
      method: req.method,
      params: req.params,
      id: index
    }));
    
    const response = await fetch(this.rpcUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(batchRequest)
    });
    
    const results = await response.json();
    return results.map(result => result.result);
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const batchClient = new BatchRPCClient(RPC_URL);

const [ledgerInfo, account1, account2] = await batchClient.batchCall([
  { method: 'get_ledger_info', params: [] },
  { method: 'get_account', params: ['0x1'] },
  { method: 'get_account', params: ['0x2'] }
]);
```

## ğŸš¨ ì—ëŸ¬ ì²˜ë¦¬ ë° ì¬ì‹œë„

### ê²¬ê³ í•œ ì—ëŸ¬ ì²˜ë¦¬
```typescript
class RobustRPCClient extends MovementRPCClient {
  private retryAttempts = 3;
  private retryDelay = 1000;
  
  async call(method: string, params: any = []) {
    let lastError: Error;
    
    for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {
      try {
        return await super.call(method, params);
      } catch (error) {
        lastError = error as Error;
        
        // ì¬ì‹œë„ ê°€ëŠ¥í•œ ì—ëŸ¬ì¸ì§€ í™•ì¸
        if (this.isRetryableError(error) && attempt < this.retryAttempts) {
          await this.delay(this.retryDelay * attempt);
          continue;
        }
        
        throw error;
      }
    }
    
    throw lastError!;
  }
  
  private isRetryableError(error: any): boolean {
    const retryableCodes = [
      'NETWORK_ERROR',
      'TIMEOUT',
      'CONNECTION_RESET',
      500, // Internal Server Error
      502, // Bad Gateway
      503, // Service Unavailable
      504  // Gateway Timeout
    ];
    
    return retryableCodes.includes(error.code) || 
           retryableCodes.includes(error.status);
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Rate Limiting ì²˜ë¦¬
```typescript
// Rate limit ëŒ€ì‘
class RateLimitedRPCClient extends MovementRPCClient {
  private requestQueue: Array<() => Promise<any>> = [];
  private isProcessing = false;
  private requestsPerSecond = 10;
  
  async call(method: string, params: any = []) {
    return new Promise((resolve, reject) => {
      this.requestQueue.push(async () => {
        try {
          const result = await super.call(method, params);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      this.processQueue();
    });
  }
  
  private async processQueue() {
    if (this.isProcessing || this.requestQueue.length === 0) return;
    
    this.isProcessing = true;
    
    while (this.requestQueue.length > 0) {
      const request = this.requestQueue.shift()!;
      await request();
      
      // Rate limiting
      await new Promise(resolve => 
        setTimeout(resolve, 1000 / this.requestsPerSecond)
      );
    }
    
    this.isProcessing = false;
  }
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

RPCì™€ Indexerë¥¼ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[Faucets & Explorer í™œìš© â†’](/network-infrastructure/faucets-explorer)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement ê³µì‹ ë¬¸ì„œ](https://docs.movementnetwork.xyz/)
- [Movement RPC API ë¬¸ì„œ](https://docs.movementnetwork.xyz/api)
- [GraphQL ê°€ì´ë“œ](https://graphql.org/learn/)

---

*íš¨ìœ¨ì ì¸ RPC í™œìš©ìœ¼ë¡œ ê³ ì„±ëŠ¥ dAppì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ”—âš¡*