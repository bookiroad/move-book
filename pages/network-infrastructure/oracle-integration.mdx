# ğŸ”® Oracle ì—°ë™ (Pyth)

Movement Networkì—ì„œ Pyth Oracleì„ í™œìš©í•˜ì—¬ ì‹¤ì‹œê°„ ì™¸ë¶€ ë°ì´í„°ë¥¼ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì— í†µí•©í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. DeFi í”„ë¡œí† ì½œ êµ¬ì¶•ì— í•„ìˆ˜ì ì¸ Oracle í™œìš©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- Oracleì˜ ê°œë…ê³¼ í•„ìš”ì„±ì„ ì™„ì „íˆ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Pyth Oracleì„ Movement ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì— í†µí•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ê°€ê²© í”¼ë“œ ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Oracle ê¸°ë°˜ DeFi í”„ë¡œí† ì½œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸŒ Oracle ê¸°ì´ˆ ê°œë…

### Oracleì´ë€?
```
Oracle = ë¸”ë¡ì²´ì¸ê³¼ ì™¸ë¶€ ì„¸ê³„ë¥¼ ì—°ê²°í•˜ëŠ” ë‹¤ë¦¬

ì™¸ë¶€ ë°ì´í„° ì†ŒìŠ¤ â†â†’ Oracle Network â†â†’ ë¸”ë¡ì²´ì¸ ìŠ¤ë§ˆíŠ¸ ê³„ì•½
     â”‚                    â”‚                    â”‚
  ì‹¤ì œ ê°€ê²© ì •ë³´        ê²€ì¦ëœ ë°ì´í„°       DeFi í”„ë¡œí† ì½œ
  ë‚ ì”¨ ì •ë³´            ì•”í˜¸í™”ëœ ì „ì†¡        ì˜ˆì¸¡ ì‹œì¥
  ìŠ¤í¬ì¸  ê²°ê³¼          ë¶„ì‚° ê²€ì¦           ë³´í—˜ ê³„ì•½
```

### Oracle Problem (ì˜¤ë¼í´ ë¬¸ì œ)
```yaml
ë¸”ë¡ì²´ì¸ì˜ í•œê³„:
  âŒ ì™¸ë¶€ ë°ì´í„° ì ‘ê·¼ ë¶ˆê°€
  âŒ ì¸í„°ë„· ì—°ê²° ì—†ìŒ
  âŒ API í˜¸ì¶œ ë¶ˆê°€ëŠ¥
  âŒ ì‹¤ì‹œê°„ ì •ë³´ ë¶€ì¡±

Oracleì´ í•´ê²°í•˜ëŠ” ë¬¸ì œ:
  âœ… ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì™¸ë¶€ ë°ì´í„°
  âœ… íƒˆì¤‘ì•™í™”ëœ ê²€ì¦
  âœ… ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
  âœ… ì¡°ì‘ ë°©ì§€ ë©”ì»¤ë‹ˆì¦˜
```

### Pyth Network ê°œìš”
```
Pyth Network íŠ¹ì§•:

ğŸš€ ê³ ì£¼íŒŒ ì—…ë°ì´íŠ¸
â”œâ”€â”€ ë°€ë¦¬ì´ˆ ë‹¨ìœ„ ê°€ê²© ì—…ë°ì´íŠ¸
â”œâ”€â”€ ë†’ì€ ì •í™•ë„
â””â”€â”€ ë‚®ì€ ì§€ì—°ì‹œê°„

ğŸ¦ í”„ë¦¬ë¯¸ì—„ ë°ì´í„° ì†ŒìŠ¤
â”œâ”€â”€ ì „í†µ ê¸ˆìœµ ê¸°ê´€
â”œâ”€â”€ ì•”í˜¸í™”í ê±°ë˜ì†Œ
â”œâ”€â”€ ë§ˆì¼“ ë©”ì´ì»¤
â””â”€â”€ DeFi í”„ë¡œí† ì½œ

ğŸ”’ ê°•ë ¥í•œ ë³´ì•ˆ
â”œâ”€â”€ ë‹¤ì¤‘ ì†ŒìŠ¤ ê²€ì¦
â”œâ”€â”€ ìŠ¤í…Œì´í‚¹ ê¸°ë°˜ ì¸ì„¼í‹°ë¸Œ
â”œâ”€â”€ ìŠ¬ë˜ì‹± ë©”ì»¤ë‹ˆì¦˜
â””â”€â”€ íˆ¬ëª…í•œ ë°ì´í„° í’ˆì§ˆ
```

## ğŸ“Š Pyth ê°€ê²© í”¼ë“œ ì¢…ë¥˜

### ì§€ì›í•˜ëŠ” ìì‚° í´ë˜ìŠ¤
```typescript
export const PYTH_ASSET_CLASSES = {
  crypto: {
    major: ['BTC/USD', 'ETH/USD', 'MOVE/USD', 'SOL/USD'],
    altcoins: ['LINK/USD', 'UNI/USD', 'AAVE/USD', 'COMP/USD'],
    stablecoins: ['USDC/USD', 'USDT/USD', 'DAI/USD', 'FRAX/USD']
  },
  
  equities: {
    indices: ['SPY', 'QQQ', 'VTI', 'IWM'],
    individual: ['AAPL/USD', 'MSFT/USD', 'GOOGL/USD', 'TSLA/USD']
  },
  
  commodities: {
    metals: ['GOLD/USD', 'SILVER/USD', 'COPPER/USD'],
    energy: ['WTI/USD', 'BRENT/USD', 'NATGAS/USD'],
    agriculture: ['CORN/USD', 'WHEAT/USD', 'SOYBEAN/USD']
  },
  
  forex: {
    majors: ['EUR/USD', 'GBP/USD', 'JPY/USD', 'AUD/USD'],
    emerging: ['CNY/USD', 'INR/USD', 'BRL/USD', 'KRW/USD']
  }
};
```

### Movement Networkì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ í”¼ë“œ
```typescript
// Movement ë„¤íŠ¸ì›Œí¬ë³„ Pyth í”¼ë“œ ID
export const MOVEMENT_PYTH_FEEDS = {
  mainnet: {
    'BTC/USD': '0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43',
    'ETH/USD': '0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace',
    'MOVE/USD': '0x123...', // ì‹¤ì œ í”¼ë“œ IDë¡œ êµì²´ í•„ìš”
    'USDC/USD': '0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a'
  },
  
  testnet: {
    'BTC/USD': '0xf9c0172ba10dfa4d19088d94f5bf61d3b54d5bd7483a322a982e1373ee8ea31b',
    'ETH/USD': '0xca80ba6dc32e08d06f1aa886011eed1d77c77be9eb761cc10d72b7d0a2fd57a6',
    'MOVE/USD': '0x456...', // í…ŒìŠ¤íŠ¸ë„· í”¼ë“œ ID
    'USDC/USD': '0x41f3625971ca2ed2263e78573fe5ce23e13d2558ed3f2e47ab0f84fb9e7ae722'
  }
};
```

## ğŸ”§ Movementì—ì„œ Pyth í†µí•©

### 1. Pyth ëª¨ë“ˆ ì„¤ì •
```move
// sources/oracle_integration.move
module my_address::oracle_integration {
    use std::signer;
    use std::vector;
    use aptos_framework::timestamp;
    use pyth::pyth;
    use pyth::price_info::{Self, PriceInfoObject};
    use pyth::price::{Self, Price};
    use pyth::i64;

    // Oracle ê´€ë ¨ ìƒìˆ˜
    const E_STALE_PRICE: u64 = 1;
    const E_INVALID_PRICE: u64 = 2;
    const E_INSUFFICIENT_CONFIDENCE: u64 = 3;
    
    // ìµœëŒ€ í—ˆìš© ê°€ê²© ë‚˜ì´ (ì´ˆ)
    const MAX_PRICE_AGE_SECONDS: u64 = 60;
    
    // ìµœì†Œ ì‹ ë¢°ë„ ì„ê³„ê°’ (basis points)
    const MIN_CONFIDENCE_BPS: u64 = 100; // 1%

    struct OracleManager has key {
        price_feeds: vector<address>,
        last_update: u64,
        admin: address
    }

    // Oracle ì´ˆê¸°í™”
    public fun initialize(admin: &signer) {
        let admin_addr = signer::address_of(admin);
        
        move_to(admin, OracleManager {
            price_feeds: vector::empty(),
            last_update: timestamp::now_seconds(),
            admin: admin_addr
        });
    }

    // ê°€ê²© í”¼ë“œ ì¶”ê°€
    public fun add_price_feed(
        admin: &signer,
        feed_address: address
    ) acquires OracleManager {
        let admin_addr = signer::address_of(admin);
        let manager = borrow_global_mut<OracleManager>(admin_addr);
        
        assert!(manager.admin == admin_addr, E_INVALID_PRICE);
        vector::push_back(&mut manager.price_feeds, feed_address);
    }

    // ê°€ê²© ì¡°íšŒ (ì•ˆì „í•œ ë°©ì‹)
    public fun get_safe_price(
        feed_address: address,
        max_age_seconds: u64
    ): (u64, u64) {
        let price_info_obj = pyth::get_price_info_object(feed_address);
        let price_info = price_info::get_price_info(&price_info_obj);
        let price = price_info::get_price(&price_info);
        
        // ê°€ê²© ìœ íš¨ì„± ê²€ì¦
        validate_price_freshness(&price, max_age_seconds);
        validate_price_confidence(&price);
        
        let price_value = price::get_price(&price);
        let confidence = price::get_conf(&price);
        
        // i64ì—ì„œ u64ë¡œ ë³€í™˜ (ìŒìˆ˜ ê°€ê²©ì€ ì—ëŸ¬)
        let price_u64 = i64::get_magnitude_if_positive(&price_value);
        assert!(i64::get_is_positive(&price_value), E_INVALID_PRICE);
        
        (price_u64, confidence)
    }

    // ê°€ê²© ì‹ ì„ ë„ ê²€ì¦
    fun validate_price_freshness(price: &Price, max_age: u64) {
        let publish_time = price::get_timestamp(price);
        let current_time = timestamp::now_seconds();
        
        assert!(
            current_time - publish_time <= max_age,
            E_STALE_PRICE
        );
    }

    // ê°€ê²© ì‹ ë¢°ë„ ê²€ì¦
    fun validate_price_confidence(price: &Price) {
        let price_value = price::get_price(price);
        let confidence = price::get_conf(price);
        
        let price_abs = i64::get_magnitude_if_positive(&price_value);
        
        // ì‹ ë¢°ë„ê°€ ê°€ê²©ì˜ 1% ì´í•˜ì—¬ì•¼ í•¨
        assert!(
            confidence * 10000 <= price_abs * MIN_CONFIDENCE_BPS,
            E_INSUFFICIENT_CONFIDENCE
        );
    }

    // ì—¬ëŸ¬ í”¼ë“œì˜ ê°€ê²©ì„ ë™ì‹œì— ì¡°íšŒ
    public fun get_multiple_prices(
        feed_addresses: vector<address>
    ): vector<(u64, u64)> {
        let prices = vector::empty();
        let i = 0;
        let len = vector::length(&feed_addresses);
        
        while (i < len) {
            let feed_addr = *vector::borrow(&feed_addresses, i);
            let (price, confidence) = get_safe_price(feed_addr, MAX_PRICE_AGE_SECONDS);
            vector::push_back(&mut prices, (price, confidence));
            i = i + 1;
        };
        
        prices
    }
}
```

### 2. DeFi í”„ë¡œí† ì½œì— Oracle í™œìš©
```move
// sources/defi_protocol.move
module my_address::defi_protocol {
    use std::signer;
    use aptos_framework::coin::{Self, Coin};
    use aptos_framework::aptos_coin::AptosCoin;
    use my_address::oracle_integration;

    // ë‹´ë³´ ë¹„ìœ¨ ìƒìˆ˜ (150% = 15000 basis points)
    const COLLATERAL_RATIO: u64 = 15000;
    const BASIS_POINTS: u64 = 10000;

    struct LendingPool has key {
        total_deposits: u64,
        total_borrows: u64,
        interest_rate: u64, // basis points
        price_feed: address
    }

    struct UserPosition has key {
        collateral: u64,
        debt: u64,
        last_update: u64
    }

    // ë‹´ë³´ ì˜ˆì¹˜
    public fun deposit_collateral(
        user: &signer,
        amount: Coin<AptosCoin>
    ) acquires LendingPool, UserPosition {
        let user_addr = signer::address_of(user);
        let deposit_amount = coin::value(&amount);
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
        if (!exists<UserPosition>(user_addr)) {
            move_to(user, UserPosition {
                collateral: 0,
                debt: 0,
                last_update: timestamp::now_seconds()
            });
        };
        
        let position = borrow_global_mut<UserPosition>(user_addr);
        position.collateral = position.collateral + deposit_amount;
        
        // í’€ì— ìê¸ˆ ì˜ˆì¹˜
        coin::deposit(user_addr, amount);
    }

    // ì•ˆì „í•œ ëŒ€ì¶œ (Oracle ê°€ê²© ê¸°ë°˜)
    public fun borrow_against_collateral(
        user: &signer,
        amount: u64,
        pool_addr: address
    ): Coin<AptosCoin> acquires LendingPool, UserPosition {
        let user_addr = signer::address_of(user);
        let pool = borrow_global<LendingPool>(pool_addr);
        let position = borrow_global_mut<UserPosition>(user_addr);
        
        // Oracleì—ì„œ í˜„ì¬ ê°€ê²© ì¡°íšŒ
        let (collateral_price, _) = oracle_integration::get_safe_price(
            pool.price_feed,
            60 // 60ì´ˆ ì´ë‚´ ê°€ê²©ë§Œ í—ˆìš©
        );
        
        // ë‹´ë³´ ê°€ì¹˜ ê³„ì‚°
        let collateral_value = position.collateral * collateral_price;
        
        // ìƒˆë¡œìš´ ì´ ë¶€ì±„
        let new_total_debt = position.debt + amount;
        
        // ë‹´ë³´ ë¹„ìœ¨ í™•ì¸ (150% ì´ìƒì´ì–´ì•¼ í•¨)
        assert!(
            collateral_value * BASIS_POINTS >= new_total_debt * COLLATERAL_RATIO,
            E_INSUFFICIENT_COLLATERAL
        );
        
        // ë¶€ì±„ ì—…ë°ì´íŠ¸
        position.debt = new_total_debt;
        
        // ëŒ€ì¶œê¸ˆ ì¸ì¶œ
        coin::withdraw<AptosCoin>(user, amount)
    }

    // ì²­ì‚° í•¨ìˆ˜ (ë‹´ë³´ ë¹„ìœ¨ì´ ë¶€ì¡±í•œ í¬ì§€ì…˜)
    public fun liquidate_position(
        liquidator: &signer,
        target_user: address,
        pool_addr: address
    ) acquires LendingPool, UserPosition {
        let pool = borrow_global<LendingPool>(pool_addr);
        let position = borrow_global_mut<UserPosition>(target_user);
        
        // í˜„ì¬ ë‹´ë³´ ê°€ê²© ì¡°íšŒ
        let (collateral_price, _) = oracle_integration::get_safe_price(
            pool.price_feed,
            60
        );
        
        let collateral_value = position.collateral * collateral_price;
        let health_ratio = collateral_value * BASIS_POINTS / position.debt;
        
        // ë‹´ë³´ ë¹„ìœ¨ì´ 130% ë¯¸ë§Œì¸ ê²½ìš° ì²­ì‚° ê°€ëŠ¥
        assert!(health_ratio < 13000, E_POSITION_HEALTHY);
        
        // ì²­ì‚° ë¡œì§ êµ¬í˜„...
        // ë‹´ë³´ ì¼ë¶€ë¥¼ ì²­ì‚°ìì—ê²Œ ì „ì†¡í•˜ê³  ë¶€ì±„ ê°ì†Œ
    }

    // ë‹¤ì¤‘ ìì‚° í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ê³„ì‚°
    public fun calculate_portfolio_value(
        user_addr: address,
        asset_amounts: vector<u64>,
        price_feeds: vector<address>
    ): u64 {
        let prices = oracle_integration::get_multiple_prices(price_feeds);
        let total_value = 0;
        let i = 0;
        
        while (i < vector::length(&asset_amounts)) {
            let amount = *vector::borrow(&asset_amounts, i);
            let (price, _) = *vector::borrow(&prices, i);
            total_value = total_value + (amount * price);
            i = i + 1;
        };
        
        total_value
    }
}
```

## ğŸ“ˆ ê³ ê¸‰ Oracle í™œìš© íŒ¨í„´

### 1. ê°€ê²© í‰í™œí™” (TWAP - Time Weighted Average Price)
```move
module my_address::price_smoothing {
    use std::vector;
    use aptos_framework::timestamp;
    use my_address::oracle_integration;

    struct TWAPOracle has key {
        price_history: vector<PricePoint>,
        window_size: u64, // seconds
        feed_address: address
    }

    struct PricePoint has store {
        price: u64,
        timestamp: u64,
        confidence: u64
    }

    // TWAP Oracle ì´ˆê¸°í™”
    public fun initialize_twap(
        admin: &signer,
        feed_address: address,
        window_size: u64
    ) {
        move_to(admin, TWAPOracle {
            price_history: vector::empty(),
            window_size,
            feed_address
        });
    }

    // ê°€ê²© ì—…ë°ì´íŠ¸
    public fun update_price(oracle_addr: address) acquires TWAPOracle {
        let oracle = borrow_global_mut<TWAPOracle>(oracle_addr);
        let (price, confidence) = oracle_integration::get_safe_price(
            oracle.feed_address,
            30 // 30ì´ˆ ì´ë‚´ ë°ì´í„°
        );
        
        let current_time = timestamp::now_seconds();
        
        // ìƒˆ ê°€ê²© í¬ì¸íŠ¸ ì¶”ê°€
        vector::push_back(&mut oracle.price_history, PricePoint {
            price,
            timestamp: current_time,
            confidence
        });
        
        // ì˜¤ë˜ëœ ë°ì´í„° ì œê±°
        remove_old_prices(&mut oracle.price_history, current_time - oracle.window_size);
    }

    // TWAP ê³„ì‚°
    public fun get_twap(oracle_addr: address): u64 acquires TWAPOracle {
        let oracle = borrow_global<TWAPOracle>(oracle_addr);
        let history = &oracle.price_history;
        
        if (vector::is_empty(history)) {
            return 0
        };
        
        let total_weighted_price = 0;
        let total_weight = 0;
        let i = 0;
        let len = vector::length(history);
        
        while (i < len - 1) {
            let current = vector::borrow(history, i);
            let next = vector::borrow(history, i + 1);
            
            let time_weight = next.timestamp - current.timestamp;
            total_weighted_price = total_weighted_price + (current.price * time_weight);
            total_weight = total_weight + time_weight;
            
            i = i + 1;
        };
        
        if (total_weight == 0) {
            let last_point = vector::borrow(history, len - 1);
            last_point.price
        } else {
            total_weighted_price / total_weight
        }
    }

    fun remove_old_prices(history: &mut vector<PricePoint>, cutoff_time: u64) {
        while (!vector::is_empty(history)) {
            let oldest = vector::borrow(history, 0);
            if (oldest.timestamp < cutoff_time) {
                vector::remove(history, 0);
            } else {
                break
            }
        }
    }
}
```

### 2. ê°€ê²© ì•Œë¦¼ ì‹œìŠ¤í…œ
```move
module my_address::price_alerts {
    use std::signer;
    use std::vector;
    use aptos_framework::event::{Self, EventHandle};
    use aptos_framework::account;
    use my_address::oracle_integration;

    struct PriceAlert has key {
        alerts: vector<Alert>,
        events: EventHandle<PriceAlertEvent>
    }

    struct Alert has store {
        user: address,
        feed_address: address,
        target_price: u64,
        is_above: bool, // true for above, false for below
        is_active: bool
    }

    struct PriceAlertEvent has drop, store {
        user: address,
        feed_address: address,
        target_price: u64,
        actual_price: u64,
        timestamp: u64
    }

    // ì•Œë¦¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    public fun initialize(admin: &signer) {
        move_to(admin, PriceAlert {
            alerts: vector::empty(),
            events: account::new_event_handle<PriceAlertEvent>(admin)
        });
    }

    // ê°€ê²© ì•Œë¦¼ ì„¤ì •
    public fun set_price_alert(
        user: &signer,
        manager_addr: address,
        feed_address: address,
        target_price: u64,
        is_above: bool
    ) acquires PriceAlert {
        let user_addr = signer::address_of(user);
        let manager = borrow_global_mut<PriceAlert>(manager_addr);
        
        vector::push_back(&mut manager.alerts, Alert {
            user: user_addr,
            feed_address,
            target_price,
            is_above,
            is_active: true
        });
    }

    // ì•Œë¦¼ í™•ì¸ ë° ì‹¤í–‰
    public fun check_alerts(manager_addr: address) acquires PriceAlert {
        let manager = borrow_global_mut<PriceAlert>(manager_addr);
        let i = 0;
        
        while (i < vector::length(&manager.alerts)) {
            let alert = vector::borrow_mut(&mut manager.alerts, i);
            
            if (alert.is_active) {
                let (current_price, _) = oracle_integration::get_safe_price(
                    alert.feed_address,
                    60
                );
                
                let should_trigger = if (alert.is_above) {
                    current_price >= alert.target_price
                } else {
                    current_price <= alert.target_price
                };
                
                if (should_trigger) {
                    // ì´ë²¤íŠ¸ ë°œìƒ
                    event::emit_event(&mut manager.events, PriceAlertEvent {
                        user: alert.user,
                        feed_address: alert.feed_address,
                        target_price: alert.target_price,
                        actual_price: current_price,
                        timestamp: timestamp::now_seconds()
                    });
                    
                    // ì•Œë¦¼ ë¹„í™œì„±í™” (ì¼íšŒì„±)
                    alert.is_active = false;
                }
            };
            
            i = i + 1;
        }
    }
}
```

## ğŸ›¡ï¸ Oracle ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 1. ê°€ê²© ì¡°ì‘ ë°©ì§€
```move
module my_address::oracle_security {
    use std::vector;
    use my_address::oracle_integration;

    // ê°€ê²© ê¸‰ë³€ ê°ì§€ ì„ê³„ê°’ (10% = 1000 basis points)
    const MAX_PRICE_CHANGE_BPS: u64 = 1000;
    const BASIS_POINTS: u64 = 10000;

    struct PriceValidator has key {
        last_validated_prices: vector<(address, u64, u64)>, // feed, price, timestamp
        circuit_breaker_active: bool
    }

    // ê°€ê²© ê¸‰ë³€ ê°ì§€
    public fun validate_price_change(
        validator_addr: address,
        feed_address: address,
        new_price: u64
    ): bool acquires PriceValidator {
        let validator = borrow_global_mut<PriceValidator>(validator_addr);
        
        // ì´ì „ ê°€ê²© ì°¾ê¸°
        let previous_price = find_previous_price(&validator.last_validated_prices, feed_address);
        
        if (previous_price == 0) {
            // ì²« ë²ˆì§¸ ê°€ê²©ì¸ ê²½ìš° í—ˆìš©
            return true
        };
        
        // ë³€í™”ìœ¨ ê³„ì‚°
        let price_change = if (new_price > previous_price) {
            ((new_price - previous_price) * BASIS_POINTS) / previous_price
        } else {
            ((previous_price - new_price) * BASIS_POINTS) / previous_price
        };
        
        // ê¸‰ë³€ ê°ì§€
        price_change <= MAX_PRICE_CHANGE_BPS
    }

    // ë‹¤ì¤‘ Oracle ê°€ê²© ë¹„êµ
    public fun compare_multiple_sources(
        feed_addresses: vector<address>,
        deviation_threshold_bps: u64
    ): (u64, bool) {
        let prices = oracle_integration::get_multiple_prices(feed_addresses);
        let sum = 0;
        let count = vector::length(&prices);
        
        // í‰ê·  ê°€ê²© ê³„ì‚°
        let i = 0;
        while (i < count) {
            let (price, _) = *vector::borrow(&prices, i);
            sum = sum + price;
            i = i + 1;
        };
        let average = sum / count;
        
        // í¸ì°¨ í™•ì¸
        let is_valid = true;
        i = 0;
        while (i < count && is_valid) {
            let (price, _) = *vector::borrow(&prices, i);
            let deviation = if (price > average) {
                ((price - average) * BASIS_POINTS) / average
            } else {
                ((average - price) * BASIS_POINTS) / average
            };
            
            if (deviation > deviation_threshold_bps) {
                is_valid = false;
            };
            i = i + 1;
        };
        
        (average, is_valid)
    }

    fun find_previous_price(
        price_history: &vector<(address, u64, u64)>,
        feed_address: address
    ): u64 {
        let i = vector::length(price_history);
        while (i > 0) {
            i = i - 1;
            let (addr, price, _) = *vector::borrow(price_history, i);
            if (addr == feed_address) {
                return price
            }
        };
        0
    }
}
```

### 2. ì—ëŸ¬ ì²˜ë¦¬ ë° í´ë°± ë©”ì»¤ë‹ˆì¦˜
```move
module my_address::oracle_fallback {
    use my_address::oracle_integration;

    struct FallbackOracle has key {
        primary_feeds: vector<address>,
        fallback_feeds: vector<address>,
        manual_price: u64,
        manual_price_timestamp: u64,
        emergency_mode: bool
    }

    // ê³„ì¸µì  ê°€ê²© ì¡°íšŒ
    public fun get_reliable_price(
        fallback_addr: address,
        max_age: u64
    ): (u64, u64) acquires FallbackOracle {
        let fallback = borrow_global<FallbackOracle>(fallback_addr);
        
        // ë¹„ìƒ ëª¨ë“œì¸ ê²½ìš° ìˆ˜ë™ ê°€ê²© ì‚¬ìš©
        if (fallback.emergency_mode) {
            return (fallback.manual_price, 0)
        };
        
        // 1. ê¸°ë³¸ í”¼ë“œ ì‹œë„
        let (price, confidence) = try_price_feeds(&fallback.primary_feeds, max_age);
        if (price > 0) {
            return (price, confidence)
        };
        
        // 2. í´ë°± í”¼ë“œ ì‹œë„
        let (fallback_price, fallback_confidence) = try_price_feeds(&fallback.fallback_feeds, max_age);
        if (fallback_price > 0) {
            return (fallback_price, fallback_confidence)
        };
        
        // 3. ìˆ˜ë™ ê°€ê²© ì‚¬ìš© (ìµœí›„ ìˆ˜ë‹¨)
        assert!(
            timestamp::now_seconds() - fallback.manual_price_timestamp <= max_age * 10,
            E_ALL_FEEDS_FAILED
        );
        
        (fallback.manual_price, 0)
    }

    fun try_price_feeds(
        feeds: &vector<address>,
        max_age: u64
    ): (u64, u64) {
        let i = 0;
        while (i < vector::length(feeds)) {
            let feed_addr = *vector::borrow(feeds, i);
            
            // ê° í”¼ë“œë¥¼ ì•ˆì „í•˜ê²Œ ì‹œë„
            let result = try_safe_price(feed_addr, max_age);
            if (result.is_some) {
                let (price, confidence) = result.value;
                return (price, confidence)
            };
            
            i = i + 1;
        };
        
        (0, 0) // ëª¨ë“  í”¼ë“œ ì‹¤íŒ¨
    }

    // ì•ˆì „í•œ ê°€ê²© ì¡°íšŒ (ì—ëŸ¬ ë¬´ì‹œ)
    fun try_safe_price(feed_address: address, max_age: u64): Option<(u64, u64)> {
        // Try-catch ì‹œë®¬ë ˆì´ì…˜ (Moveì—ì„œëŠ” ì§ì ‘ ì§€ì›í•˜ì§€ ì•ŠìŒ)
        // ì‹¤ì œë¡œëŠ” Oracle ëª¨ë“ˆì—ì„œ ì—ëŸ¬ ëŒ€ì‹  Optionì„ ë°˜í™˜í•˜ë„ë¡ ìˆ˜ì • í•„ìš”
        
        // oracle_integration::try_get_safe_price(feed_address, max_age)
        option::none() // ì„ì‹œ êµ¬í˜„
    }
}
```

## ğŸš€ ì‹¤ì „ Oracle í™œìš© ì‚¬ë¡€

### DeFi Yield Farming í”„ë¡œí† ì½œ
```typescript
// TypeScript SDKë¥¼ í†µí•œ Oracle í™œìš©
import { MovementClient } from '@movementnetwork/sdk';

class YieldFarmingProtocol {
  constructor(private client: MovementClient) {}
  
  async calculateAPY(poolAddress: string): Promise<number> {
    // 1. í’€ì˜ ì´ ê°€ì¹˜ ê³„ì‚° (Oracle ê°€ê²© ì‚¬ìš©)
    const tokens = await this.getPoolTokens(poolAddress);
    let totalValueUSD = 0;
    
    for (const token of tokens) {
      const price = await this.getTokenPriceUSD(token.address);
      totalValueUSD += token.balance * price;
    }
    
    // 2. ë¦¬ì›Œë“œ í† í° ê°€ê²© ì¡°íšŒ
    const rewardTokenPrice = await this.getTokenPriceUSD(REWARD_TOKEN_ADDRESS);
    
    // 3. ì—°ê°„ ë¦¬ì›Œë“œ ê³„ì‚°
    const dailyRewards = await this.getDailyRewards(poolAddress);
    const annualRewardsUSD = dailyRewards * rewardTokenPrice * 365;
    
    // 4. APY ê³„ì‚°
    const apy = (annualRewardsUSD / totalValueUSD) * 100;
    return apy;
  }
  
  private async getTokenPriceUSD(tokenAddress: string): Promise<number> {
    const priceFeeds = {
      [BTC_TOKEN]: 'BTC/USD',
      [ETH_TOKEN]: 'ETH/USD',
      [MOVE_TOKEN]: 'MOVE/USD'
    };
    
    const feedName = priceFeeds[tokenAddress];
    if (!feedName) throw new Error('Price feed not found');
    
    // Move ê³„ì•½ í˜¸ì¶œ
    const result = await this.client.view({
      function: `${ORACLE_MODULE}::get_safe_price`,
      arguments: [PYTH_FEEDS[feedName], 60], // 60ì´ˆ max age
      type_arguments: []
    });
    
    const [price, confidence] = result as [string, string];
    return parseInt(price) / 1e8; // 8 decimal places
  }
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

Oracle í†µí•©ì„ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[Full Node ìš´ì˜ (ê³ ê¸‰) â†’](/network-infrastructure/full-node-operations)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Pyth Network ê³µì‹ ì‚¬ì´íŠ¸](https://pyth.network/)
- [Pyth Move SDK](https://docs.pyth.network/documentation/pythnet-price-feeds/movement)
- [Oracle ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€](https://blog.chain.link/secure-oracle-best-practices/)
- [Movement DeFi ì˜ˆì œ](https://github.com/movementlabsxyz/defi-examples)

---

*ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” Oracle ë°ì´í„°ë¡œ í˜ì‹ ì ì¸ DeFi í”„ë¡œí† ì½œì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ”®ğŸ“ˆ*