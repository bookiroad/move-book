# âš ï¸ ìƒìˆ˜ì™€ ì—ëŸ¬ ì²˜ë¦¬ (Constants & Error Handling)

ì•ˆì •ì ì´ê³  ìœ ì§€ë³´ìˆ˜ ê°€ëŠ¥í•œ Move ì½”ë“œë¥¼ ì‘ì„±í•˜ê¸° ìœ„í•œ ìƒìˆ˜ ì„ ì–¸ê³¼ ì—ëŸ¬ ì²˜ë¦¬ ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.

## ğŸ“ ìƒìˆ˜ (Constants)

ìƒìˆ˜ëŠ” ì»´íŒŒì¼ íƒ€ì„ì— ê²°ì •ë˜ëŠ” ë¶ˆë³€ ê°’ì…ë‹ˆë‹¤. ì½”ë“œì˜ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚µë‹ˆë‹¤.

### ê¸°ë³¸ ìƒìˆ˜ ì„ ì–¸
```move
module movement::constants_example {
    // ì¼ë°˜ ìƒìˆ˜ - ëŒ€ë¬¸ì ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤
    const MAX_SUPPLY: u64 = 1000000;
    const MIN_BALANCE: u64 = 100;
    const PLATFORM_FEE_RATE: u64 = 250; // 2.5% (ê¸°ì¤€ì  10000)
    
    // ë¬¸ìì—´ ìƒìˆ˜
    const TOKEN_NAME: vector<u8> = b"Movement Token";
    const VERSION: vector<u8> = b"1.0.0";
    
    public fun get_max_supply(): u64 {
        MAX_SUPPLY
    }
}
```

### ì—ëŸ¬ ì½”ë“œ ìƒìˆ˜
ì—ëŸ¬ ì½”ë“œëŠ” íŠ¹ë³„í•œ ë„¤ì´ë° ê·œì¹™ì„ ë”°ë¦…ë‹ˆë‹¤:

```move
module movement::error_constants {
    // ì—ëŸ¬ ì½”ë“œ - ì¹´ë©œì¼€ì´ìŠ¤ + E ì ‘ë‘ì–´
    const EInsufficientBalance: u64 = 1;
    const ENotAuthorized: u64 = 2;
    const ETokenNotFound: u64 = 3;
    const EExceedsMaxSupply: u64 = 4;
    const EInvalidAddress: u64 = 5;
    
    // 16ì§„ìˆ˜ë¡œë„ ì •ì˜ ê°€ëŠ¥ (ë” ì²´ê³„ì )
    const E_MINT_BEYOND: u64 = 0x00001;
    const E_INVALID_ADDRESS: u64 = 0x00002;
    const E_NOT_ADMIN: u64 = 0x00003;
}
```

## ğŸš¨ ê¸°ë³¸ ì—ëŸ¬ ì²˜ë¦¬

### abort ë¬¸
ì¦‰ì‹œ ì‹¤í–‰ì„ ì¤‘ë‹¨í•˜ê³  ì—ëŸ¬ ì½”ë“œë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤:

```move
module movement::basic_errors {
    const EInsufficientFunds: u64 = 1;
    const ENotOwner: u64 = 2;
    
    public fun withdraw(balance: u64, amount: u64, is_owner: bool) {
        // ê¶Œí•œ í™•ì¸
        if (!is_owner) {
            abort ENotOwner
        };
        
        // ì”ì•¡ í™•ì¸  
        if (balance < amount) {
            abort EInsufficientFunds
        };
        
        // ì •ìƒ ì²˜ë¦¬ ë¡œì§...
    }
}
```

### assert! ë§¤í¬ë¡œ
ì¡°ê±´ì„ í™•ì¸í•˜ê³  ì‹¤íŒ¨ì‹œ abortí•©ë‹ˆë‹¤:

```move
module movement::assert_examples {
    const EInvalidAmount: u64 = 1;
    const EZeroAddress: u64 = 2;
    
    public fun transfer(from: address, to: address, amount: u64) {
        // assert!(ì¡°ê±´, ì—ëŸ¬_ì½”ë“œ)
        assert!(amount > 0, EInvalidAmount);
        assert!(to != @0x0, EZeroAddress);
        
        // ì „ì†¡ ë¡œì§ ì‹¤í–‰...
    }
    
    // ë³µí•© ì¡°ê±´ ê²€ì‚¬
    public fun mint_token(admin: address, recipient: address, amount: u64) {
        assert!(admin == @movement, ENotOwner);
        assert!(recipient != @0x0, EZeroAddress);  
        assert!(amount > 0 && amount <= 1000000, EInvalidAmount);
        
        // ë¯¼íŒ… ë¡œì§...
    }
}
```

## ğŸ¯ ê³ ê¸‰ ì—ëŸ¬ ì²˜ë¦¬ íŒ¨í„´

### ì—ëŸ¬ ì½”ë“œ ëª¨ë“ˆ ë¶„ë¦¬
```move
// errors.move íŒŒì¼
module movement::errors {
    // ê³µí†µ ì—ëŸ¬ ì½”ë“œë“¤
    const ENotEven: u64 = 2;
    const ENotAuthorized: u64 = 100;
    const EInsufficientBalance: u64 = 101;
    const EInvalidInput: u64 = 102;
    
    // Getter í•¨ìˆ˜ë“¤ (ì¬ì‚¬ìš©ì„ ìœ„í•´)
    public fun not_even(): u64 { ENotEven }
    public fun not_authorized(): u64 { ENotAuthorized }
    public fun insufficient_balance(): u64 { EInsufficientBalance }
    public fun invalid_input(): u64 { EInvalidInput }
}

// ë‹¤ë¥¸ ëª¨ë“ˆì—ì„œ ì‚¬ìš©
module movement::token {
    use movement::errors;
    
    public fun transfer(amount: u64, balance: u64) {
        assert!(amount <= balance, errors::insufficient_balance());
        assert!(amount > 0, errors::invalid_input());
        
        // ì „ì†¡ ë¡œì§...
    }
}
```

### ìƒì„¸í•œ ì—ëŸ¬ ê²€ì¦
```move
module movement::validation {
    const EInvalidTokenId: u64 = 1;
    const ETokenNotOwned: u64 = 2;
    const EInsufficientApproval: u64 = 3;
    
    struct TokenInfo has store {
        owner: address,
        approved: address,
        metadata: vector<u8>,
    }
    
    public fun validate_transfer(
        token_id: u64,
        sender: address,
        token_info: &TokenInfo
    ) {
        // í† í° ì¡´ì¬ ì—¬ë¶€
        assert!(token_id > 0, EInvalidTokenId);
        
        // ì†Œìœ ê¶Œ ë˜ëŠ” ìŠ¹ì¸ í™•ì¸
        let is_owner = sender == token_info.owner;
        let is_approved = sender == token_info.approved;
        
        assert!(is_owner || is_approved, ETokenNotOwned);
    }
}
```

## ğŸ’° ì‹¤ì „ ì˜ˆì œ: DeFi ì—ëŸ¬ ì²˜ë¦¬

```move
module movement::defi_errors {
    use std::signer;
    
    // DeFi ê´€ë ¨ ì—ëŸ¬ ì½”ë“œë“¤
    const EInsufficientLiquidity: u64 = 1;
    const ESlippageExceeded: u64 = 2;
    const EPairNotExists: u64 = 3;
    const EInvalidRatio: u64 = 4;
    const EPoolNotInitialized: u64 = 5;
    
    struct LiquidityPool has store {
        token_a_reserve: u64,
        token_b_reserve: u64,
        total_supply: u64,
    }
    
    // ìŠ¤ì™‘ í•¨ìˆ˜ - í¬ê´„ì ì¸ ì—ëŸ¬ ê²€ì‚¬
    public fun swap_tokens(
        pool: &mut LiquidityPool,
        input_amount: u64,
        min_output: u64,
        user: &signer
    ): u64 {
        // ì…ë ¥ ê²€ì¦
        assert!(input_amount > 0, EInvalidRatio);
        assert!(pool.token_a_reserve > 0 && pool.token_b_reserve > 0, EPoolNotInitialized);
        
        // ì¶œë ¥ëŸ‰ ê³„ì‚°
        let output_amount = calculate_output(
            input_amount,
            pool.token_a_reserve,
            pool.token_b_reserve
        );
        
        // ì¶©ë¶„í•œ ìœ ë™ì„± í™•ì¸
        assert!(output_amount <= pool.token_b_reserve, EInsufficientLiquidity);
        
        // ìŠ¬ë¦¬í˜ì§€ í™•ì¸
        assert!(output_amount >= min_output, ESlippageExceeded);
        
        // í’€ ìƒíƒœ ì—…ë°ì´íŠ¸
        pool.token_a_reserve = pool.token_a_reserve + input_amount;
        pool.token_b_reserve = pool.token_b_reserve - output_amount;
        
        output_amount
    }
    
    fun calculate_output(input: u64, reserve_in: u64, reserve_out: u64): u64 {
        let numerator = input * reserve_out;
        let denominator = reserve_in + input;
        numerator / denominator
    }
}
```

## ğŸ® ì‹¤ì „ ì˜ˆì œ: NFT ì—ëŸ¬ ì²˜ë¦¬

```move
module movement::nft_errors {
    use std::string::String;
    use std::vector;
    
    // NFT ê´€ë ¨ ì—ëŸ¬ ì½”ë“œ
    const ETokenNotExists: u64 = 1;
    const ENotOwner: u64 = 2;
    const ENotApproved: u64 = 3;
    const EInvalidMetadata: u64 = 4;
    const ECollectionFull: u64 = 5;
    const ESelfTransfer: u64 = 6;
    
    struct NFT has store {
        id: u64,
        owner: address,
        metadata: String,
        approved: address,
    }
    
    struct Collection has key {
        nfts: vector<NFT>,
        max_supply: u64,
    }
    
    // NFT ì „ì†¡ - ëª¨ë“  ê²€ì¦ í¬í•¨
    public fun transfer_nft(
        collection: &mut Collection,
        token_id: u64,
        from: address,
        to: address,
        sender: address
    ) {
        // ê¸°ë³¸ ê²€ì¦
        assert!(token_id > 0, ETokenNotExists);
        assert!(from != to, ESelfTransfer);
        assert!(to != @0x0, EInvalidMetadata); // 0 ì£¼ì†Œë¡œ ì „ì†¡ ê¸ˆì§€
        
        // NFT ì°¾ê¸°
        let nft_index = find_nft_index(&collection.nfts, token_id);
        assert!(nft_index < vector::length(&collection.nfts), ETokenNotExists);
        
        let nft_ref = vector::borrow(&collection.nfts, nft_index);
        
        // ê¶Œí•œ í™•ì¸
        let is_owner = sender == nft_ref.owner;
        let is_approved = sender == nft_ref.approved;
        assert!(is_owner || is_approved, ENotApproved);
        
        // ì‹¤ì œ owner í™•ì¸
        assert!(nft_ref.owner == from, ENotOwner);
        
        // ì „ì†¡ ì‹¤í–‰
        let nft_mut = vector::borrow_mut(&mut collection.nfts, nft_index);
        nft_mut.owner = to;
        nft_mut.approved = @0x0; // ìŠ¹ì¸ ì´ˆê¸°í™”
    }
    
    // ë¯¼íŒ… - ê³µê¸‰ëŸ‰ ì œí•œ í™•ì¸
    public fun mint_nft(
        collection: &mut Collection,
        to: address,
        metadata: String
    ): u64 {
        let current_supply = vector::length(&collection.nfts);
        assert!(current_supply < collection.max_supply, ECollectionFull);
        assert!(to != @0x0, EInvalidMetadata);
        
        let token_id = current_supply + 1;
        let nft = NFT {
            id: token_id,
            owner: to,
            metadata,
            approved: @0x0,
        };
        
        vector::push_back(&mut collection.nfts, nft);
        token_id
    }
    
    fun find_nft_index(nfts: &vector<NFT>, token_id: u64): u64 {
        let len = vector::length(nfts);
        let i = 0;
        
        while (i < len) {
            let nft = vector::borrow(nfts, i);
            if (nft.id == token_id) {
                return i
            };
            i = i + 1;
        };
        
        len // Not found
    }
}
```

## ğŸ›¡ï¸ ëª¨ë²” ì‚¬ë¡€

### 1. ì—ëŸ¬ ì½”ë“œ ì²´ê³„í™”
```move
module movement::error_system {
    // ì¹´í…Œê³ ë¦¬ë³„ë¡œ ì—ëŸ¬ ì½”ë“œ ê·¸ë£¹í™”
    
    // ê¶Œí•œ ê´€ë ¨ (100ë²ˆëŒ€)
    const E_NOT_ADMIN: u64 = 100;
    const E_NOT_OWNER: u64 = 101;
    const E_NOT_AUTHORIZED: u64 = 102;
    
    // ì…ë ¥ ê²€ì¦ ê´€ë ¨ (200ë²ˆëŒ€)  
    const E_INVALID_AMOUNT: u64 = 200;
    const E_INVALID_ADDRESS: u64 = 201;
    const E_INVALID_PARAMETER: u64 = 202;
    
    // ìƒíƒœ ê´€ë ¨ (300ë²ˆëŒ€)
    const E_INSUFFICIENT_BALANCE: u64 = 300;
    const E_ALREADY_EXISTS: u64 = 301;
    const E_NOT_FOUND: u64 = 302;
}
```

### 2. ì…ë ¥ ê²€ì¦ í•¨ìˆ˜í™”
```move
module movement::validation_utils {
    const E_INVALID_ADDRESS: u64 = 1;
    const E_INVALID_AMOUNT: u64 = 2;
    
    public fun validate_address(addr: address) {
        assert!(addr != @0x0, E_INVALID_ADDRESS);
    }
    
    public fun validate_amount(amount: u64, min: u64, max: u64) {
        assert!(amount >= min && amount <= max, E_INVALID_AMOUNT);
    }
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

ìƒìˆ˜ì™€ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ ë°°ì› ë‹¤ë©´:
- [ì œë„¤ë¦­ê³¼ íŒ¬í…€ íƒ€ì…](/basic-concepts/generics-phantom) - ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì½”ë“œ
- [ë‹¨ìœ„ í…ŒìŠ¤íŠ¸](/basic-concepts/unit-testing) - ì½”ë“œ í’ˆì§ˆ ë³´ì¥

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement ê³µì‹ ë¬¸ì„œ](https://docs.movementnetwork.xyz/)
- [ì œì–´ êµ¬ì¡°](/basic-concepts/control-structures)

---

*ì ì ˆí•œ ì—ëŸ¬ ì²˜ë¦¬ëŠ” ì‚¬ìš©ì ê²½í—˜ê³¼ ì½”ë“œ ì•ˆì •ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚µë‹ˆë‹¤! ğŸ›¡ï¸*