# ğŸ”§ ì œë„¤ë¦­ê³¼ íŒ¬í…€ íƒ€ì… (Generics & Phantom Types)

ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ê³  íƒ€ì… ì•ˆì „í•œ ì½”ë“œë¥¼ ì‘ì„±í•˜ê¸° ìœ„í•œ Moveì˜ ê³ ê¸‰ íƒ€ì… ì‹œìŠ¤í…œì„ í•™ìŠµí•©ë‹ˆë‹¤. ì œë„¤ë¦­ê³¼ íŒ¬í…€ íƒ€ì…ì€ ì½”ë“œì˜ ìœ ì—°ì„±ê³¼ ì•ˆì „ì„±ì„ ë™ì‹œì— ì œê³µí•©ë‹ˆë‹¤.

## ğŸ¯ ì œë„¤ë¦­ (Generics)

ì œë„¤ë¦­ì„ ì‚¬ìš©í•˜ë©´ ë‹¤ì–‘í•œ íƒ€ì…ì—ì„œ ë™ì‘í•˜ëŠ” í•¨ìˆ˜ì™€ êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì œë„¤ë¦­ í•¨ìˆ˜
```move
module movement::generic_functions {
    // ê¸°ë³¸ ì œë„¤ë¦­ í•¨ìˆ˜
    public fun identity<T: drop>(value: T): T {
        value
    }
    
    // ì œë„¤ë¦­ êµí™˜ í•¨ìˆ˜
    public fun swap<T: drop>(x: T, y: T): (T, T) {
        (y, x)
    }
    
    // ë²¡í„° ì‘ì—… í•¨ìˆ˜
    public fun get_first<T: copy>(items: &vector<T>): T {
        *vector::borrow(items, 0)
    }
    
    // ì‚¬ìš© ì˜ˆì‹œ
    fun example_usage() {
        let num = identity<u64>(42);
        let text = identity<vector<u8>>(b"hello");
        
        let (a, b) = swap<u64>(1, 2); // (2, 1)
        let (x, y) = swap<bool>(true, false); // (false, true)
    }
}
```

### ì œë„¤ë¦­ êµ¬ì¡°ì²´
```move
module movement::generic_structs {
    // ì œë„¤ë¦­ ë˜í¼ êµ¬ì¡°ì²´
    struct Wrapper<T> has copy, drop, store {
        value: T
    }
    
    // ì œë„¤ë¦­ í˜ì–´ êµ¬ì¡°ì²´
    struct Pair<T, U> has copy, drop, store {
        first: T,
        second: U,
    }
    
    // ì œë„¤ë¦­ ì»¨í…Œì´ë„ˆ
    struct Container<T: store> has key, store {
        items: vector<T>,
        count: u64,
    }
    
    // ìƒì„±ì í•¨ìˆ˜ë“¤
    public fun make_wrapper<T: copy + drop>(value: T): Wrapper<T> {
        Wrapper { value }
    }
    
    public fun make_pair<T: copy + drop, U: copy + drop>(
        first: T, 
        second: U
    ): Pair<T, U> {
        Pair { first, second }
    }
    
    // ì‚¬ìš© ì˜ˆì‹œ
    fun examples() {
        let num_wrapper = make_wrapper<u64>(100);
        let text_wrapper = make_wrapper<vector<u8>>(b"Movement");
        
        let mixed_pair = make_pair<u64, bool>(42, true);
        let string_pair = make_pair<vector<u8>, vector<u8>>(b"hello", b"world");
    }
}
```

## ğŸ­ íƒ€ì… ì œì•½ (Type Constraints)

ì œë„¤ë¦­ íƒ€ì…ì— abilitiesë¥¼ ìš”êµ¬í•˜ì—¬ ì•ˆì „ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.

### Abilities ì œì•½
```move
module movement::type_constraints {
    // copy ì œì•½ - ê°’ì„ ë³µì‚¬í•  ìˆ˜ ìˆì–´ì•¼ í•¨
    public fun duplicate<T: copy>(value: &T): T {
        *value
    }
    
    // drop ì œì•½ - ê°’ì„ ì‚­ì œí•  ìˆ˜ ìˆì–´ì•¼ í•¨
    public fun consume<T: drop>(value: T) {
        // valueëŠ” ìë™ìœ¼ë¡œ dropë¨
    }
    
    // store ì œì•½ - ë‹¤ë¥¸ êµ¬ì¡°ì²´ì— ì €ì¥ ê°€ëŠ¥í•´ì•¼ í•¨
    struct StorableContainer<T: store> has store {
        data: T
    }
    
    // ì—¬ëŸ¬ ì œì•½ ì¡°í•©
    public fun safe_operation<T: copy + drop + store>(value: T): T {
        let copied = value; // copy
        copied // ì›ë³¸ì€ drop, ë³µì‚¬ë³¸ ë°˜í™˜
    }
}
```

### ì‹¤ì „ ì œì•½ ì˜ˆì œ
```move
module movement::practical_constraints {
    use std::string::String;
    
    // í† í° íƒ€ì…ì— ëŒ€í•œ ì œë„¤ë¦­ ì§€ê°‘
    struct Wallet<CoinType: store> has key {
        balance: u64,
        metadata: String,
    }
    
    // êµí™˜ ê°€ëŠ¥í•œ ì•„ì´í…œë“¤
    struct Tradeable<T: store + copy> has store {
        item: T,
        price: u64,
        seller: address,
    }
    
    // ì•ˆì „í•œ ì „ì†¡ í•¨ìˆ˜
    public fun safe_transfer<T: key + store>(
        account: &signer,
        resource: T
    ) {
        move_to(account, resource);
    }
}
```

## ğŸ‘» íŒ¬í…€ íƒ€ì… (Phantom Types)

íŒ¬í…€ íƒ€ì…ì€ ëŸ°íƒ€ì„ì—ëŠ” ì¡´ì¬í•˜ì§€ ì•Šì§€ë§Œ ì»´íŒŒì¼ íƒ€ì„ì— íƒ€ì… ì•ˆì „ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.

### ê¸°ë³¸ íŒ¬í…€ íƒ€ì…
```move
module movement::phantom_types {
    // íŒ¬í…€ íƒ€ì… ë§ˆì»¤
    struct USD {}
    struct KRW {}
    struct BTC {}
    
    // íŒ¬í…€ íƒ€ì…ì„ ì‚¬ìš©í•œ ê¸ˆì•¡ êµ¬ì¡°ì²´
    struct Money<phantom Currency> has copy, drop, store {
        amount: u64,
    }
    
    // ê° í†µí™”ë³„ íƒ€ì… ì•ˆì „í•œ í•¨ìˆ˜ë“¤
    public fun create_usd(amount: u64): Money<USD> {
        Money { amount }
    }
    
    public fun create_krw(amount: u64): Money<KRW> {
        Money { amount }
    }
    
    public fun create_btc(amount: u64): Money<BTC> {
        Money { amount }
    }
    
    // ê°™ì€ í†µí™”ë¼ë¦¬ë§Œ ì—°ì‚° ê°€ëŠ¥
    public fun add_money<Currency>(
        a: Money<Currency>, 
        b: Money<Currency>
    ): Money<Currency> {
        Money { amount: a.amount + b.amount }
    }
    
    // í™˜ì „ í•¨ìˆ˜ (ëª…ì‹œì  ë³€í™˜)
    public fun exchange_usd_to_krw(usd: Money<USD>, rate: u64): Money<KRW> {
        Money { amount: usd.amount * rate }
    }
}
```

### ì‹¤ì „ íŒ¬í…€ íƒ€ì…: í† í° ì‹œìŠ¤í…œ
```move
module movement::token_system {
    // í† í° íƒ€ì… ë§ˆì»¤ë“¤
    struct MovementToken {}
    struct StableCoin {}
    struct RewardToken {}
    
    // íŒ¬í…€ íƒ€ì… í† í° êµ¬ì¡°ì²´
    struct Token<phantom TokenType> has store {
        amount: u64,
    }
    
    // ê³„ì •ë³„ ì”ì•¡
    struct Balance<phantom TokenType> has key {
        value: u64,
    }
    
    // í† í°ë³„ ë©”íƒ€ë°ì´í„°
    struct TokenInfo<phantom TokenType> has key {
        name: vector<u8>,
        symbol: vector<u8>,
        decimals: u8,
        total_supply: u64,
    }
    
    // íƒ€ì… ì•ˆì „í•œ ë¯¼íŒ…
    public fun mint<TokenType>(amount: u64): Token<TokenType> {
        Token { amount }
    }
    
    // ê°™ì€ íƒ€ì…ë¼ë¦¬ë§Œ í•©ì‚° ê°€ëŠ¥
    public fun merge<TokenType>(
        token1: Token<TokenType>, 
        token2: Token<TokenType>
    ): Token<TokenType> {
        Token { amount: token1.amount + token2.amount }
    }
    
    // ì „ì†¡ í•¨ìˆ˜ - íƒ€ì… ì•ˆì „ì„± ë³´ì¥
    public fun transfer<TokenType>(
        from: &signer,
        to: address,
        amount: u64,
    ) acquires Balance {
        let from_addr = signer::address_of(from);
        
        // ì”ì•¡ í™•ì¸ ë° ì°¨ê°
        let from_balance = borrow_global_mut<Balance<TokenType>>(from_addr);
        assert!(from_balance.value >= amount, 1);
        from_balance.value = from_balance.value - amount;
        
        // ìˆ˜ì‹ ì ì”ì•¡ ì¦ê°€
        if (!exists<Balance<TokenType>>(to)) {
            move_to(from, Balance<TokenType> { value: 0 });
        };
        
        let to_balance = borrow_global_mut<Balance<TokenType>>(to);
        to_balance.value = to_balance.value + amount;
    }
}
```

## ğŸª ì‹¤ì „ ì˜ˆì œ: DEX (íƒˆì¤‘ì•™í™” ê±°ë˜ì†Œ)

```move
module movement::dex_generics {
    use std::signer;
    
    // í† í° íƒ€ì… ë§ˆì»¤ë“¤
    struct TokenA {}
    struct TokenB {}
    
    // ìœ ë™ì„± í’€ (ë‘ í† í° íƒ€ì…ì„ íŒ¬í…€ìœ¼ë¡œ ì‚¬ìš©)
    struct LiquidityPool<phantom X, phantom Y> has key {
        reserve_x: u64,
        reserve_y: u64,
        total_supply: u64,
    }
    
    // LP í† í°
    struct LPToken<phantom X, phantom Y> has store {
        amount: u64,
    }
    
    // í’€ ì´ˆê¸°í™”
    public fun initialize_pool<X, Y>(
        account: &signer,
        initial_x: u64,
        initial_y: u64,
    ) {
        let pool = LiquidityPool<X, Y> {
            reserve_x: initial_x,
            reserve_y: initial_y,
            total_supply: initial_x * initial_y, // ê°„ë‹¨í•œ ê³µì‹
        };
        
        move_to(account, pool);
    }
    
    // ìœ ë™ì„± ì¶”ê°€ (ì œë„¤ë¦­ + íŒ¬í…€)
    public fun add_liquidity<X, Y>(
        pool_addr: address,
        amount_x: u64,
        amount_y: u64,
    ): LPToken<X, Y> acquires LiquidityPool {
        let pool = borrow_global_mut<LiquidityPool<X, Y>>(pool_addr);
        
        // ë¹„ìœ¨ ê³„ì‚° ë¡œì§ (ê°„ì†Œí™”)
        let lp_amount = (amount_x * amount_y) / 1000;
        
        pool.reserve_x = pool.reserve_x + amount_x;
        pool.reserve_y = pool.reserve_y + amount_y;
        pool.total_supply = pool.total_supply + lp_amount;
        
        LPToken { amount: lp_amount }
    }
    
    // ìŠ¤ì™‘ í•¨ìˆ˜ (X í† í°ì„ Y í† í°ìœ¼ë¡œ)
    public fun swap_x_to_y<X, Y>(
        pool_addr: address,
        input_amount: u64,
    ): u64 acquires LiquidityPool {
        let pool = borrow_global_mut<LiquidityPool<X, Y>>(pool_addr);
        
        // AMM ê³µì‹: x * y = k
        let output_amount = (input_amount * pool.reserve_y) / 
                           (pool.reserve_x + input_amount);
        
        pool.reserve_x = pool.reserve_x + input_amount;
        pool.reserve_y = pool.reserve_y - output_amount;
        
        output_amount
    }
}
```

## ğŸ® ì‹¤ì „ ì˜ˆì œ: ê²Œì„ ì•„ì´í…œ ì‹œìŠ¤í…œ

```move
module movement::game_items {
    // ì•„ì´í…œ íƒ€ì… ë§ˆì»¤ë“¤
    struct Sword {}
    struct Shield {}
    struct Potion {}
    
    // ë“±ê¸‰ ë§ˆì»¤ë“¤
    struct Common {}
    struct Rare {}
    struct Epic {}
    struct Legendary {}
    
    // ì œë„¤ë¦­ ì•„ì´í…œ êµ¬ì¡°ì²´
    struct Item<phantom ItemType, phantom Rarity> has store, drop {
        power: u64,
        durability: u64,
        metadata: vector<u8>,
    }
    
    // ì¸ë²¤í† ë¦¬
    struct Inventory has key {
        swords: vector<Item<Sword, Common>>,
        rare_swords: vector<Item<Sword, Rare>>,
        shields: vector<Item<Shield, Common>>,
        potions: vector<Item<Potion, Common>>,
    }
    
    // íƒ€ì…ë³„ ì•„ì´í…œ ìƒì„±
    public fun create_common_sword(power: u64): Item<Sword, Common> {
        Item {
            power,
            durability: 100,
            metadata: b"Common Iron Sword",
        }
    }
    
    public fun create_legendary_sword(power: u64): Item<Sword, Legendary> {
        Item {
            power,
            durability: 1000,
            metadata: b"Legendary Excalibur",
        }
    }
    
    // ê°•í™” ì‹œìŠ¤í…œ (ê°™ì€ íƒ€ì…ë§Œ ê°•í™” ê°€ëŠ¥)
    public fun upgrade_item<ItemType, CurrentRarity, NextRarity>(
        item: Item<ItemType, CurrentRarity>,
        upgrade_material: Item<ItemType, CurrentRarity>,
    ): Item<ItemType, NextRarity> {
        Item {
            power: item.power + upgrade_material.power / 2,
            durability: item.durability,
            metadata: item.metadata,
        }
    }
}
```

## ğŸ’¡ ëª¨ë²” ì‚¬ë¡€

### 1. ì˜ë¯¸ ìˆëŠ” ì œë„¤ë¦­ ì´ë¦„
```move
// âœ… ì¢‹ì€ ì˜ˆ
struct Pool<TokenA, TokenB> has store {
    reserve_a: u64,
    reserve_b: u64,
}

// âŒ í”¼í•´ì•¼ í•  ì˜ˆ
struct Pool<T, U> has store {
    reserve_1: u64,
    reserve_2: u64,
}
```

### 2. ì ì ˆí•œ ì œì•½ ì‚¬ìš©
```move
// âœ… í•„ìš”í•œ ì œì•½ë§Œ ì¶”ê°€
public fun safe_store<T: store>(value: T) {
    // store abilityë§Œ í•„ìš”
}

// âŒ ë¶ˆí•„ìš”í•œ ì œì•½
public fun safe_store<T: copy + drop + store + key>(value: T) {
    // ê³¼ë„í•œ ì œì•½
}
```

### 3. íŒ¬í…€ íƒ€ì… í™œìš©
```move
// âœ… íƒ€ì… ì•ˆì „ì„±ì„ ìœ„í•œ íŒ¬í…€ íƒ€ì…
struct Currency<phantom CoinType> has store {
    amount: u64
}

// ì»´íŒŒì¼ íƒ€ì„ì— ì˜ëª»ëœ ì—°ì‚° ë°©ì§€
// Currency<USD> + Currency<KRW> = ì»´íŒŒì¼ ì—ëŸ¬!
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

ì œë„¤ë¦­ê³¼ íŒ¬í…€ íƒ€ì…ì„ ì´í•´í–ˆë‹¤ë©´:
- [ë‹¨ìœ„ í…ŒìŠ¤íŠ¸](/basic-concepts/unit-testing) - ì½”ë“œ í’ˆì§ˆ ë³´ì¥
- [ê³ ê¸‰ ê°œë…](/advanced-concepts) - Smart Vector, Smart Table

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement ê³µì‹ ë¬¸ì„œ](https://docs.movementnetwork.xyz/)
- [ìƒìˆ˜ì™€ ì—ëŸ¬ ì²˜ë¦¬](/basic-concepts/constants-errors)

---

*ì œë„¤ë¦­ê³¼ íŒ¬í…€ íƒ€ì…ìœ¼ë¡œ ì•ˆì „í•˜ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì½”ë“œë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”! ğŸ¯*