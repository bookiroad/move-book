# ğŸ”„ ì œì–´ êµ¬ì¡° (Control Structures)

Move ì–¸ì–´ì˜ ì¡°ê±´ë¬¸ê³¼ ë°˜ë³µë¬¸ì„ í•™ìŠµí•©ë‹ˆë‹¤. í”„ë¡œê·¸ë¨ì˜ íë¦„ì„ ì œì–´í•˜ì—¬ ë³µì¡í•œ ë¡œì§ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ğŸ¯ ì¡°ê±´ë¬¸ (Conditionals)

### if / else ë¬¸
ê°€ì¥ ê¸°ë³¸ì ì¸ ì¡°ê±´ë¬¸ì…ë‹ˆë‹¤:

```move
module movement::conditionals_example {
    fun basic_if_else(x: u64): u64 {
        if (x > 10) {
            x * 2
        } else {
            x + 1
        }
    }
    
    // ì¡°ê±´ë¬¸ë„ í‘œí˜„ì‹(expression)ì…ë‹ˆë‹¤
    fun conditional_expression(is_valid: bool): u64 {
        let result = if (is_valid) 100 else 0;
        result
    }
}
```

### else if ë¬¸
ì—¬ëŸ¬ ì¡°ê±´ì„ ìˆœì°¨ì ìœ¼ë¡œ ê²€ì‚¬í•©ë‹ˆë‹¤:

```move
module movement::multiple_conditions {
    fun grade_evaluation(score: u64): vector<u8> {
        if (score >= 90) {
            b"A"
        } else if (score >= 80) {
            b"B"  
        } else if (score >= 70) {
            b"C"
        } else if (score >= 60) {
            b"D"
        } else {
            b"F"
        }
    }
    
    fun token_tier(balance: u64): u8 {
        if (balance >= 1000000) {
            1  // VIP
        } else if (balance >= 100000) {
            2  // Gold
        } else if (balance >= 10000) {
            3  // Silver
        } else {
            4  // Bronze
        }
    }
}
```

## ğŸ” ë°˜ë³µë¬¸ (Loops)

### while ë£¨í”„
ì¡°ê±´ì´ ì°¸ì¸ ë™ì•ˆ ê³„ì† ì‹¤í–‰í•©ë‹ˆë‹¤:

```move
module movement::while_examples {
    use std::vector;
    
    // ê¸°ë³¸ while ë£¨í”„
    fun count_down(mut n: u64): vector<u64> {
        let result = vector::empty<u64>();
        
        while (n > 0) {
            vector::push_back(&mut result, n);
            n = n - 1;
        };
        
        result
    }
    
    // í•©ê³„ ê³„ì‚°
    fun sum_up_to(n: u64): u64 {
        let sum = 0;
        let i = 1;
        
        while (i <= n) {
            sum = sum + i;
            i = i + 1;
        };
        
        sum
    }
}
```

### for ë£¨í”„ (ë²”ìœ„ ê¸°ë°˜)
ì •í•´ì§„ ë²”ìœ„ì—ì„œ ë°˜ë³µí•©ë‹ˆë‹¤:

```move
module movement::for_examples {
    use std::vector;
    
    // ë²”ìœ„ ê¸°ë°˜ for ë£¨í”„
    fun create_sequence(start: u64, end: u64): vector<u64> {
        let result = vector::empty<u64>();
        
        for (i in start..end) {
            vector::push_back(&mut result, i);
        };
        
        result
    }
    
    // ë²¡í„° ìˆœíšŒ
    fun sum_vector(numbers: &vector<u64>): u64 {
        let sum = 0;
        let len = vector::length(numbers);
        
        for (i in 0..len) {
            sum = sum + *vector::borrow(numbers, i);
        };
        
        sum
    }
}
```

### loopì™€ break
ë¬´í•œ ë£¨í”„ì™€ ì¡°ê±´ë¶€ ì¢…ë£Œ:

```move
module movement::loop_examples {
    fun find_factor(n: u64): u64 {
        let i = 2;
        
        loop {
            if (n % i == 0) {
                break i  // ê°’ì„ ë°˜í™˜í•˜ë©° ì¢…ë£Œ
            };
            
            if (i * i > n) {
                break 1  // ì†Œìˆ˜ì¸ ê²½ìš°
            };
            
            i = i + 1;
        }
    }
    
    // continue ì‚¬ìš© (ë‹¤ìŒ ë°˜ë³µìœ¼ë¡œ ê±´ë„ˆë›°ê¸°)
    fun sum_even_numbers(limit: u64): u64 {
        let sum = 0;
        let i = 0;
        
        loop {
            if (i > limit) break;
            
            i = i + 1;
            
            if (i % 2 != 0) continue;  // í™€ìˆ˜ëŠ” ê±´ë„ˆë›°ê¸°
            
            sum = sum + i;
        }
    }
}
```

## ğŸ® ì‹¤ì „ ì˜ˆì œ: ê²Œì„ ë¡œì§

```move
module movement::game_logic {
    use std::vector;
    
    struct Player has store, drop {
        health: u64,
        mana: u64,
        level: u8,
    }
    
    struct Monster has store, drop {
        health: u64,
        attack: u64,
        reward: u64,
    }
    
    // ì „íˆ¬ ì‹œë®¬ë ˆì´ì…˜
    fun battle(player: &mut Player, monster: &mut Monster): bool {
        while (player.health > 0 && monster.health > 0) {
            // í”Œë ˆì´ì–´ ê³µê²©
            if (monster.health <= 10) {
                monster.health = 0;
            } else {
                monster.health = monster.health - 10;
            };
            
            // ëª¬ìŠ¤í„° ìƒì¡´ ì‹œ ë°˜ê²©
            if (monster.health > 0) {
                if (player.health <= monster.attack) {
                    player.health = 0;
                } else {
                    player.health = player.health - monster.attack;
                }
            }
        };
        
        // í”Œë ˆì´ì–´ ìŠ¹ë¦¬ ì—¬ë¶€ ë°˜í™˜
        player.health > 0
    }
    
    // ë ˆë²¨ì—… ì‹œìŠ¤í…œ
    fun level_up_sequence(player: &mut Player, exp_gained: u64): u8 {
        let mut total_exp = exp_gained;
        let mut levels_gained = 0;
        
        while (total_exp >= exp_required_for_level(player.level + 1)) {
            let required = exp_required_for_level(player.level + 1);
            total_exp = total_exp - required;
            player.level = player.level + 1;
            levels_gained = levels_gained + 1;
            
            // ìŠ¤íƒ¯ ì¦ê°€
            player.health = player.health + 20;
            player.mana = player.mana + 10;
        };
        
        levels_gained
    }
    
    fun exp_required_for_level(level: u8): u64 {
        (level as u64) * 100
    }
}
```

## ğŸ’° ì‹¤ì „ ì˜ˆì œ: DeFi ë¡œì§

```move
module movement::defi_logic {
    use std::vector;
    
    struct Pool has store {
        token_a_reserve: u64,
        token_b_reserve: u64,
        total_supply: u64,
    }
    
    struct PriceHistory has store {
        prices: vector<u64>,
        timestamps: vector<u64>,
    }
    
    // ìŠ¤ì™‘ ê³„ì‚° (ìë™í™”ëœ ë§ˆì¼“ ë©”ì´ì»¤)
    fun calculate_swap_output(
        input_amount: u64,
        input_reserve: u64,
        output_reserve: u64
    ): u64 {
        // ìƒìˆ˜ ê³± ê³µì‹: x * y = k
        let numerator = input_amount * output_reserve;
        let denominator = input_reserve + input_amount;
        
        numerator / denominator
    }
    
    // ê°€ê²© í‰ê·  ê³„ì‚°
    fun calculate_twap(
        price_history: &PriceHistory,
        time_window: u64
    ): u64 {
        let len = vector::length(&price_history.prices);
        let mut sum = 0;
        let mut count = 0;
        let current_time = 1000; // ì˜ˆì‹œ íƒ€ì„ìŠ¤íƒ¬í”„
        
        // ìµœê·¼ time_window ë‚´ì˜ ê°€ê²©ë“¤ë§Œ ê³ ë ¤
        for (i in 0..len) {
            let timestamp = *vector::borrow(&price_history.timestamps, i);
            
            if (current_time - timestamp <= time_window) {
                sum = sum + *vector::borrow(&price_history.prices, i);
                count = count + 1;
            }
        };
        
        if (count > 0) {
            sum / count
        } else {
            0
        }
    }
}
```

## âš¡ ìµœì í™” íŒ

### 1. ì¡°ê±´ë¬¸ ìµœì í™”
```move
// âœ… ì¢‹ì€ ì˜ˆ - ê°€ì¥ ê°€ëŠ¥ì„± ë†’ì€ ì¡°ê±´ì„ ë¨¼ì €
fun optimize_conditions(user_type: u8): u64 {
    if (user_type == 1) {        // 90%ì˜ ê²½ìš°
        100
    } else if (user_type == 2) { // 8%ì˜ ê²½ìš°  
        200
    } else {                     // 2%ì˜ ê²½ìš°
        300
    }
}

// âŒ í”¼í•´ì•¼ í•  ì˜ˆ - ë¶ˆí•„ìš”í•œ ì¤‘ì²©
fun avoid_nested_conditions(x: u64): u64 {
    if (x > 0) {
        if (x < 100) {
            if (x % 2 == 0) {
                x * 2
            } else {
                x + 1
            }
        } else {
            x / 2
        }
    } else {
        0
    }
}
```

### 2. ë£¨í”„ ìµœì í™”
```move
// âœ… ì¢‹ì€ ì˜ˆ - ë²¡í„° ê¸¸ì´ë¥¼ ë¯¸ë¦¬ ì €ì¥
fun efficient_loop(data: &vector<u64>): u64 {
    let len = vector::length(data);  // í•œ ë²ˆë§Œ ê³„ì‚°
    let mut sum = 0;
    
    for (i in 0..len) {
        sum = sum + *vector::borrow(data, i);
    };
    
    sum
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

ì œì–´ êµ¬ì¡°ë¥¼ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:
- [ìƒìˆ˜ì™€ ì—ëŸ¬ ì²˜ë¦¬](/basic-concepts/constants-errors) - ì•ˆì •ì ì¸ ì½”ë“œ
- [ì œë„¤ë¦­ê³¼ íŒ¬í…€ íƒ€ì…](/basic-concepts/generics-phantom) - ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì½”ë“œ

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement ê³µì‹ ë¬¸ì„œ](https://docs.movementnetwork.xyz/)
- [ë°ì´í„° íƒ€ì…](/basic-concepts/data-types)

---

*ì ì ˆí•œ ì œì–´ êµ¬ì¡°ë¡œ ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ìš°ì•„í•˜ê²Œ í‘œí˜„í•˜ì„¸ìš”! ğŸ›ï¸*