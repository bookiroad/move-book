# ğŸ§ª ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (Unit Testing)

Move ì½”ë“œì˜ í’ˆì§ˆê³¼ ì•ˆì •ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ëŠ” ì½”ë“œê°€ ì˜ˆìƒëŒ€ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•˜ê³  ë²„ê·¸ë¥¼ ì¡°ê¸°ì— ë°œê²¬í•˜ëŠ” ì¤‘ìš”í•œ ë„êµ¬ì…ë‹ˆë‹¤.

## ğŸ¯ í…ŒìŠ¤íŠ¸ ê¸°ë³¸ ê°œë…

Moveì—ì„œëŠ” `#[test]` ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ì—¬ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

### ê¸°ë³¸ í…ŒìŠ¤íŠ¸ êµ¬ì¡°
```move
module movement::basic_tests {
    // í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ëŠ” #[test] ì–´ë…¸í…Œì´ì…˜ í•„ìš”
    #[test]
    fun test_addition() {
        let result = 2 + 3;
        assert!(result == 5, 1);
    }
    
    #[test]
    fun test_string_operations() {
        use std::string;
        let hello = string::utf8(b"Hello");
        let world = string::utf8(b"World");
        
        // ë¬¸ìì—´ ê¸¸ì´ í…ŒìŠ¤íŠ¸
        assert!(string::length(&hello) == 5, 1);
        assert!(string::length(&world) == 5, 2);
    }
}
```

### í…ŒìŠ¤íŠ¸ ì „ìš© í•¨ìˆ˜
```move
module movement::test_helpers {
    // í…ŒìŠ¤íŠ¸ì—ì„œë§Œ ì‚¬ìš©ë˜ëŠ” í—¬í¼ í•¨ìˆ˜
    #[test_only]
    fun create_test_account(): address {
        @0x1234
    }
    
    #[test_only]
    fun setup_test_data(): (u64, vector<u8>) {
        (100, b"test_data")
    }
    
    #[test]
    fun test_with_helpers() {
        let addr = create_test_account();
        let (amount, data) = setup_test_data();
        
        assert!(addr == @0x1234, 1);
        assert!(amount == 100, 2);
        assert!(data == b"test_data", 3);
    }
}
```

## âš ï¸ ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸

ì˜ˆìƒë˜ëŠ” ì‹¤íŒ¨ ìƒí™©ë„ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ì˜ˆìƒ ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸
```move
module movement::failure_tests {
    const E_DIVISION_BY_ZERO: u64 = 1;
    const E_INSUFFICIENT_BALANCE: u64 = 2;
    
    fun divide(a: u64, b: u64): u64 {
        assert!(b != 0, E_DIVISION_BY_ZERO);
        a / b
    }
    
    fun withdraw(balance: u64, amount: u64): u64 {
        assert!(balance >= amount, E_INSUFFICIENT_BALANCE);
        balance - amount
    }
    
    // ì •ìƒ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸
    #[test]
    fun test_divide_success() {
        let result = divide(10, 2);
        assert!(result == 5, 1);
    }
    
    // ì‹¤íŒ¨ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_divide_by_zero() {
        divide(10, 0); // E_DIVISION_BY_ZEROë¡œ ì‹¤íŒ¨í•´ì•¼ í•¨
    }
    
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_insufficient_balance() {
        withdraw(50, 100); // E_INSUFFICIENT_BALANCEë¡œ ì‹¤íŒ¨í•´ì•¼ í•¨
    }
}
```

### ë‹¤ì–‘í•œ ì‹¤íŒ¨ íŒ¨í„´
```move
module movement::advanced_failure_tests {
    #[test]
    #[expected_failure] // ì–´ë–¤ ì—ëŸ¬ë“  ìƒê´€ì—†ì´ ì‹¤íŒ¨í•˜ë©´ ì„±ê³µ
    fun test_any_failure() {
        abort 999
    }
    
    #[test]
    #[expected_failure(abort_code = 42)]
    fun test_specific_error() {
        abort 42 // ì •í™•íˆ 42 ì—ëŸ¬ì—¬ì•¼ í•¨
    }
    
    #[test]
    #[expected_failure(location = Self)]
    fun test_failure_location() {
        abort 1 // ì´ ëª¨ë“ˆì—ì„œ ë°œìƒí•œ ì—ëŸ¬ì—¬ì•¼ í•¨
    }
}
```

## ğŸ—ï¸ ë¦¬ì†ŒìŠ¤ í…ŒìŠ¤íŠ¸

ë¦¬ì†ŒìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ë³µì¡í•œ ë¡œì§ë„ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### ê³„ì •ê³¼ ë¦¬ì†ŒìŠ¤ í…ŒìŠ¤íŠ¸
```move
module movement::resource_tests {
    use std::signer;
    use std::account;
    
    struct Counter has key {
        value: u64,
    }
    
    public fun init_counter(account: &signer) {
        move_to(account, Counter { value: 0 });
    }
    
    public fun increment(addr: address) acquires Counter {
        let counter = borrow_global_mut<Counter>(addr);
        counter.value = counter.value + 1;
    }
    
    public fun get_count(addr: address): u64 acquires Counter {
        borrow_global<Counter>(addr).value
    }
    
    // í…ŒìŠ¤íŠ¸ í—¬í¼
    #[test_only]
    fun create_test_signer(): signer {
        account::create_account_for_test(@0x123)
    }
    
    #[test]
    fun test_counter_init() {
        let account = create_test_signer();
        init_counter(&account);
        
        let count = get_count(signer::address_of(&account));
        assert!(count == 0, 1);
    }
    
    #[test]
    fun test_counter_increment() acquires Counter {
        let account = create_test_signer();
        let addr = signer::address_of(&account);
        
        init_counter(&account);
        increment(addr);
        increment(addr);
        
        let count = get_count(addr);
        assert!(count == 2, 1);
    }
}
```

## ğŸ’° ì‹¤ì „ ì˜ˆì œ: í† í° ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

```move
module movement::token_tests {
    use std::signer;
    use std::account;
    
    const E_INSUFFICIENT_BALANCE: u64 = 1;
    const E_INVALID_AMOUNT: u64 = 2;
    
    struct TokenStore has key {
        balance: u64,
    }
    
    public fun init_account(account: &signer) {
        move_to(account, TokenStore { balance: 0 });
    }
    
    public fun mint(account: &signer, amount: u64) acquires TokenStore {
        assert!(amount > 0, E_INVALID_AMOUNT);
        
        let addr = signer::address_of(account);
        let store = borrow_global_mut<TokenStore>(addr);
        store.balance = store.balance + amount;
    }
    
    public fun transfer(
        from: &signer,
        to: address,
        amount: u64,
    ) acquires TokenStore {
        assert!(amount > 0, E_INVALID_AMOUNT);
        
        let from_addr = signer::address_of(from);
        let from_store = borrow_global_mut<TokenStore>(from_addr);
        assert!(from_store.balance >= amount, E_INSUFFICIENT_BALANCE);
        
        from_store.balance = from_store.balance - amount;
        
        let to_store = borrow_global_mut<TokenStore>(to);
        to_store.balance = to_store.balance + amount;
    }
    
    public fun balance_of(addr: address): u64 acquires TokenStore {
        borrow_global<TokenStore>(addr).balance
    }
    
    // í…ŒìŠ¤íŠ¸ í—¬í¼ë“¤
    #[test_only]
    fun setup_accounts(): (signer, signer) {
        let alice = account::create_account_for_test(@0xA11CE);
        let bob = account::create_account_for_test(@0xB0B);
        (alice, bob)
    }
    
    #[test_only]
    fun init_with_balance(account: &signer, amount: u64) acquires TokenStore {
        init_account(account);
        if (amount > 0) {
            mint(account, amount);
        }
    }
    
    // ê¸°ë³¸ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
    #[test]
    fun test_mint() acquires TokenStore {
        let alice = account::create_account_for_test(@0xA11CE);
        init_account(&alice);
        
        mint(&alice, 100);
        
        let balance = balance_of(signer::address_of(&alice));
        assert!(balance == 100, 1);
    }
    
    #[test]
    fun test_transfer_success() acquires TokenStore {
        let (alice, bob) = setup_accounts();
        init_with_balance(&alice, 100);
        init_with_balance(&bob, 0);
        
        transfer(&alice, signer::address_of(&bob), 30);
        
        assert!(balance_of(signer::address_of(&alice)) == 70, 1);
        assert!(balance_of(signer::address_of(&bob)) == 30, 2);
    }
    
    // ì—ëŸ¬ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_transfer_insufficient_balance() acquires TokenStore {
        let (alice, bob) = setup_accounts();
        init_with_balance(&alice, 50);
        init_with_balance(&bob, 0);
        
        transfer(&alice, signer::address_of(&bob), 100); // ì”ì•¡ ë¶€ì¡±
    }
    
    #[test]
    #[expected_failure(abort_code = 2)]
    fun test_mint_invalid_amount() acquires TokenStore {
        let alice = account::create_account_for_test(@0xA11CE);
        init_account(&alice);
        
        mint(&alice, 0); // ì˜ëª»ëœ ê¸ˆì•¡
    }
    
    // ì—£ì§€ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸
    #[test]
    fun test_multiple_transfers() acquires TokenStore {
        let (alice, bob) = setup_accounts();
        init_with_balance(&alice, 1000);
        init_with_balance(&bob, 0);
        
        // ì—¬ëŸ¬ ë²ˆ ì „ì†¡
        transfer(&alice, signer::address_of(&bob), 100);
        transfer(&alice, signer::address_of(&bob), 200);
        transfer(&alice, signer::address_of(&bob), 300);
        
        assert!(balance_of(signer::address_of(&alice)) == 400, 1);
        assert!(balance_of(signer::address_of(&bob)) == 600, 2);
    }
}
```

## ğŸ® ì‹¤ì „ ì˜ˆì œ: ê²Œì„ ë¡œì§ í…ŒìŠ¤íŠ¸

```move
module movement::game_tests {
    use std::signer;
    use std::account;
    use std::vector;
    
    struct Player has key {
        level: u8,
        experience: u64,
        health: u64,
        inventory: vector<u64>, // ì•„ì´í…œ IDë“¤
    }
    
    struct GameConfig has key {
        max_level: u8,
        exp_per_level: u64,
    }
    
    public fun init_player(account: &signer) {
        move_to(account, Player {
            level: 1,
            experience: 0,
            health: 100,
            inventory: vector::empty(),
        });
    }
    
    public fun gain_exp(addr: address, amount: u64) acquires Player {
        let player = borrow_global_mut<Player>(addr);
        player.experience = player.experience + amount;
        
        // ë ˆë²¨ì—… ì²´í¬ (100 EXPë‹¹ 1ë ˆë²¨)
        while (player.experience >= 100 && player.level < 10) {
            player.experience = player.experience - 100;
            player.level = player.level + 1;
            player.health = player.health + 20; // ë ˆë²¨ì—…ì‹œ ì²´ë ¥ ì¦ê°€
        }
    }
    
    public fun add_item(addr: address, item_id: u64) acquires Player {
        let player = borrow_global_mut<Player>(addr);
        vector::push_back(&mut player.inventory, item_id);
    }
    
    // View í•¨ìˆ˜ë“¤
    public fun get_level(addr: address): u8 acquires Player {
        borrow_global<Player>(addr).level
    }
    
    public fun get_health(addr: address): u64 acquires Player {
        borrow_global<Player>(addr).health
    }
    
    public fun get_inventory_size(addr: address): u64 acquires Player {
        vector::length(&borrow_global<Player>(addr).inventory)
    }
    
    // í…ŒìŠ¤íŠ¸ë“¤
    #[test_only]
    fun create_test_player(): signer {
        account::create_account_for_test(@0xPLAYER)
    }
    
    #[test]
    fun test_player_initialization() acquires Player {
        let player = create_test_player();
        init_player(&player);
        
        let addr = signer::address_of(&player);
        assert!(get_level(addr) == 1, 1);
        assert!(get_health(addr) == 100, 2);
        assert!(get_inventory_size(addr) == 0, 3);
    }
    
    #[test]
    fun test_experience_gain() acquires Player {
        let player = create_test_player();
        let addr = signer::address_of(&player);
        init_player(&player);
        
        gain_exp(addr, 50);
        assert!(get_level(addr) == 1, 1); // ì•„ì§ ë ˆë²¨ì—… ì•ˆë¨
        
        gain_exp(addr, 60);
        assert!(get_level(addr) == 2, 2); // ë ˆë²¨ì—…!
        assert!(get_health(addr) == 120, 3); // ì²´ë ¥ ì¦ê°€
    }
    
    #[test]
    fun test_multiple_level_ups() acquires Player {
        let player = create_test_player();
        let addr = signer::address_of(&player);
        init_player(&player);
        
        gain_exp(addr, 350); // 3ë ˆë²¨ ìƒë‹¹ì˜ ê²½í—˜ì¹˜
        assert!(get_level(addr) == 4, 1); // 1 -> 4ë ˆë²¨
        assert!(get_health(addr) == 160, 2); // 100 + 60 ì²´ë ¥
    }
    
    #[test]
    fun test_level_cap() acquires Player {
        let player = create_test_player();
        let addr = signer::address_of(&player);
        init_player(&player);
        
        gain_exp(addr, 2000); // ë§¤ìš° ë§ì€ ê²½í—˜ì¹˜
        assert!(get_level(addr) == 10, 1); // ìµœëŒ€ ë ˆë²¨ 10
    }
    
    #[test]
    fun test_inventory_management() acquires Player {
        let player = create_test_player();
        let addr = signer::address_of(&player);
        init_player(&player);
        
        add_item(addr, 101); // ê²€
        add_item(addr, 201); // ë°©íŒ¨
        add_item(addr, 301); // í¬ì…˜
        
        assert!(get_inventory_size(addr) == 3, 1);
    }
}
```

## ğŸ” í…ŒìŠ¤íŠ¸ ì‹¤í–‰

### CLI ëª…ë ¹ì–´
```bash
# ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰
movement move test

# íŠ¹ì • ëª¨ë“ˆì˜ í…ŒìŠ¤íŠ¸ë§Œ ì‹¤í–‰
movement move test --filter basic_tests

# íŠ¹ì • í•¨ìˆ˜ í…ŒìŠ¤íŠ¸ë§Œ ì‹¤í–‰  
movement move test --filter test_addition

# ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸ë„ í¬í•¨í•˜ì—¬ ìì„¸í•œ ì¶œë ¥
movement move test --verbose
```

### í…ŒìŠ¤íŠ¸ ê²°ê³¼ í•´ì„
```bash
# ì„±ê³µ ì˜ˆì‹œ
PASS    movement::basic_tests::test_addition
PASS    movement::basic_tests::test_string_operations
PASS    movement::failure_tests::test_divide_by_zero

# ì‹¤íŒ¨ ì˜ˆì‹œ
FAIL    movement::token_tests::test_transfer
        Error: Assertion failed in test_transfer
        Location: movement::token_tests line 45
```

## ğŸ’¡ í…ŒìŠ¤íŠ¸ ëª¨ë²” ì‚¬ë¡€

### 1. ì˜ë¯¸ ìˆëŠ” í…ŒìŠ¤íŠ¸ ì´ë¦„
```move
// âœ… ì¢‹ì€ ì˜ˆ
#[test]
fun test_transfer_reduces_sender_balance() { /* ... */ }

#[test]
fun test_mint_increases_total_supply() { /* ... */ }

// âŒ í”¼í•´ì•¼ í•  ì˜ˆ
#[test]
fun test1() { /* ... */ }

#[test]
fun test_function() { /* ... */ }
```

### 2. ê° í…ŒìŠ¤íŠ¸ëŠ” í•˜ë‚˜ì˜ ê¸°ëŠ¥ë§Œ ê²€ì¦
```move
// âœ… ì¢‹ì€ ì˜ˆ - í•˜ë‚˜ì˜ ê¸°ëŠ¥ë§Œ í…ŒìŠ¤íŠ¸
#[test]
fun test_mint_increases_balance() {
    // mint ê¸°ëŠ¥ë§Œ í…ŒìŠ¤íŠ¸
}

#[test]
fun test_transfer_updates_both_balances() {
    // transfer ê¸°ëŠ¥ë§Œ í…ŒìŠ¤íŠ¸
}

// âŒ í”¼í•´ì•¼ í•  ì˜ˆ - ì—¬ëŸ¬ ê¸°ëŠ¥ì„ í•œ ë²ˆì—
#[test]
fun test_all_token_operations() {
    // mint, transfer, burn ëª¨ë‘ í…ŒìŠ¤íŠ¸
}
```

### 3. ì ì ˆí•œ ì—ëŸ¬ ë©”ì‹œì§€
```move
#[test]
fun test_balance_calculation() {
    let balance = calculate_balance(100, 30);
    assert!(balance == 70, 1); // ê°„ë‹¨í•œ ì—ëŸ¬ ì½”ë“œ
    
    // ë” ë‚˜ì€ ë°©ë²• - ì˜ë¯¸ ìˆëŠ” ì—ëŸ¬ ì½”ë“œ
    const E_WRONG_BALANCE: u64 = 1001;
    assert!(balance == 70, E_WRONG_BALANCE);
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:
- [ê³ ê¸‰ ê°œë…](/advanced-concepts) - Smart Vector, Smart Table, Resource Account
- [dApp ê°œë°œ](/dapp-development) - ì‹¤ì „ í”„ë¡œì íŠ¸ ê°œë°œ

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement ê³µì‹ ë¬¸ì„œ](https://docs.movementnetwork.xyz/)
- [Movement CLI ì‚¬ìš©ë²•](/developer-tools/movement-cli)

---

*ì² ì €í•œ í…ŒìŠ¤íŠ¸ë¡œ ì•ˆì •ì ì¸ ìŠ¤ë§ˆíŠ¸ ê³„ì•½ì„ ê°œë°œí•˜ì„¸ìš”! ğŸ”¬*