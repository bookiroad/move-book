# ğŸ§ª í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬

Movement ê°œë°œì—ì„œ í¬ê´„ì ì´ê³  íš¨ê³¼ì ì¸ í…ŒìŠ¤íŠ¸ ì „ëµì„ êµ¬ì¶•í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¶€í„° E2E í…ŒìŠ¤íŠ¸ê¹Œì§€ ëª¨ë“  ë ˆë²¨ì˜ í…ŒìŠ¤íŠ¸ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- ì™„ì „í•œ í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ë¥¼ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- TDD(í…ŒìŠ¤íŠ¸ ì£¼ë„ ê°œë°œ) ë°©ì‹ìœ¼ë¡œ Move ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í…ŒìŠ¤íŠ¸ ìë™í™”ì™€ CI/CD íŒŒì´í”„ë¼ì¸ì„ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ë¥¼ ì¸¡ì •í•˜ê³  ê°œì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ“Š í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ

```
        ğŸ”º E2E Tests (Few)
       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      ğŸ”ºğŸ”º Integration Tests (Some)  
     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ğŸ”ºğŸ”ºğŸ”º Unit Tests (Many)
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

| í…ŒìŠ¤íŠ¸ íƒ€ì… | ìˆ˜ëŸ‰ | ì†ë„ | ë¹„ìš© | ì‹ ë¢°ì„± |
|-------------|------|------|------|--------|
| **Unit Tests** | ë§ìŒ | âš¡âš¡âš¡âš¡âš¡ | ğŸ’° | â­â­â­ |
| **Integration Tests** | ì ë‹¹ | âš¡âš¡âš¡ | ğŸ’°ğŸ’° | â­â­â­â­ |
| **E2E Tests** | ì ìŒ | âš¡âš¡ | ğŸ’°ğŸ’°ğŸ’° | â­â­â­â­â­ |

## ğŸ—ï¸ 1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (Unit Tests)

### ê¸°ë³¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ êµ¬ì¡°
```move
module movement::calculator {
    public fun add(a: u64, b: u64): u64 {
        a + b
    }
    
    public fun divide(a: u64, b: u64): u64 {
        assert!(b != 0, 1);
        a / b
    }
    
    public fun power(base: u64, exponent: u64): u64 {
        if (exponent == 0) {
            1
        } else if (exponent == 1) {
            base
        } else {
            base * power(base, exponent - 1)
        }
    }
    
    // === ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ===
    
    #[test]
    fun test_add_simple() {
        assert!(add(2, 3) == 5, 1);
        assert!(add(0, 0) == 0, 2);
        assert!(add(100, 200) == 300, 3);
    }
    
    #[test]
    fun test_add_edge_cases() {
        // ìµœëŒ€ê°’ í…ŒìŠ¤íŠ¸
        let max_u64 = 18446744073709551615;
        assert!(add(max_u64, 0) == max_u64, 1);
        
        // í° ìˆ˜ í…ŒìŠ¤íŠ¸
        assert!(add(1000000, 2000000) == 3000000, 2);
    }
    
    #[test] 
    fun test_divide_normal() {
        assert!(divide(10, 2) == 5, 1);
        assert!(divide(100, 10) == 10, 2);
        assert!(divide(1, 1) == 1, 3);
    }
    
    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_divide_by_zero() {
        divide(10, 0);
    }
    
    #[test]
    fun test_power_cases() {
        assert!(power(2, 0) == 1, 1); // ì§€ìˆ˜ê°€ 0
        assert!(power(2, 1) == 2, 2); // ì§€ìˆ˜ê°€ 1
        assert!(power(2, 3) == 8, 3); // ì¼ë°˜ì ì¸ ê²½ìš°
        assert!(power(10, 2) == 100, 4);
    }
    
    // ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
    #[test]
    fun test_power_performance() {
        // í° ì§€ìˆ˜ì—ì„œë„ í•©ë¦¬ì ì¸ ì‹œê°„ ë‚´ì— ì‹¤í–‰ë˜ëŠ”ì§€ í™•ì¸
        let result = power(2, 10);
        assert!(result == 1024, 1);
    }
}
```

### ê³ ê¸‰ í…ŒìŠ¤íŠ¸ íŒ¨í„´
```move
module movement::advanced_testing {
    use std::vector;
    use std::string::{Self, String};
    use std::signer;
    
    // í…ŒìŠ¤íŠ¸ í—¬í¼ í•¨ìˆ˜ë“¤
    #[test_only]
    fun create_test_string(content: vector<u8>): String {
        string::utf8(content)
    }
    
    #[test_only] 
    fun assert_vector_equal<T: drop>(actual: &vector<T>, expected: &vector<T>) {
        assert!(vector::length(actual) == vector::length(expected), 1);
        let len = vector::length(actual);
        let i = 0;
        while (i < len) {
            // Note: ì‹¤ì œë¡œëŠ” Tê°€ PartialEqë¥¼ êµ¬í˜„í•´ì•¼ í•¨
            i = i + 1;
        }
    }
    
    // ë°ì´í„° ê¸°ë°˜ í…ŒìŠ¤íŠ¸
    #[test]
    fun test_string_operations_data_driven() {
        // í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ë°ì´í„°
        let test_cases = vector[
            (b"hello", 5),
            (b"world", 5), 
            (b"", 0),
            (b"movement", 8),
        ];
        
        let i = 0;
        while (i < vector::length(&test_cases)) {
            let (input, expected_len) = *vector::borrow(&test_cases, i);
            let test_string = create_test_string(input);
            assert!(string::length(&test_string) == expected_len, i);
            i = i + 1;
        }
    }
    
    // Mock ê°ì²´ë¥¼ í™œìš©í•œ í…ŒìŠ¤íŠ¸
    struct MockDatabase has store, drop {
        data: vector<String>,
    }
    
    #[test_only]
    fun create_mock_db(): MockDatabase {
        MockDatabase {
            data: vector[
                create_test_string(b"user1"),
                create_test_string(b"user2"),
            ]
        }
    }
    
    #[test]
    fun test_with_mock_database() {
        let mock_db = create_mock_db();
        assert!(vector::length(&mock_db.data) == 2, 1);
        
        let first_user = vector::borrow(&mock_db.data, 0);
        assert!(*first_user == create_test_string(b"user1"), 2);
    }
}
```

### íŒŒë¼ë¯¸í„°í™”ëœ í…ŒìŠ¤íŠ¸
```move
module movement::parameterized_tests {
    // í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ ì‹œë®¬ë ˆì´ì…˜
    #[test]
    fun test_math_operations_parameterized() {
        // Addition tests
        test_addition_case(0, 0, 0);
        test_addition_case(1, 2, 3);
        test_addition_case(100, 200, 300);
        test_addition_case(999, 1, 1000);
        
        // Multiplication tests  
        test_multiplication_case(0, 5, 0);
        test_multiplication_case(1, 10, 10);
        test_multiplication_case(3, 4, 12);
        test_multiplication_case(7, 8, 56);
    }
    
    fun test_addition_case(a: u64, b: u64, expected: u64) {
        assert!(a + b == expected, 1);
    }
    
    fun test_multiplication_case(a: u64, b: u64, expected: u64) {
        assert!(a * b == expected, 1);
    }
    
    // ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸
    #[test]
    fun test_boundary_values() {
        // u64 ê²½ê³„ê°’ë“¤
        let max_u64 = 18446744073709551615;
        let min_u64 = 0;
        
        assert!(min_u64 + 1 == 1, 1);
        assert!(max_u64 - 1 == 18446744073709551614, 2);
        
        // ì¼ë°˜ì ì¸ ê²½ê³„ê°’ë“¤
        test_boundary_case(0);    // ìµœì†Œê°’
        test_boundary_case(1);    // ìµœì†Œê°’ + 1
        test_boundary_case(255);  // u8 ìµœëŒ€ê°’
        test_boundary_case(256);  // u8 ìµœëŒ€ê°’ + 1
    }
    
    fun test_boundary_case(value: u64) {
        // ê° ê²½ê³„ê°’ì—ì„œì˜ ë™ì‘ í™•ì¸
        assert!(value >= 0, 1);
        if (value <= 255) {
            let as_u8 = (value as u8);
            assert!((as_u8 as u64) == value, 2);
        }
    }
}
```

## ğŸ”— 2. í†µí•© í…ŒìŠ¤íŠ¸ (Integration Tests)

### ëª¨ë“ˆ ê°„ ìƒí˜¸ì‘ìš© í…ŒìŠ¤íŠ¸
```move
// tests/integration_tests.move
#[test_only]
module movement::integration_tests {
    use movement::token;
    use movement::nft;
    use movement::marketplace;
    use std::signer;
    use std::account;
    
    // í†µí•© í…ŒìŠ¤íŠ¸ìš© ê³„ì • ìƒì„±
    #[test_only]
    fun setup_test_accounts(): (signer, signer, signer) {
        let admin = account::create_account_for_test(@0xADMIN);
        let seller = account::create_account_for_test(@0xSELLER);
        let buyer = account::create_account_for_test(@0xBUYER);
        (admin, seller, buyer)
    }
    
    // NFT ë§ˆì¼“í”Œë ˆì´ìŠ¤ ì „ì²´ ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸
    #[test]
    fun test_nft_marketplace_full_workflow() acquires TokenStore, NFTCollection, Marketplace {
        let (admin, seller, buyer) = setup_test_accounts();
        
        // 1. í† í° ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        token::initialize(&admin);
        token::mint(&admin, signer::address_of(&seller), 1000);
        token::mint(&admin, signer::address_of(&buyer), 1000);
        
        // 2. NFT ì»¬ë ‰ì…˜ ìƒì„±
        nft::create_collection(&seller, string::utf8(b"Test Collection"));
        let token_id = nft::mint_nft(
            &seller,
            string::utf8(b"Test NFT"),
            string::utf8(b"Description"), 
            string::utf8(b"https://example.com/image.png")
        );
        
        // 3. ë§ˆì¼“í”Œë ˆì´ìŠ¤ì— NFT ë“±ë¡
        marketplace::initialize(&admin);
        marketplace::list_nft(&seller, token_id, 500);
        
        // 4. NFT êµ¬ë§¤
        marketplace::buy_nft(&buyer, signer::address_of(&seller), token_id);
        
        // 5. ê²°ê³¼ ê²€ì¦
        assert!(nft::get_owner(token_id) == signer::address_of(&buyer), 1);
        assert!(token::get_balance(signer::address_of(&seller)) == 1500, 2); // 1000 + 500
        assert!(token::get_balance(signer::address_of(&buyer)) == 500, 3);   // 1000 - 500
    }
    
    // ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ í†µí•© í…ŒìŠ¤íŠ¸
    #[test]
    #[expected_failure(abort_code = 100)] // ì”ì•¡ ë¶€ì¡± ì—ëŸ¬
    fun test_insufficient_balance_scenario() acquires TokenStore, Marketplace {
        let (admin, seller, buyer) = setup_test_accounts();
        
        token::initialize(&admin);
        token::mint(&admin, signer::address_of(&buyer), 100); // ì ì€ ì”ì•¡
        
        marketplace::initialize(&admin);  
        marketplace::list_nft(&seller, 1, 500); // ë¹„ì‹¼ NFT
        
        // ì”ì•¡ ë¶€ì¡±ìœ¼ë¡œ êµ¬ë§¤ ì‹¤íŒ¨í•´ì•¼ í•¨
        marketplace::buy_nft(&buyer, signer::address_of(&seller), 1);
    }
    
    // ë™ì‹œì„± í…ŒìŠ¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜
    #[test]
    fun test_concurrent_operations() acquires TokenStore {
        let (admin, user1, user2) = setup_test_accounts();
        
        token::initialize(&admin);
        token::mint(&admin, signer::address_of(&user1), 1000);
        token::mint(&admin, signer::address_of(&user2), 1000);
        
        // ë™ì‹œì— ê°™ì€ ê³„ì •ìœ¼ë¡œ ì „ì†¡ (ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë¨)
        token::transfer(&user1, signer::address_of(&user2), 100);
        token::transfer(&user1, signer::address_of(&user2), 200);
        
        // ìµœì¢… ìƒíƒœ í™•ì¸
        assert!(token::get_balance(signer::address_of(&user1)) == 700, 1);
        assert!(token::get_balance(signer::address_of(&user2)) == 1300, 2);
    }
}
```

### ìƒíƒœ ì „í™˜ í…ŒìŠ¤íŠ¸
```move
#[test_only]
module movement::state_machine_tests {
    // ìƒíƒœ ê¸°ë°˜ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ê²Œì„ ì˜ˆì œ
    use movement::game;
    use std::signer;
    
    #[test]
    fun test_game_state_transitions() acquires GameState {
        let player = account::create_account_for_test(@0xPLAYER);
        
        // ì´ˆê¸° ìƒíƒœ: NotStarted
        game::create_game(&player);
        assert!(game::get_state(signer::address_of(&player)) == game::NOT_STARTED, 1);
        
        // ì „í™˜: NotStarted -> Playing
        game::start_game(&player);
        assert!(game::get_state(signer::address_of(&player)) == game::PLAYING, 2);
        
        // ì „í™˜: Playing -> Paused
        game::pause_game(&player);
        assert!(game::get_state(signer::address_of(&player)) == game::PAUSED, 3);
        
        // ì „í™˜: Paused -> Playing
        game::resume_game(&player);
        assert!(game::get_state(signer::address_of(&player)) == game::PLAYING, 4);
        
        // ì „í™˜: Playing -> Finished
        game::finish_game(&player);
        assert!(game::get_state(signer::address_of(&player)) == game::FINISHED, 5);
    }
    
    // ë¶ˆë²•ì ì¸ ìƒíƒœ ì „í™˜ í…ŒìŠ¤íŠ¸
    #[test]
    #[expected_failure(abort_code = 200)] // ì˜ëª»ëœ ìƒíƒœ ì „í™˜
    fun test_invalid_state_transition() acquires GameState {
        let player = account::create_account_for_test(@0xPLAYER);
        
        game::create_game(&player);
        // NotStarted ìƒíƒœì—ì„œ ë°”ë¡œ pause ì‹œë„ (ë¶ˆê°€ëŠ¥í•´ì•¼ í•¨)
        game::pause_game(&player);
    }
}
```

## ğŸŒ 3. ì—”ë“œíˆ¬ì—”ë“œ í…ŒìŠ¤íŠ¸ (E2E Tests)

### TypeScript E2E í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬
```typescript
// tests/e2e/movementE2E.test.ts
import { MovementClient, AptosAccount } from '@movementlabs/movement-sdk';
import { expect } from '@jest/globals';

describe('Movement E2E Tests', () => {
    let client: MovementClient;
    let admin: AptosAccount;
    let user1: AptosAccount;
    let user2: AptosAccount;
    
    beforeAll(async () => {
        // Movement í…ŒìŠ¤íŠ¸ë„· í´ë¼ì´ì–¸íŠ¸ ì„¤ì •
        client = new MovementClient({
            nodeUrl: 'https://testnet.bardock.movementnetwork.xyz/v1',
            faucetUrl: 'https://faucet.movementnetwork.xyz/'
        });
        
        // í…ŒìŠ¤íŠ¸ ê³„ì •ë“¤ ìƒì„±
        admin = new AptosAccount();
        user1 = new AptosAccount();
        user2 = new AptosAccount();
        
        // Faucetì—ì„œ í† í° ë°›ê¸°
        await client.fundAccount(admin.address(), 100000000);
        await client.fundAccount(user1.address(), 100000000);
        await client.fundAccount(user2.address(), 100000000);
        
        // ë°°í¬ëœ ê³„ì•½ ëŒ€ê¸°
        await waitForDeployment();
    });
    
    describe('Token Operations', () => {
        it('should initialize token system', async () => {
            const payload = {
                type: "entry_function_payload",
                function: `${CONTRACT_ADDRESS}::token::initialize`,
                type_arguments: [],
                arguments: []
            };
            
            const txn = await client.generateTransaction(admin.address(), payload);
            const signedTxn = await client.signTransaction(admin, txn);
            const result = await client.submitTransaction(signedTxn);
            
            await client.waitForTransaction(result.hash);
            expect(result.success).toBe(true);
        });
        
        it('should mint tokens', async () => {
            const payload = {
                type: "entry_function_payload", 
                function: `${CONTRACT_ADDRESS}::token::mint`,
                type_arguments: [],
                arguments: [user1.address().hex(), "1000"]
            };
            
            const txn = await client.generateTransaction(admin.address(), payload);
            const signedTxn = await client.signTransaction(admin, txn);
            const result = await client.submitTransaction(signedTxn);
            
            await client.waitForTransaction(result.hash);
            
            // ì”ì•¡ í™•ì¸
            const balance = await getTokenBalance(user1.address().hex());
            expect(balance).toBe(1000);
        });
        
        it('should transfer tokens', async () => {
            // user1 -> user2ë¡œ 500 í† í° ì „ì†¡
            const payload = {
                type: "entry_function_payload",
                function: `${CONTRACT_ADDRESS}::token::transfer`,
                type_arguments: [],
                arguments: [user2.address().hex(), "500"]
            };
            
            const txn = await client.generateTransaction(user1.address(), payload);
            const signedTxn = await client.signTransaction(user1, txn);
            const result = await client.submitTransaction(signedTxn);
            
            await client.waitForTransaction(result.hash);
            
            // ì”ì•¡ í™•ì¸
            const user1Balance = await getTokenBalance(user1.address().hex());
            const user2Balance = await getTokenBalance(user2.address().hex());
            
            expect(user1Balance).toBe(500);
            expect(user2Balance).toBe(500);
        });
    });
    
    describe('NFT Marketplace', () => {
        let nftId: number;
        
        it('should create NFT collection', async () => {
            const payload = {
                type: "entry_function_payload",
                function: `${CONTRACT_ADDRESS}::nft::create_collection`,
                type_arguments: [],
                arguments: ["Test Collection", "1000"]
            };
            
            const txn = await client.generateTransaction(user1.address(), payload);
            const signedTxn = await client.signTransaction(user1, txn);
            const result = await client.submitTransaction(signedTxn);
            
            await client.waitForTransaction(result.hash);
            expect(result.success).toBe(true);
        });
        
        it('should mint NFT', async () => {
            const payload = {
                type: "entry_function_payload",
                function: `${CONTRACT_ADDRESS}::nft::mint_nft`,
                type_arguments: [],
                arguments: [
                    "Test NFT",
                    "Test Description", 
                    "https://example.com/image.png"
                ]
            };
            
            const txn = await client.generateTransaction(user1.address(), payload);
            const signedTxn = await client.signTransaction(user1, txn);
            const result = await client.submitTransaction(signedTxn);
            
            await client.waitForTransaction(result.hash);
            
            // ì´ë²¤íŠ¸ì—ì„œ NFT ID ì¶”ì¶œ
            nftId = extractNFTIdFromEvents(result);
            expect(nftId).toBeGreaterThan(0);
        });
        
        it('should complete marketplace transaction', async () => {
            // 1. NFTë¥¼ ë§ˆì¼“í”Œë ˆì´ìŠ¤ì— ë“±ë¡
            await listNFTOnMarketplace(user1, nftId, 300);
            
            // 2. user2ê°€ NFT êµ¬ë§¤
            await buyNFTFromMarketplace(user2, user1.address().hex(), nftId);
            
            // 3. ê²°ê³¼ ê²€ì¦
            const owner = await getNFTOwner(nftId);
            expect(owner).toBe(user2.address().hex());
            
            const user1Balance = await getTokenBalance(user1.address().hex());
            const user2Balance = await getTokenBalance(user2.address().hex());
            
            expect(user1Balance).toBe(800); // 500 + 300
            expect(user2Balance).toBe(200); // 500 - 300
        });
    });
    
    // ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸
    describe('Stress Tests', () => {
        it('should handle multiple concurrent transactions', async () => {
            const promises = [];
            
            // 100ê°œì˜ ë™ì‹œ íŠ¸ëœì­ì…˜ ìƒì„±
            for (let i = 0; i < 100; i++) {
                const promise = transferTokens(
                    i % 2 === 0 ? user1 : user2,
                    i % 2 === 0 ? user2.address().hex() : user1.address().hex(),
                    1
                );
                promises.push(promise);
            }
            
            // ëª¨ë“  íŠ¸ëœì­ì…˜ ì™„ë£Œ ëŒ€ê¸°
            const results = await Promise.allSettled(promises);
            
            // ì„±ê³µë¥  í™•ì¸ (ìµœì†Œ 95% ì„±ê³µ)
            const successCount = results.filter(r => r.status === 'fulfilled').length;
            const successRate = successCount / results.length;
            
            expect(successRate).toBeGreaterThanOrEqual(0.95);
        });
    });
});

// í—¬í¼ í•¨ìˆ˜ë“¤
async function waitForDeployment(): Promise<void> {
    // ê³„ì•½ ë°°í¬ ì™„ë£Œê¹Œì§€ ëŒ€ê¸°
    await new Promise(resolve => setTimeout(resolve, 5000));
}

async function getTokenBalance(address: string): Promise<number> {
    try {
        const resource = await client.getAccountResource(
            address,
            `${CONTRACT_ADDRESS}::token::TokenStore`
        );
        return parseInt((resource.data as any).balance);
    } catch {
        return 0;
    }
}

function extractNFTIdFromEvents(result: any): number {
    // ì´ë²¤íŠ¸ì—ì„œ NFT ID ì¶”ì¶œ ë¡œì§
    const events = result.events || [];
    for (const event of events) {
        if (event.type.includes('NFTMinted')) {
            return parseInt(event.data.token_id);
        }
    }
    return 0;
}

async function listNFTOnMarketplace(seller: AptosAccount, nftId: number, price: number): Promise<void> {
    const payload = {
        type: "entry_function_payload",
        function: `${CONTRACT_ADDRESS}::marketplace::list_nft`,
        type_arguments: [],
        arguments: [nftId.toString(), price.toString()]
    };
    
    const txn = await client.generateTransaction(seller.address(), payload);
    const signedTxn = await client.signTransaction(seller, txn);
    const result = await client.submitTransaction(signedTxn);
    
    await client.waitForTransaction(result.hash);
}
```

## ğŸ“ˆ 4. í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ì™€ í’ˆì§ˆ

### ì»¤ë²„ë¦¬ì§€ ì¸¡ì •
```bash
#!/bin/bash
# scripts/test-coverage.sh

echo "=== Move í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ì¸¡ì • ==="

# ì»¤ë²„ë¦¬ì§€ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
movement move test --coverage --output-format html --output-dir coverage-report

# ì»¤ë²„ë¦¬ì§€ í†µê³„ í‘œì‹œ
echo "ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„± ì™„ë£Œ:"
echo "ğŸ“Š HTML ë¦¬í¬íŠ¸: coverage-report/index.html"

# ì»¤ë²„ë¦¬ì§€ ì„ê³„ê°’ í™•ì¸
COVERAGE=$(movement move test --coverage --summary | grep -oP '\d+(?=% coverage)')

if [ "$COVERAGE" -ge 90 ]; then
    echo "âœ… ì»¤ë²„ë¦¬ì§€ $COVERAGE% - ëª©í‘œ ë‹¬ì„±!"
elif [ "$COVERAGE" -ge 80 ]; then
    echo "âš ï¸ ì»¤ë²„ë¦¬ì§€ $COVERAGE% - ê°œì„  ê¶Œì¥"
else
    echo "âŒ ì»¤ë²„ë¦¬ì§€ $COVERAGE% - ê°œì„  í•„ìš”"
    exit 1
fi
```

### í…ŒìŠ¤íŠ¸ í’ˆì§ˆ ë©”íŠ¸ë¦­
```move
#[test_only]
module movement::test_quality_metrics {
    // í…ŒìŠ¤íŠ¸ ë³µì¡ë„ ì¸¡ì •
    #[test]
    fun test_cyclomatic_complexity() {
        // ë³µì¡í•œ ì¡°ê±´ë¬¸ì´ ìˆëŠ” í•¨ìˆ˜ í…ŒìŠ¤íŠ¸
        let result = complex_function(10, true, 5);
        assert!(result == 15, 1);
        
        let result2 = complex_function(10, false, 5);  
        assert!(result2 == 50, 2);
    }
    
    fun complex_function(a: u64, condition: bool, b: u64): u64 {
        if (condition) {
            if (a > 5) {
                a + b
            } else {
                a - b  
            }
        } else {
            if (b > 3) {
                a * b
            } else {
                a / b
            }
        }
    }
    
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° í’ˆì§ˆ
    #[test]
    fun test_data_quality() {
        // ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸
        test_boundary_values();
        
        // ëŒ€í‘œê°’ í…ŒìŠ¤íŠ¸
        test_representative_values();
        
        // ì—ëŸ¬ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸
        test_error_cases();
    }
    
    fun test_boundary_values() {
        // 0, 1, ìµœëŒ€ê°’ ë“±
        assert!(math_function(0) == 0, 1);
        assert!(math_function(1) == 1, 2);
    }
    
    fun test_representative_values() {
        // ì¼ë°˜ì ì¸ ì‚¬ìš© ì¼€ì´ìŠ¤
        assert!(math_function(10) == 100, 1);
        assert!(math_function(25) == 625, 2);
    }
    
    fun test_error_cases() {
        // ì—ëŸ¬ê°€ ì˜ˆìƒë˜ëŠ” ì¼€ì´ìŠ¤ë“¤
        // (ì‹¤ì œë¡œëŠ” expected_failure í…ŒìŠ¤íŠ¸ë“¤)
    }
    
    fun math_function(x: u64): u64 {
        x * x
    }
}
```

## ğŸ”„ 5. CI/CD í…ŒìŠ¤íŠ¸ ìë™í™”

### GitHub Actions ì›Œí¬í”Œë¡œìš°
```yaml
# .github/workflows/test.yml
name: Movement Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Movement CLI
      run: |
        curl -LO https://github.com/movementlabs/aptos-core/releases/latest/movement-cli.tar.gz
        tar -xzf movement-cli.tar.gz
        sudo mv movement /usr/local/bin/
        
    - name: Run Unit Tests
      run: |
        movement move test --coverage
        
    - name: Generate Coverage Report
      run: |
        movement move test --coverage --output-format html --output-dir coverage
        
    - name: Upload Coverage
      uses: codecov/codecov-action@v3
      with:
        directory: ./coverage
        
  integration