# ğŸ’³ Wallet ì—°ë™ ë„êµ¬ (Razor, Nightly & More)

Movement Networkê³¼ í˜¸í™˜ë˜ëŠ” ë‹¤ì–‘í•œ ì§€ê°‘ë“¤ì˜ ì—°ë™ ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. ì‚¬ìš©ì ê²½í—˜ì„ ê·¹ëŒ€í™”í•˜ëŠ” ì§€ê°‘ í†µí•© ì „ëµì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- ì£¼ìš” Movement ì§€ê°‘ë“¤ê³¼ ì—°ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë©€í‹° ì§€ê°‘ ì§€ì› dAppì„ ê°œë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì§€ê°‘ë³„ íŠ¹ì§•ê³¼ ìµœì í™” ë°©ë²•ì„ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì•ˆì „í•œ ì§€ê°‘ ì—°ë™ íŒ¨í„´ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ“Š ì§€ì› ì§€ê°‘ ë¹„êµ

| ì§€ê°‘ | íƒ€ì… | í”Œë«í¼ | Movement ì§€ì› | íŠ¹ì§• |
|------|------|--------|---------------|------|
| **Razor Wallet** | ë¸Œë¼ìš°ì € í™•ì¥ | Web | âœ… ë„¤ì´í‹°ë¸Œ | ê³ ì„±ëŠ¥, DEX íŠ¹í™” |
| **Nightly** | ë¸Œë¼ìš°ì € í™•ì¥ | Web | âœ… ë„¤ì´í‹°ë¸Œ | ë©€í‹°ì²´ì¸, NFT ì§€ì› |
| **Movement Wallet** | ëª¨ë°”ì¼ | iOS/Android | âœ… ê³µì‹ | Movement ì „ìš© |
| **Pontem** | ë¸Œë¼ìš°ì € í™•ì¥ | Web | âœ… í˜¸í™˜ | Move ì–¸ì–´ íŠ¹í™” |
| **WalletConnect** | í”„ë¡œí† ì½œ | Universal | âœ… ì§€ì› | í¬ë¡œìŠ¤ í”Œë«í¼ |

## ğŸ”§ 1. Razor Wallet ì—°ë™

### ê¸°ë³¸ ì„¤ì¹˜ ë° ê°ì§€
```typescript
// utils/razorWallet.ts
interface RazorWallet {
    connect(): Promise<string[]>;
    disconnect(): Promise<void>;
    signAndSubmitTransaction(transaction: any): Promise<any>;
    signMessage(message: string): Promise<string>;
    account(): string | null;
    network(): string;
}

declare global {
    interface Window {
        razor?: RazorWallet;
    }
}

export class RazorWalletAdapter {
    private wallet: RazorWallet | null = null;
    
    constructor() {
        this.checkWalletAvailability();
    }
    
    private checkWalletAvailability(): void {
        if (typeof window !== 'undefined' && window.razor) {
            this.wallet = window.razor;
            console.log('Razor Wallet ê°ì§€ë¨');
        } else {
            console.log('Razor Walletì´ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤');
        }
    }
    
    async connect(): Promise<string | null> {
        if (!this.wallet) {
            throw new Error('Razor Walletì´ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤');
        }
        
        try {
            const accounts = await this.wallet.connect();
            return accounts[0] || null;
        } catch (error) {
            console.error('Razor Wallet ì—°ê²° ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    async disconnect(): Promise<void> {
        if (this.wallet) {
            await this.wallet.disconnect();
        }
    }
    
    async signAndSubmitTransaction(transaction: any): Promise<string> {
        if (!this.wallet) {
            throw new Error('ì§€ê°‘ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
        }
        
        try {
            const result = await this.wallet.signAndSubmitTransaction(transaction);
            return result.hash;
        } catch (error) {
            console.error('íŠ¸ëœì­ì…˜ ì‹¤í–‰ ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    getCurrentAccount(): string | null {
        return this.wallet?.account() || null;
    }
    
    getCurrentNetwork(): string {
        return this.wallet?.network() || 'unknown';
    }
}
```

### React Hook êµ¬í˜„
```typescript
// hooks/useRazorWallet.ts
import { useState, useEffect, useCallback } from 'react';
import { RazorWalletAdapter } from '../utils/razorWallet';

export const useRazorWallet = () => {
    const [wallet] = useState(() => new RazorWalletAdapter());
    const [account, setAccount] = useState<string | null>(null);
    const [connected, setConnected] = useState(false);
    const [connecting, setConnecting] = useState(false);
    
    const connect = useCallback(async () => {
        setConnecting(true);
        try {
            const address = await wallet.connect();
            setAccount(address);
            setConnected(!!address);
        } catch (error) {
            console.error('ì—°ê²° ì‹¤íŒ¨:', error);
        } finally {
            setConnecting(false);
        }
    }, [wallet]);
    
    const disconnect = useCallback(async () => {
        try {
            await wallet.disconnect();
            setAccount(null);
            setConnected(false);
        } catch (error) {
            console.error('ì—°ê²° í•´ì œ ì‹¤íŒ¨:', error);
        }
    }, [wallet]);
    
    const sendTransaction = useCallback(async (transaction: any) => {
        if (!connected) {
            throw new Error('ì§€ê°‘ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
        }
        
        return await wallet.signAndSubmitTransaction(transaction);
    }, [wallet, connected]);
    
    useEffect(() => {
        const currentAccount = wallet.getCurrentAccount();
        if (currentAccount) {
            setAccount(currentAccount);
            setConnected(true);
        }
    }, [wallet]);
    
    return {
        wallet,
        account,
        connected,
        connecting,
        connect,
        disconnect,
        sendTransaction
    };
};
```

## ğŸŒ™ 2. Nightly Wallet ì—°ë™

### Nightly ì–´ëŒ‘í„°
```typescript
// utils/nightlyWallet.ts
interface NightlyWallet {
    connect(): Promise<{ address: string; publicKey: string }>;
    disconnect(): Promise<void>;
    signAndSubmitTransaction(payload: any): Promise<any>;
    signMessage(message: Uint8Array): Promise<{ signature: string }>;
    isConnected(): boolean;
    getAccount(): { address: string } | null;
}

declare global {
    interface Window {
        nightly?: {
            movement?: NightlyWallet;
        };
    }
}

export class NightlyWalletAdapter {
    private wallet: NightlyWallet | null = null;
    
    constructor() {
        this.initializeWallet();
    }
    
    private async initializeWallet(): Promise<void> {
        // NightlyëŠ” lazy loadingì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
        if (typeof window !== 'undefined') {
            await this.waitForNightly();
        }
    }
    
    private async waitForNightly(timeout: number = 3000): Promise<void> {
        return new Promise((resolve, reject) => {
            if (window.nightly?.movement) {
                this.wallet = window.nightly.movement;
                resolve();
                return;
            }
            
            const interval = setInterval(() => {
                if (window.nightly?.movement) {
                    this.wallet = window.nightly.movement;
                    clearInterval(interval);
                    clearTimeout(timeoutId);
                    resolve();
                }
            }, 100);
            
            const timeoutId = setTimeout(() => {
                clearInterval(interval);
                reject(new Error('Nightly Wallet ë¡œë“œ íƒ€ì„ì•„ì›ƒ'));
            }, timeout);
        });
    }
    
    async connect(): Promise<string> {
        if (!this.wallet) {
            throw new Error('Nightly Walletì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        }
        
        try {
            const result = await this.wallet.connect();
            return result.address;
        } catch (error) {
            console.error('Nightly Wallet ì—°ê²° ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    async disconnect(): Promise<void> {
        if (this.wallet) {
            await this.wallet.disconnect();
        }
    }
    
    async signAndSubmitTransaction(payload: any): Promise<string> {
        if (!this.wallet || !this.wallet.isConnected()) {
            throw new Error('ì§€ê°‘ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
        }
        
        try {
            const result = await this.wallet.signAndSubmitTransaction(payload);
            return result.hash;
        } catch (error) {
            console.error('íŠ¸ëœì­ì…˜ ì‹¤í–‰ ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    isConnected(): boolean {
        return this.wallet?.isConnected() || false;
    }
    
    getCurrentAccount(): string | null {
        const account = this.wallet?.getAccount();
        return account?.address || null;
    }
}
```

## ğŸ”— 3. WalletConnect í†µí•©

### WalletConnect v2 êµ¬í˜„
```typescript
// utils/walletConnect.ts
import { SignClient } from '@walletconnect/sign-client';
import { SessionTypes } from '@walletconnect/types';

export class WalletConnectAdapter {
    private signClient: SignClient | null = null;
    private session: SessionTypes.Struct | null = null;
    
    async initialize(): Promise<void> {
        this.signClient = await SignClient.init({
            projectId: process.env.REACT_APP_WALLETCONNECT_PROJECT_ID!,
            metadata: {
                name: 'Movement dApp',
                description: 'Movement Network dApp',
                url: window.location.origin,
                icons: ['https://your-app.com/icon.png']
            }
        });
        
        // ê¸°ì¡´ ì„¸ì…˜ ë³µêµ¬
        const sessions = this.signClient.session.getAll();
        if (sessions.length > 0) {
            this.session = sessions[0];
        }
    }
    
    async connect(): Promise<string> {
        if (!this.signClient) {
            throw new Error('WalletConnectê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
        }
        
        try {
            const { uri, approval } = await this.signClient.connect({
                requiredNamespaces: {
                    movement: {
                        methods: [
                            'movement_signAndSubmitTransaction',
                            'movement_signMessage'
                        ],
                        chains: ['movement:testnet', 'movement:mainnet'],
                        events: ['accountsChanged', 'chainChanged']
                    }
                }
            });
            
            if (uri) {
                // QR ì½”ë“œ ë˜ëŠ” ë”¥ë§í¬ë¡œ URI í‘œì‹œ
                this.showConnectionURI(uri);
            }
            
            this.session = await approval();
            const accounts = this.session.namespaces.movement.accounts;
            
            return accounts[0].split(':')[2]; // ì£¼ì†Œ ì¶”ì¶œ
        } catch (error) {
            console.error('WalletConnect ì—°ê²° ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    async disconnect(): Promise<void> {
        if (this.signClient && this.session) {
            await this.signClient.disconnect({
                topic: this.session.topic,
                reason: {
                    code: 6000,
                    message: 'User disconnected'
                }
            });
            this.session = null;
        }
    }
    
    async signAndSubmitTransaction(transaction: any): Promise<string> {
        if (!this.signClient || !this.session) {
            throw new Error('ì„¸ì…˜ì´ ì—†ìŠµë‹ˆë‹¤');
        }
        
        try {
            const result = await this.signClient.request({
                topic: this.session.topic,
                chainId: 'movement:testnet',
                request: {
                    method: 'movement_signAndSubmitTransaction',
                    params: [transaction]
                }
            });
            
            return result.hash;
        } catch (error) {
            console.error('íŠ¸ëœì­ì…˜ ì‹¤í–‰ ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    private showConnectionURI(uri: string): void {
        // QR ì½”ë“œ ìƒì„± ë° í‘œì‹œ ë¡œì§
        // ë˜ëŠ” ëª¨ë°”ì¼ ë”¥ë§í¬ ì²˜ë¦¬
        console.log('WalletConnect URI:', uri);
    }
}
```

## ğŸ¯ 4. í†µí•© ì§€ê°‘ ê´€ë¦¬ì

### ë©€í‹° ì§€ê°‘ ì–´ëŒ‘í„°
```typescript
// utils/walletManager.ts
export enum WalletType {
    RAZOR = 'razor',
    NIGHTLY = 'nightly',
    WALLETCONNECT = 'walletconnect',
    MOVEMENT_MOBILE = 'movement-mobile'
}

interface BaseWallet {
    connect(): Promise<string>;
    disconnect(): Promise<void>;
    signAndSubmitTransaction(transaction: any): Promise<string>;
    isConnected(): boolean;
    getCurrentAccount(): string | null;
}

export class UniversalWalletManager {
    private adapters: Map<WalletType, BaseWallet> = new Map();
    private currentWallet: WalletType | null = null;
    
    constructor() {
        this.initializeAdapters();
    }
    
    private initializeAdapters(): void {
        this.adapters.set(WalletType.RAZOR, new RazorWalletAdapter());
        this.adapters.set(WalletType.NIGHTLY, new NightlyWalletAdapter());
        this.adapters.set(WalletType.WALLETCONNECT, new WalletConnectAdapter());
    }
    
    getAvailableWallets(): WalletType[] {
        const available: WalletType[] = [];
        
        if (window.razor) available.push(WalletType.RAZOR);
        if (window.nightly?.movement) available.push(WalletType.NIGHTLY);
        available.push(WalletType.WALLETCONNECT); // í•­ìƒ ì‚¬ìš© ê°€ëŠ¥
        
        return available;
    }
    
    async connect(walletType: WalletType): Promise<string> {
        const adapter = this.adapters.get(walletType);
        if (!adapter) {
            throw new Error(`ì§€ì›í•˜ì§€ ì•ŠëŠ” ì§€ê°‘: ${walletType}`);
        }
        
        try {
            const address = await adapter.connect();
            this.currentWallet = walletType;
            
            // ì§€ê°‘ ì„ íƒ ì €ì¥
            localStorage.setItem('selectedWallet', walletType);
            
            return address;
        } catch (error) {
            console.error(`${walletType} ì—°ê²° ì‹¤íŒ¨:`, error);
            throw error;
        }
    }
    
    async disconnect(): Promise<void> {
        if (this.currentWallet) {
            const adapter = this.adapters.get(this.currentWallet);
            if (adapter) {
                await adapter.disconnect();
            }
            
            this.currentWallet = null;
            localStorage.removeItem('selectedWallet');
        }
    }
    
    async signAndSubmitTransaction(transaction: any): Promise<string> {
        if (!this.currentWallet) {
            throw new Error('ì—°ê²°ëœ ì§€ê°‘ì´ ì—†ìŠµë‹ˆë‹¤');
        }
        
        const adapter = this.adapters.get(this.currentWallet);
        if (!adapter) {
            throw new Error('ì§€ê°‘ ì–´ëŒ‘í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        }
        
        return await adapter.signAndSubmitTransaction(transaction);
    }
    
    isConnected(): boolean {
        if (!this.currentWallet) return false;
        
        const adapter = this.adapters.get(this.currentWallet);
        return adapter?.isConnected() || false;
    }
    
    getCurrentAccount(): string | null {
        if (!this.currentWallet) return null;
        
        const adapter = this.adapters.get(this.currentWallet);
        return adapter?.getCurrentAccount() || null;
    }
    
    getCurrentWalletType(): WalletType | null {
        return this.currentWallet;
    }
    
    async autoReconnect(): Promise<boolean> {
        const savedWallet = localStorage.getItem('selectedWallet') as WalletType;
        
        if (savedWallet && this.getAvailableWallets().includes(savedWallet)) {
            try {
                await this.connect(savedWallet);
                return true;
            } catch (error) {
                console.error('ìë™ ì¬ì—°ê²° ì‹¤íŒ¨:', error);
                localStorage.removeItem('selectedWallet');
            }
        }
        
        return false;
    }
}
```

### React Context Provider
```typescript
// contexts/WalletContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { UniversalWalletManager, WalletType } from '../utils/walletManager';

interface WalletContextType {
    walletManager: UniversalWalletManager;
    account: string | null;
    connected: boolean;
    connecting: boolean;
    availableWallets: WalletType[];
    currentWalletType: WalletType | null;
    connect: (walletType: WalletType) => Promise<void>;
    disconnect: () => Promise<void>;
    sendTransaction: (transaction: any) => Promise<string>;
}

const WalletContext = createContext<WalletContextType | undefined>(undefined);

interface WalletProviderProps {
    children: ReactNode;
}

export const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {
    const [walletManager] = useState(() => new UniversalWalletManager());
    const [account, setAccount] = useState<string | null>(null);
    const [connected, setConnected] = useState(false);
    const [connecting, setConnecting] = useState(false);
    const [availableWallets, setAvailableWallets] = useState<WalletType[]>([]);
    const [currentWalletType, setCurrentWalletType] = useState<WalletType | null>(null);
    
    const connect = async (walletType: WalletType) => {
        setConnecting(true);
        try {
            const address = await walletManager.connect(walletType);
            setAccount(address);
            setConnected(true);
            setCurrentWalletType(walletType);
        } catch (error) {
            console.error('ì§€ê°‘ ì—°ê²° ì‹¤íŒ¨:', error);
            throw error;
        } finally {
            setConnecting(false);
        }
    };
    
    const disconnect = async () => {
        try {
            await walletManager.disconnect();
            setAccount(null);
            setConnected(false);
            setCurrentWalletType(null);
        } catch (error) {
            console.error('ì§€ê°‘ ì—°ê²° í•´ì œ ì‹¤íŒ¨:', error);
            throw error;
        }
    };
    
    const sendTransaction = async (transaction: any): Promise<string> => {
        return await walletManager.signAndSubmitTransaction(transaction);
    };
    
    useEffect(() => {
        const initializeWallets = async () => {
            // ì‚¬ìš© ê°€ëŠ¥í•œ ì§€ê°‘ ê°ì§€
            setAvailableWallets(walletManager.getAvailableWallets());
            
            // ìë™ ì¬ì—°ê²° ì‹œë„
            const reconnected = await walletManager.autoReconnect();
            if (reconnected) {
                setAccount(walletManager.getCurrentAccount());
                setConnected(walletManager.isConnected());
                setCurrentWalletType(walletManager.getCurrentWalletType());
            }
        };
        
        initializeWallets();
    }, [walletManager]);
    
    const value: WalletContextType = {
        walletManager,
        account,
        connected,
        connecting,
        availableWallets,
        currentWalletType,
        connect,
        disconnect,
        sendTransaction
    };
    
    return (
        <WalletContext.Provider value={value}>
            {children}
        </WalletContext.Provider>
    );
};

export const useWallet = (): WalletContextType => {
    const context = useContext(WalletContext);
    if (!context) {
        throw new Error('useWalletì€ WalletProvider ë‚´ì—ì„œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤');
    }
    return context;
};
```

## ğŸ¨ 5. UI ì»´í¬ë„ŒíŠ¸

### ì§€ê°‘ ì„ íƒ ëª¨ë‹¬
```typescript
// components/WalletModal.tsx
import React, { useState } from 'react';
import { useWallet } from '../contexts/WalletContext';
import { WalletType } from '../utils/walletManager';

interface WalletModalProps {
    isOpen: boolean;
    onClose: () => void;
}

const walletInfo = {
    [WalletType.RAZOR]: {
        name: 'Razor Wallet',
        icon: '/icons/razor.png',
        description: 'Movement ë„¤ì´í‹°ë¸Œ ì§€ê°‘'
    },
    [WalletType.NIGHTLY]: {
        name: 'Nightly',
        icon: '/icons/nightly.png', 
        description: 'ë©€í‹°ì²´ì¸ ì§€ê°‘'
    },
    [WalletType.WALLETCONNECT]: {
        name: 'WalletConnect',
        icon: '/icons/walletconnect.png',
        description: 'ëª¨ë°”ì¼ ì§€ê°‘ ì—°ê²°'
    }
};

export const WalletModal: React.FC<WalletModalProps> = ({ isOpen, onClose }) => {
    const { connect, availableWallets, connecting } = useWallet();
    const [selectedWallet, setSelectedWallet] = useState<WalletType | null>(null);
    
    if (!isOpen) return null;
    
    const handleConnect = async (walletType: WalletType) => {
        setSelectedWallet(walletType);
        try {
            await connect(walletType);
            onClose();
        } catch (error) {
            console.error('ì—°ê²° ì‹¤íŒ¨:', error);
        } finally {
            setSelectedWallet(null);
        }
    };
    
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white rounded-lg p-6 w-96 max-w-sm mx-4">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold">ì§€ê°‘ ì—°ê²°</h2>
                    <button 
                        onClick={onClose}
                        className="text-gray-500 hover:text-gray-700"
                    >
                        âœ•
                    </button>
                </div>
                
                <div className="space-y-3">
                    {availableWallets.map((walletType) => {
                        const info = walletInfo[walletType];
                        const isLoading = connecting && selectedWallet === walletType;
                        
                        return (
                            <button
                                key={walletType}
                                onClick={() => handleConnect(walletType)}
                                disabled={connecting}
                                className="w-full flex items-center p-4 border rounded-lg hover:bg-gray-50 disabled:opacity-50"
                            >
                                <img 
                                    src={info.icon} 
                                    alt={info.name}
                                    className="w-8 h-8 mr-3"
                                />
                                <div className="flex-1 text-left">
                                    <div className="font-medium">{info.name}</div>
                                    <div className="text-sm text-gray-500">
                                        {info.description}
                                    </div>
                                </div>
                                {isLoading && (
                                    <div className="ml-2">
                                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                                    </div>
                                )}
                            </button>
                        );
                    })}
                </div>
                
                {availableWallets.length === 0 && (
                    <div className="text-center text-gray-500 py-8">
                        ì§€ì›í•˜ëŠ” ì§€ê°‘ì´ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.
                    </div>
                )}
            </div>
        </div>
    );
};
```

### ì§€ê°‘ ì—°ê²° ë²„íŠ¼
```typescript
// components/ConnectButton.tsx
import React, { useState } from 'react';
import { useWallet } from '../contexts/WalletContext';
import { WalletModal } from './WalletModal';

export const ConnectButton: React.FC = () => {
    const { connected, account, disconnect, currentWalletType } = useWallet();
    const [modalOpen, setModalOpen] = useState(false);
    const [dropdownOpen, setDropdownOpen] = useState(false);
    
    if (connected && account) {
        return (
            <div className="relative">
                <button
                    onClick={() => setDropdownOpen(!dropdownOpen)}
                    className="flex items-center space-x-2 bg-green-100 text-green-800 px-4 py-2 rounded-lg"
                >
                    <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                    <span className="font-medium">
                        {`${account.slice(0, 6)}...${account.slice(-4)}`}
                    </span>
                    <span className="text-xs text-green-600">
                        {currentWalletType}
                    </span>
                </button>
                
                {dropdownOpen && (
                    <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg z-10">
                        <div className="py-1">
                            <button
                                onClick={() => navigator.clipboard.writeText(account)}
                                className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                            >
                                ì£¼ì†Œ ë³µì‚¬
                            </button>
                            <button
                                onClick={disconnect}
                                className="block px-4 py-2 text-sm text-red-700 hover:bg-red-50 w-full text-left"
                            >
                                ì—°ê²° í•´ì œ
                            </button>
                        </div>
                    </div>
                )}
            </div>
        );
    }
    
    return (
        <>
            <button
                onClick={() => setModalOpen(true)}
                className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700"
            >
                ì§€ê°‘ ì—°ê²°
            </button>
            
            <WalletModal 
                isOpen={modalOpen}
                onClose={() => setModalOpen(false)}
            />
        </>
    );
};
```

## ğŸ”’ 6. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### íŠ¸ëœì­ì…˜ ê²€ì¦
```typescript
// utils/transactionValidator.ts
export class TransactionValidator {
    static validateTransaction(transaction: any): boolean {
        // í•„ìˆ˜ í•„ë“œ í™•ì¸
        if (!transaction.function || !transaction.arguments) {
            return false;
        }
        
        // ê°€ìŠ¤ í•œë„ í™•ì¸
        if (transaction.max_gas_amount && transaction.max_gas_amount > 1000000) {
            console.warn('ë†’ì€ ê°€ìŠ¤ í•œë„ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤');
            return confirm('ë†’ì€ ê°€ìŠ¤ ë¹„ìš©ì´ ì˜ˆìƒë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
        }
        
        // ìœ„í—˜í•œ í•¨ìˆ˜ í˜¸ì¶œ í™•ì¸
        const dangerousFunctions = [
            'transfer_all',
            'burn_all', 
            'destroy_account'
        ];
        
        if (dangerousFunctions.some(fn => transaction.function.includes(fn))) {
            console.warn('ìœ„í—˜í•œ í•¨ìˆ˜ í˜¸ì¶œì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤');
            return confirm('ì´ íŠ¸ëœì­ì…˜ì€ ìœ„í—˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
        }
        
        return true;
    }
    
    static sanitizeTransaction(transaction: any): any {
        // íŠ¸ëœì­ì…˜ ë°ì´í„° ì •í™”
        return {
            ...transaction,
            max_gas_amount: Math.min(transaction.max_gas_amount || 100000, 1000000),
            gas_unit_price: Math.min(transaction.gas_unit_price || 100, 10000)
        };
    }
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

ì§€ê°‘ ì—°ë™ì„ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[ê°œë°œ í™˜ê²½ (VS Code/IntelliJ) â†’](/developer-tools/ide-setup)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement ê³µì‹ ë¬¸ì„œ](https://docs.movementnetwork.xyz/)
- [Razor Wallet ë¬¸ì„œ](https://docs.razorwallet.xyz/)
- [Nightly Wallet ë¬¸ì„œ](https://docs.nightly.app/)
- [WalletConnect ë¬¸ì„œ](https://docs.walletconnect.com/)

---

*ë‹¤ì–‘í•œ ì§€ê°‘ì„ ì§€ì›í•˜ì—¬ ì‚¬ìš©ì ì ‘ê·¼ì„±ì„ ê·¹ëŒ€í™”í•˜ì„¸ìš”! ğŸ’³ğŸš€*