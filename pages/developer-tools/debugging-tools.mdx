# ğŸ” ë””ë²„ê¹… & ëª¨ë‹ˆí„°ë§

Movement ê°œë°œì—ì„œ ë°œìƒí•˜ëŠ” ë¬¸ì œë¥¼ íš¨ê³¼ì ìœ¼ë¡œ í•´ê²°í•˜ê³  ì‹œìŠ¤í…œì„ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. ì‹¤ì „ì—ì„œ ë°”ë¡œ í™œìš©í•  ìˆ˜ ìˆëŠ” ë””ë²„ê¹… ê¸°ë²•ê³¼ ë„êµ¬ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- ë‹¤ì–‘í•œ Move ì—ëŸ¬ë¥¼ ì²´ê³„ì ìœ¼ë¡œ ë””ë²„ê¹…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- íŠ¸ëœì­ì…˜ ì‹¤í–‰ ê³¼ì •ì„ ìƒì„¸íˆ ì¶”ì í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì„±ëŠ¥ ë³‘ëª©ì„ ì‹ë³„í•˜ê³  ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ› ï¸ ë””ë²„ê¹… ë„êµ¬ ìŠ¤íƒ

| ë„êµ¬ | ìš©ë„ | ë‚œì´ë„ | íš¨ê³¼ |
|------|------|--------|------|
| **Movement CLI** | ê¸°ë³¸ ë””ë²„ê¹… | â­â­ | ğŸ¯ğŸ¯ğŸ¯ğŸ¯ |
| **VS Code Debugger** | IDE í†µí•© ë””ë²„ê¹… | â­â­â­ | ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ |
| **Log Analysis** | ë¡œê·¸ ë¶„ì„ | â­â­ | ğŸ¯ğŸ¯ğŸ¯ |
| **Transaction Tracer** | íŠ¸ëœì­ì…˜ ì¶”ì  | â­â­â­â­ | ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ |
| **Performance Profiler** | ì„±ëŠ¥ ë¶„ì„ | â­â­â­â­â­ | ğŸ¯ğŸ¯ğŸ¯ğŸ¯ğŸ¯ |

## ğŸ› 1. ê¸°ë³¸ ë””ë²„ê¹… ê¸°ë²•

### ì»´íŒŒì¼ ì—ëŸ¬ í•´ê²°
```bash
# ìƒì„¸ ì»´íŒŒì¼ ì—ëŸ¬ ì •ë³´
movement move build --verbose

# íŠ¹ì • ëª¨ë“ˆë§Œ ì²´í¬
movement move check --package core

# ì˜ì¡´ì„± ë¬¸ì œ í™•ì¸
movement move deps --check-conflicts
```

### ëŸ°íƒ€ì„ ì—ëŸ¬ ë””ë²„ê¹…
```move
// ë””ë²„ê¹…ìš© í•¨ìˆ˜ ì˜ˆì‹œ
module movement::debug_utils {
    use std::debug;
    use std::string;
    
    // ë””ë²„ê·¸ ì¶œë ¥ (í…ŒìŠ¤íŠ¸ì—ì„œë§Œ ë™ì‘)
    public fun debug_print(msg: vector<u8>) {
        debug::print(&string::utf8(msg));
    }
    
    // ì¡°ê±´ë¶€ ë””ë²„ê·¸
    public fun debug_assert(condition: bool, msg: vector<u8>) {
        if (!condition) {
            debug::print(&string::utf8(b"Debug Assert Failed: "));
            debug::print(&string::utf8(msg));
        }
        assert!(condition, 999);
    }
    
    // ê°’ ì¶”ì 
    public fun trace_value<T: drop>(label: vector<u8>, value: T): T {
        debug::print(&string::utf8(label));
        debug::print(&value);
        value
    }
}
```

### ì—ëŸ¬ ì½”ë“œ ì²´ê³„í™”
```move
module movement::error_codes {
    // ì—ëŸ¬ ì¹´í…Œê³ ë¦¬ë³„ ë¶„ë¥˜
    
    // ê¶Œí•œ ê´€ë ¨ (1000ë²ˆëŒ€)
    public fun e_not_authorized(): u64 { 1001 }
    public fun e_not_owner(): u64 { 1002 }
    public fun e_insufficient_permission(): u64 { 1003 }
    
    // ìƒíƒœ ê´€ë ¨ (2000ë²ˆëŒ€)  
    public fun e_already_exists(): u64 { 2001 }
    public fun e_not_found(): u64 { 2002 }
    public fun e_invalid_state(): u64 { 2003 }
    
    // ì…ë ¥ ê²€ì¦ (3000ë²ˆëŒ€)
    public fun e_invalid_address(): u64 { 3001 }
    public fun e_invalid_amount(): u64 { 3002 }
    public fun e_invalid_parameter(): u64 { 3003 }
    
    // ë¦¬ì†ŒìŠ¤ ê´€ë ¨ (4000ë²ˆëŒ€)
    public fun e_insufficient_balance(): u64 { 4001 }
    public fun e_resource_exhausted(): u64 { 4002 }
    public fun e_quota_exceeded(): u64 { 4003 }
    
    // ì—ëŸ¬ ë©”ì‹œì§€ í—¬í¼
    public fun get_error_message(code: u64): vector<u8> {
        if (code == 1001) b"Not authorized"
        else if (code == 1002) b"Not owner"
        else if (code == 2001) b"Already exists"
        else if (code == 2002) b"Not found"
        else if (code == 3001) b"Invalid address"
        else if (code == 4001) b"Insufficient balance"
        else b"Unknown error"
    }
}
```

## ğŸ”¬ 2. ê³ ê¸‰ ë””ë²„ê¹… ë„êµ¬

### íŠ¸ëœì­ì…˜ ì¶”ì ê¸°
```typescript
// utils/transactionTracer.ts
import { MovementClient } from '@movementlabs/movement-sdk';

export class TransactionTracer {
    private client: MovementClient;
    
    constructor(client: MovementClient) {
        this.client = client;
    }
    
    // íŠ¸ëœì­ì…˜ ìƒì„¸ ë¶„ì„
    async traceTransaction(txHash: string): Promise<TransactionTrace> {
        console.log(`ğŸ” íŠ¸ëœì­ì…˜ ì¶”ì  ì‹œì‘: ${txHash}`);
        
        try {
            // 1. ê¸°ë³¸ íŠ¸ëœì­ì…˜ ì •ë³´
            const txInfo = await this.client.getTransactionByHash(txHash);
            console.log('ğŸ“‹ ê¸°ë³¸ ì •ë³´:', {
                sender: txInfo.sender,
                sequence_number: txInfo.sequence_number,
                gas_used: txInfo.gas_used,
                success: txInfo.success
            });
            
            // 2. ì‹¤í–‰ ê³¼ì • ë¶„ì„
            const executionTrace = await this.analyzeExecution(txInfo);
            
            // 3. ìƒíƒœ ë³€ê²½ ì¶”ì 
            const stateChanges = await this.traceStateChanges(txInfo);
            
            // 4. ì´ë²¤íŠ¸ ë¶„ì„
            const events = await this.analyzeEvents(txInfo);
            
            // 5. ê°€ìŠ¤ ì‚¬ìš©ëŸ‰ ë¶„ì„
            const gasAnalysis = this.analyzeGasUsage(txInfo);
            
            return {
                transaction: txInfo,
                execution: executionTrace,
                stateChanges: stateChanges,
                events: events,
                gasAnalysis: gasAnalysis
            };
            
        } catch (error) {
            console.error('âŒ íŠ¸ëœì­ì…˜ ì¶”ì  ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    private async analyzeExecution(txInfo: any): Promise<ExecutionTrace> {
        // VM ì‹¤í–‰ ê³¼ì • ë¶„ì„
        const vmLogs = txInfo.vm_status?.type === "executed" 
            ? await this.getVMExecutionLogs(txInfo.hash)
            : null;
            
        return {
            status: txInfo.vm_status?.type,
            executionTime: txInfo.timestamp,
            vmLogs: vmLogs,
            functionCalls: this.extractFunctionCalls(txInfo.payload)
        };
    }
    
    private async traceStateChanges(txInfo: any): Promise<StateChange[]> {
        const changes: StateChange[] = [];
        
        // write_setì—ì„œ ìƒíƒœ ë³€ê²½ ì¶”ì¶œ
        if (txInfo.changes) {
            for (const change of txInfo.changes) {
                changes.push({
                    address: change.address,
                    type: change.type,
                    resource: change.data?.type,
                    before: change.data?.data_before,
                    after: change.data?.data_after
                });
            }
        }
        
        return changes;
    }
    
    private analyzeGasUsage(txInfo: any): GasAnalysis {
        return {
            gasUsed: parseInt(txInfo.gas_used),
            gasLimit: parseInt(txInfo.max_gas_amount),
            gasPrice: parseInt(txInfo.gas_unit_price),
            totalCost: parseInt(txInfo.gas_used) * parseInt(txInfo.gas_unit_price),
            efficiency: (parseInt(txInfo.gas_used) / parseInt(txInfo.max_gas_amount)) * 100
        };
    }
}

// íƒ€ì… ì •ì˜
interface TransactionTrace {
    transaction: any;
    execution: ExecutionTrace;
    stateChanges: StateChange[];
    events: any[];
    gasAnalysis: GasAnalysis;
}

interface ExecutionTrace {
    status: string;
    executionTime: string;
    vmLogs: any;
    functionCalls: string[];
}

interface StateChange {
    address: string;
    type: string;
    resource: string;
    before: any;
    after: any;
}

interface GasAnalysis {
    gasUsed: number;
    gasLimit: number;
    gasPrice: number;
    totalCost: number;
    efficiency: number;
}
```

### ì‹¤ì‹œê°„ ë¡œê·¸ ëª¨ë‹ˆí„°ë§
```bash
#!/bin/bash
# scripts/monitor-logs.sh

echo "=== Movement ì‹¤ì‹œê°„ ë¡œê·¸ ëª¨ë‹ˆí„°ë§ ==="

# ë¡œê·¸ ë ˆë²¨ ì„¤ì •
export RUST_LOG="movement=debug,movement::compiler=trace"

# ì»¬ëŸ¬ ì¶œë ¥ ì„¤ì •
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ë¡œê·¸ í•„í„°ë§ í•¨ìˆ˜
filter_logs() {
    while IFS= read -r line; do
        if [[ $line == *"ERROR"* ]]; then
            echo -e "${RED}$line${NC}"
        elif [[ $line == *"WARN"* ]]; then
            echo -e "${YELLOW}$line${NC}"
        elif [[ $line == *"INFO"* ]]; then
            echo -e "${GREEN}$line${NC}"
        elif [[ $line == *"DEBUG"* ]]; then
            echo -e "${BLUE}$line${NC}"
        else
            echo "$line"
        fi
    done
}

# Movement í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ ë° ë¡œê·¸ ê°ì‹œ
movement move test --verbose 2>&1 | filter_logs
```

### ì„±ëŠ¥ í”„ë¡œíŒŒì¼ëŸ¬
```rust
// tools/profiler.rs
use std::time::{Duration, Instant};
use std::collections::HashMap;

pub struct PerformanceProfiler {
    timers: HashMap<String, Instant>,
    results: HashMap<String, Duration>,
}

impl PerformanceProfiler {
    pub fn new() -> Self {
        Self {
            timers: HashMap::new(),
            results: HashMap::new(),
        }
    }
    
    // íƒ€ì´ë¨¸ ì‹œì‘
    pub fn start_timer(&mut self, name: &str) {
        self.timers.insert(name.to_string(), Instant::now());
    }
    
    // íƒ€ì´ë¨¸ ì¢…ë£Œ
    pub fn end_timer(&mut self, name: &str) -> Duration {
        if let Some(start_time) = self.timers.remove(name) {
            let duration = start_time.elapsed();
            self.results.insert(name.to_string(), duration);
            duration
        } else {
            Duration::from_secs(0)
        }
    }
    
    // í•¨ìˆ˜ ì‹¤í–‰ ì‹œê°„ ì¸¡ì •
    pub fn profile_function<F, R>(&mut self, name: &str, func: F) -> R
    where
        F: FnOnce() -> R,
    {
        self.start_timer(name);
        let result = func();
        let duration = self.end_timer(name);
        
        println!("â±ï¸ {}: {:?}", name, duration);
        result
    }
    
    // ê²°ê³¼ ë¦¬í¬íŠ¸ ìƒì„±
    pub fn generate_report(&self) -> String {
        let mut report = String::from("=== ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ê²°ê³¼ ===\n");
        
        let mut sorted_results: Vec<_> = self.results.iter().collect();
        sorted_results.sort_by(|a, b| b.1.cmp(a.1)); // ì‹œê°„ ìˆœìœ¼ë¡œ ì •ë ¬
        
        for (name, duration) in sorted_results {
            report.push_str(&format!("{}: {:?}\n", name, duration));
        }
        
        report
    }
    
    // ë³‘ëª© ì§€ì  ì‹ë³„
    pub fn identify_bottlenecks(&self, threshold_ms: u64) -> Vec<String> {
        self.results
            .iter()
            .filter(|(_, duration)| duration.as_millis() > threshold_ms as u128)
            .map(|(name, _)| name.clone())
            .collect()
    }
}

// ë§¤í¬ë¡œë¡œ ì‰¬ìš´ ì‚¬ìš©
#[macro_export]
macro_rules! profile {
    ($profiler:expr, $name:expr, $code:block) => {
        $profiler.profile_function($name, || $code)
    };
}
```

## ğŸ“Š 3. ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

### ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
```typescript
// monitoring/metricsCollector.ts
export class MetricsCollector {
    private metrics: Map<string, number[]> = new Map();
    private client: MovementClient;
    
    constructor(client: MovementClient) {
        this.client = client;
    }
    
    // ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ëª¨ë‹ˆí„°ë§
    async collectNetworkMetrics(): Promise<NetworkMetrics> {
        const startTime = Date.now();
        
        try {
            // ë¸”ë¡ ë†’ì´
            const ledgerInfo = await this.client.getLedgerInfo();
            const blockHeight = parseInt(ledgerInfo.block_height);
            
            // íŠ¸ëœì­ì…˜ ì²˜ë¦¬ëŸ‰ (TPS)
            const tps = await this.calculateTPS();
            
            // ë„¤íŠ¸ì›Œí¬ ì§€ì—°ì‹œê°„
            const latency = Date.now() - startTime;
            
            // ê°€ìŠ¤ ê°€ê²©
            const gasPrice = await this.getAverageGasPrice();
            
            const metrics = {
                blockHeight,
                tps,
                latency,
                gasPrice,
                timestamp: new Date().toISOString()
            };
            
            this.recordMetric('network', metrics);
            return metrics;
            
        } catch (error) {
            console.error('ë„¤íŠ¸ì›Œí¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    // ê³„ì • ë©”íŠ¸ë¦­ ëª¨ë‹ˆí„°ë§
    async collectAccountMetrics(address: string): Promise<AccountMetrics> {
        try {
            const accountInfo = await this.client.getAccount(address);
            const balance = await this.client.getAccountBalance(address);
            const resources = await this.client.getAccountResources(address);
            const transactions = await this.client.getAccountTransactions(address, { limit: 100 });
            
            const metrics = {
                address,
                balance: parseInt(balance),
                sequenceNumber: parseInt(accountInfo.sequence_number),
                resourceCount: resources.length,
                transactionCount: transactions.length,
                lastActivity: transactions[0]?.timestamp || null,
                timestamp: new Date().toISOString()
            };
            
            this.recordMetric('account', metrics);
            return metrics;
            
        } catch (error) {
            console.error('ê³„ì • ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    // ìŠ¤ë§ˆíŠ¸ ê³„ì•½ ë©”íŠ¸ë¦­
    async collectContractMetrics(contractAddress: string): Promise<ContractMetrics> {
        try {
            const modules = await this.client.getAccountModules(contractAddress);
            const resources = await this.client.getAccountResources(contractAddress);
            const events = await this.client.getEventsByCreationNumber(contractAddress);
            
            const metrics = {
                contractAddress,
                moduleCount: modules.length,
                resourceCount: resources.length,
                eventCount: events.length,
                lastEvent: events[0]?.timestamp || null,
                timestamp: new Date().toISOString()
            };
            
            this.recordMetric('contract', metrics);
            return metrics;
            
        } catch (error) {
            console.error('ê³„ì•½ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨:', error);
            throw error;
        }
    }
    
    private async calculateTPS(): Promise<number> {
        // ìµœê·¼ ë¸”ë¡ë“¤ì˜ íŠ¸ëœì­ì…˜ ìˆ˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ TPS ê³„ì‚°
        const ledgerInfo = await this.client.getLedgerInfo();
        const currentHeight = parseInt(ledgerInfo.block_height);
        
        // ìµœê·¼ 10ê°œ ë¸”ë¡ ë¶„ì„
        let totalTxs = 0;
        let totalTime = 0;
        
        for (let i = 0; i < 10; i++) {
            try {
                const blockInfo = await this.client.getBlockByHeight(currentHeight - i);
                totalTxs += blockInfo.transactions?.length || 0;
                // ë¸”ë¡ ì‹œê°„ ê°„ê²© ê³„ì‚° (ê°„ì†Œí™”)
                totalTime += 1; // 1ì´ˆë¡œ ê°€ì •
            } catch (error) {
                // ë¸”ë¡ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                continue;
            }
        }
        
        return totalTime > 0 ? totalTxs / totalTime : 0;
    }
    
    private async getAverageGasPrice(): Promise<number> {
        // ìµœê·¼ íŠ¸ëœì­ì…˜ë“¤ì˜ í‰ê·  ê°€ìŠ¤ ê°€ê²© ê³„ì‚°
        try {
            const transactions = await this.client.getTransactions({ limit: 100 });
            let totalGasPrice = 0;
            let count = 0;
            
            for (const tx of transactions) {
                if (tx.gas_unit_price) {
                    totalGasPrice += parseInt(tx.gas_unit_price);
                    count++;
                }
            }
            
            return count > 0 ? totalGasPrice / count : 0;
        } catch (error) {
            console.error('ê°€ìŠ¤ ê°€ê²© ê³„ì‚° ì‹¤íŒ¨:', error);
            return 0;
        }
    }
    
    private recordMetric(type: string, data: any): void {
        if (!this.metrics.has(type)) {
            this.metrics.set(type, []);
        }
        
        const metrics = this.metrics.get(type)!;
        metrics.push(data);
        
        // ìµœê·¼ 1000ê°œ ë°ì´í„°ë§Œ ìœ ì§€
        if (metrics.length > 1000) {
            metrics.shift();
        }
    }
    
    // ë©”íŠ¸ë¦­ ë‚´ë³´ë‚´ê¸°
    getMetrics(type: string): any[] {
        return this.metrics.get(type) || [];
    }
    
    // ì•ŒëŒ ì¡°ê±´ ì²´í¬
    checkAlerts(): Alert[] {
        const alerts: Alert[] = [];
        
        // TPS ì•ŒëŒ
        const networkMetrics = this.getMetrics('network');
        if (networkMetrics.length > 0) {
            const latestTPS = networkMetrics[networkMetrics.length - 1].tps;
            if (latestTPS < 1) {
                alerts.push({
                    type: 'LOW_TPS',
                    message: `ë‚®ì€ TPS ê°ì§€: ${latestTPS}`,
                    severity: 'warning'
                });
            }
        }
        
        // ê°€ìŠ¤ ê°€ê²© ì•ŒëŒ
        const gasPrice = networkMetrics.length > 0 ? networkMetrics[networkMetrics.length - 1].gasPrice : 0;
        if (gasPrice > 1000) {
            alerts.push({
                type: 'HIGH_GAS_PRICE',
                message: `ë†’ì€ ê°€ìŠ¤ ê°€ê²©: ${gasPrice}`,
                severity: 'warning'
            });
        }
        
        return alerts;
    }
}

// íƒ€ì… ì •ì˜
interface NetworkMetrics {
    blockHeight: number;
    tps: number;
    latency: number;
    gasPrice: number;
    timestamp: string;
}

interface AccountMetrics {
    address: string;
    balance: number;
    sequenceNumber: number;
    resourceCount: number;
    transactionCount: number;
    lastActivity: string | null;
    timestamp: string;
}

interface ContractMetrics {
    contractAddress: string;
    moduleCount: number;
    resourceCount: number;
    eventCount: number;
    lastEvent: string | null;
    timestamp: string;
}

interface Alert {
    type: string;
    message: string;
    severity: 'info' | 'warning' | 'error';
}
```

### ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ
```typescript
// components/MonitoringDashboard.tsx
import React, { useState, useEffect } from 'react';
import { Line, Bar, Doughnut } from 'react-chartjs-2';
import { MetricsCollector } from '../monitoring/metricsCollector';

export const MonitoringDashboard: React.FC = () => {
    const [networkMetrics, setNetworkMetrics] = useState<any[]>([]);
    const [alerts, setAlerts] = useState<any[]>([]);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        const metricsCollector = new MetricsCollector(client);
        
        const collectMetrics = async () => {
            try {
                await metricsCollector.collectNetworkMetrics();
                const metrics = metricsCollector.getMetrics('network');
                const currentAlerts = metricsCollector.checkAlerts();
                
                setNetworkMetrics(metrics);
                setAlerts(currentAlerts);
            } catch (error) {
                console.error('ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨:', error);
            } finally {
                setLoading(false);
            }
        };
        
        // ì´ˆê¸° ìˆ˜ì§‘
        collectMetrics();
        
        // 30ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
        const interval = setInterval(collectMetrics, 30000);
        
        return () => clearInterval(interval);
    }, []);
    
    const tpsData = {
        labels: networkMetrics.map(m => new Date(m.timestamp).toLocaleTimeString()),
        datasets: [{
            label: 'TPS (Transactions Per Second)',
            data: networkMetrics.map(m => m.tps),
            borderColor: 'rgb(75, 192, 192)',
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            tension: 0.1
        }]
    };
    
    const latencyData = {
        labels: networkMetrics.map(m => new Date(m.timestamp).toLocaleTimeString()),
        datasets: [{
            label: 'ë„¤íŠ¸ì›Œí¬ ì§€ì—°ì‹œê°„ (ms)',
            data: networkMetrics.map(m => m.latency),
            borderColor: 'rgb(255, 99, 132)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            tension: 0.1
        }]
    };
    
    if (loading) {
        return (
            <div className="flex justify-center items-center h-64">
                <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500"></div>
            </div>
        );
    }
    
    return (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 p-6">
            {/* ì•ŒëŒ íŒ¨ë„ */}
            <div className="lg:col-span-3">
                <div className="bg-white rounded-lg shadow p-4">
                    <h3 className="text-lg font-semibold mb-4">ğŸš¨ ì‹¤ì‹œê°„ ì•ŒëŒ</h3>
                    {alerts.length > 0 ? (
                        <div className="space-y-2">
                            {alerts.map((alert, index) => (
                                <div
                                    key={index}
                                    className={`p-3 rounded ${
                                        alert.severity === 'error' ? 'bg-red-100 text-red-700' :
                                        alert.severity === 'warning' ? 'bg-yellow-100 text-yellow-700' :
                                        'bg-blue-100 text-blue-700'
                                    }`}
                                >
                                    <span className="font-medium">{alert.type}:</span> {alert.message}
                                </div>
                            ))}
                        </div>
                    ) : (
                        <p className="text-gray-500">í˜„ì¬ ì•ŒëŒì´ ì—†ìŠµë‹ˆë‹¤</p>
                    )}
                </div>
            </div>
            
            {/* TPS ì°¨íŠ¸ */}
            <div className="bg-white rounded-lg shadow p-4">
                <h3 className="text-lg font-semibold mb-4">ğŸ“Š TPS</h3>
                <Line data={tpsData} options={{ responsive: true }} />
            </div>
            
            {/* ì§€ì—°ì‹œê°„ ì°¨íŠ¸ */}
            <div className="bg-white rounded-lg shadow p-4">
                <h3 className="text-lg font-semibold mb-4">â±ï¸ ë„¤íŠ¸ì›Œí¬ ì§€ì—°ì‹œê°„</h3>
                <Line data={latencyData} options={{ responsive: true }} />
            </div>
            
            {/* í˜„ì¬ ìƒíƒœ */}
            <div className="bg-white rounded-lg shadow p-4">
                <h3 className="text-lg font-semibold mb-4">ğŸ“ˆ í˜„ì¬ ìƒíƒœ</h3>
                {networkMetrics.length > 0 && (
                    <div className="space-y-3">
                        <div className="flex justify-between">
                            <span>ë¸”ë¡ ë†’ì´:</span>
                            <span className="font-mono">{networkMetrics[networkMetrics.length - 1].blockHeight}</span>
                        </div>
                        <div className="flex justify-between">
                            <span>í˜„ì¬ TPS:</span>
                            <span className="font-mono">{networkMetrics[networkMetrics.length - 1].tps.toFixed(2)}</span>
                        </div>
                        <div className="flex justify-between">
                            <span>í‰ê·  ê°€ìŠ¤ ê°€ê²©:</span>
                            <span className="font-mono">{networkMetrics[networkMetrics.length - 1].gasPrice}</span>
                        </div>
                        <div className="flex justify-between">
                            <span>ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸:</span>
                            <span className="text-sm text-gray-500">
                                {new Date(networkMetrics[networkMetrics.length - 1].timestamp).toLocaleString()}
                            </span>
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
};
```

## ğŸš¨ 4. ì—ëŸ¬ í•´ê²° ê°€ì´ë“œ

### ì¼ë°˜ì ì¸ Move ì—ëŸ¬ë“¤

#### 1. ì†Œìœ ê¶Œ ë° ì°¨ìš© ì—ëŸ¬
```move
// âŒ ì˜ëª»ëœ ì˜ˆ
fun wrong_borrow() {
    let x = 10;
    let y = &x;
    let z = &mut x; // ì—ëŸ¬: ì´ë¯¸ ë¶ˆë³€ ì°¸ì¡°ê°€ ì¡´ì¬í•¨
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ  
fun correct_borrow() {
    let mut x = 10;
    {
        let y = &x; // ë¶ˆë³€ ì°¸ì¡°
        // y ì‚¬ìš©
    } // y ìŠ¤ì½”í”„ ì¢…ë£Œ
    let z = &mut x; // ê°€ë³€ ì°¸ì¡° ê°€ëŠ¥
}
```

#### 2. ë¦¬ì†ŒìŠ¤ ì´ë™ ì—ëŸ¬
```move
// âŒ ì˜ëª»ëœ ì˜ˆ
fun resource_move_error() {
    let resource = MyResource { value: 100 };
    use_resource(resource);
    use_resource(resource); // ì—ëŸ¬: ë¦¬ì†ŒìŠ¤ê°€ ì´ë¯¸ ì´ë™ë¨
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ
fun resource_move_correct() {
    let resource = MyResource { value: 100 };
    use_resource(copy resource); // copy ability í•„ìš”
    use_resource(resource);
}
```

#### 3. íƒ€ì… ë¶ˆì¼ì¹˜ ì—ëŸ¬
```move
// âŒ ì˜ëª»ëœ ì˜ˆ
fun type_mismatch() {
    let x: u64 = 100;
    let y: u8 = x; // ì—ëŸ¬: u64ë¥¼ u8ì— ì§ì ‘ í• ë‹¹ ë¶ˆê°€
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ
fun type_cast_correct() {
    let x: u64 = 100;
    assert!(x <= 255, 1); // ë²”ìœ„ ê²€ì‚¬
    let y: u8 = (x as u8); // ëª…ì‹œì  ìºìŠ¤íŒ…
}
```

### ë””ë²„ê¹… ì²´í¬ë¦¬ìŠ¤íŠ¸
```bash
# ë””ë²„ê¹… ì²´í¬ë¦¬ìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸
#!/bin/bash

echo "=== Move ë””ë²„ê¹… ì²´í¬ë¦¬ìŠ¤íŠ¸ ==="

# 1. ì»´íŒŒì¼ í™•ì¸
echo "1. ì»´íŒŒì¼ í™•ì¸..."
if movement move build; then
    echo "âœ… ì»´íŒŒì¼ ì„±ê³µ"
else
    echo "âŒ ì»´íŒŒì¼ ì‹¤íŒ¨ - ë¬¸ë²• ì˜¤ë¥˜ í™•ì¸ í•„ìš”"
    exit 1
fi

# 2. ë¦°íŠ¸ ê²€ì‚¬
echo "2. ë¦°íŠ¸ ê²€ì‚¬..."
movement move check

# 3. í…ŒìŠ¤íŠ¸ ì‹¤í–‰
echo "3. í…ŒìŠ¤íŠ¸ ì‹¤í–‰..."
if movement move test --verbose; then
    echo "âœ… ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼"
else
    echo "âŒ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ - ë¡œì§ ì˜¤ë¥˜ í™•ì¸ í•„ìš”"
fi

# 4. ê°€ìŠ¤ ì‚¬ìš©ëŸ‰ í™•ì¸
echo "4. ê°€ìŠ¤ ì‚¬ìš©ëŸ‰ ë¶„ì„..."
movement move test --gas-profile

# 5. ì˜ì¡´ì„± í™•ì¸
echo "5. ì˜ì¡´ì„± í™•ì¸..."
movement move deps --check-updates

echo "ë””ë²„ê¹… ì²´í¬ë¦¬ìŠ¤íŠ¸ ì™„ë£Œ!"
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

ë””ë²„ê¹… ë„êµ¬ë¥¼ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ â†’](/developer-tools/testing-framework)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement ê³µì‹ ë¬¸ì„œ](https://docs.movementnetwork.xyz/)
- [Move ë””ë²„ê¹… ê°€ì´ë“œ](https://move-language.github.io/move/debugging.html)

---

*ì²´ê³„ì ì¸ ë””ë²„ê¹…ìœ¼ë¡œ ì•ˆì •ì ì¸ ì½”ë“œë¥¼ ë§Œë“œì„¸ìš”! ğŸ”ğŸ› ï¸*