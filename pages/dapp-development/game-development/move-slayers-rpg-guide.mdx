# ğŸ® Move Slayers - ì˜¨ì²´ì¸ RPG ì™„ì „ ê°€ì´ë“œ

Movement Networkì—ì„œ Move ì–¸ì–´ë¡œ ì™„ì „í•œ ì˜¨ì²´ì¸ RPG ê²Œì„ì„ êµ¬ì¶•í•˜ëŠ” ì¢…í•© ê°€ì´ë“œì…ë‹ˆë‹¤. í”Œë ˆì´ì–´ ì‹œìŠ¤í…œë¶€í„° ì „íˆ¬, ì•„ì´í…œ, ê²½í—˜ì¹˜ê¹Œì§€ ëª¨ë“  ê²Œì„ ë©”ì»¤ë‹ˆì¦˜ì„ Moveë¡œ êµ¬í˜„í•´ë´…ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ê°€ì´ë“œë¥¼ ì™„ë£Œí•˜ë©´:
- Move ì–¸ì–´ë¡œ ë³µì¡í•œ ê²Œì„ ë¡œì§ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì˜¨ì²´ì¸ ìƒíƒœ ê´€ë¦¬ì™€ ìì› ì•ˆì „ì„±ì„ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í”Œë ˆì´ì–´, ì•„ì´í…œ, ì „íˆ¬ ì‹œìŠ¤í…œì„ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í…ŒìŠ¤íŠ¸ ì£¼ë„ ê°œë°œë¡œ ì•ˆì •ì ì¸ ê²Œì„ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì‹¤ì œ í”Œë ˆì´ ê°€ëŠ¥í•œ RPG ê²Œì„ì„ ë°°í¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ—ï¸ í”„ë¡œì íŠ¸ êµ¬ì¡°

Move Slayers RPGëŠ” ë‹¤ìŒê³¼ ê°™ì€ ëª¨ë“ˆí˜• êµ¬ì¡°ë¡œ ì„¤ê³„ë©ë‹ˆë‹¤:

```
move_slayers/
â”œâ”€â”€ sources/
â”‚   â”œâ”€â”€ hero.move      # í”Œë ˆì´ì–´ ë¡œì§ ë° ê²Œì„ ë©”ì»¤ë‹ˆì¦˜
â”‚   â””â”€â”€ enemies.move   # ì  ì •ì˜ ë° ì „íˆ¬ ì‹œìŠ¤í…œ
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ hero_tests.move # ì¢…í•© í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸
â””â”€â”€ Move.toml          # í”„ë¡œì íŠ¸ ì„¤ì •
```

### í•µì‹¬ ê²Œì„ ì‹œìŠ¤í…œ
```
ğŸ® Move Slayers RPG ì•„í‚¤í…ì²˜:

ğŸ‘¤ í”Œë ˆì´ì–´ ì‹œìŠ¤í…œ
â”œâ”€â”€ ë ˆë²¨ ë° ê²½í—˜ì¹˜ ê´€ë¦¬
â”œâ”€â”€ ì²´ë ¥/ë§ˆë‚˜ ì‹œìŠ¤í…œ
â”œâ”€â”€ ì¸ë²¤í† ë¦¬ ê´€ë¦¬
â””â”€â”€ ì¥ë¹„ ì‹œìŠ¤í…œ

âš”ï¸ ì „íˆ¬ ì‹œìŠ¤í…œ
â”œâ”€â”€ í„´ì œ ì „íˆ¬ ë©”ì»¤ë‹ˆì¦˜
â”œâ”€â”€ ë°ë¯¸ì§€ ê³„ì‚°
â”œâ”€â”€ ì  AI ë° ë°˜ê²©
â””â”€â”€ ì „íˆ¬ ê²°ê³¼ ì²˜ë¦¬

ğŸ’ ì•„ì´í…œ ì‹œìŠ¤í…œ
â”œâ”€â”€ ë¬´ê¸°, ë°©íŒ¨, ê°‘ì˜·
â”œâ”€â”€ ë¬¼ì•½ ë° ì†Œëª¨í’ˆ
â”œâ”€â”€ ì¥ë¹„ íš¨ê³¼
â””â”€â”€ ì•„ì´í…œ ì œì‘

ğŸ— ì  ì‹œìŠ¤í…œ
â”œâ”€â”€ ë‹¤ì–‘í•œ ì  íƒ€ì…
â”œâ”€â”€ ëŠ¥ë ¥ì¹˜ ì‹œìŠ¤í…œ
â”œâ”€â”€ ë³´ìƒ ë©”ì»¤ë‹ˆì¦˜
â””â”€â”€ ë‚œì´ë„ ì¡°ì ˆ
```

## ğŸ‘¤ ëª¨ë“ˆ 1: í”Œë ˆì´ì–´ ì‹œìŠ¤í…œ (hero.move)

### ëª¨ë“ˆ ì„ ì–¸ ë° Import
```move
module move_slayers::hero {
    use std::signer;
    use std::vector;
    use std::string;
    use std::option;
    use move_slayers::enemies;
```

**í•µì‹¬ ê°œë…:**
- `module move_slayers::hero`: move_slayers íŒ¨í‚¤ì§€ì˜ hero ëª¨ë“ˆ ì„ ì–¸
- `use std::signer`: ê³„ì • ì¸ì¦ì„ ìœ„í•œ signer íƒ€ì… ì‚¬ìš©
- `use std::vector`: ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œì„ ìœ„í•œ ë™ì  ë°°ì—´
- `use std::string`: ì•„ì´í…œ ì´ë¦„ ë“± ë¬¸ìì—´ ì²˜ë¦¬
- `use std::option`: ì¥ë¹„ ìŠ¬ë¡¯ì˜ ì„ íƒì  ê°’ ì²˜ë¦¬

### ìƒìˆ˜ ë° íƒ€ì… ì •ì˜
```move
    const TYPE_SWORD: u8 = 0;
    const TYPE_SHIELD: u8 = 1;
    const TYPE_ARMOR: u8 = 2;
    const TYPE_POTION: u8 = 3;
```

**ì„¤ê³„ ì›ì¹™:**
- ë§¤ì§ ë„˜ë²„ ëŒ€ì‹  ìƒìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì½”ë“œ ê°€ë…ì„± í–¥ìƒ
- `u8` íƒ€ì…ìœ¼ë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± í™•ë³´
- í™•ì¥ ê°€ëŠ¥í•œ ì•„ì´í…œ íƒ€ì… ì‹œìŠ¤í…œ

### ì•„ì´í…œ êµ¬ì¡°ì²´
```move
    struct Item has copy, drop, store {
        id: u64,
        name: string::String,
        item_type: u8,
        power: u64,
    }
```

**Move ëŠ¥ë ¥ ì‹œìŠ¤í…œ:**
- `copy`: ì•„ì´í…œ ë³µì œ ê°€ëŠ¥ (í…ŒìŠ¤íŠ¸ ë° ê±°ë˜ìš©)
- `drop`: ì•„ì´í…œ ì†Œë©¸ ê°€ëŠ¥ (ì†Œëª¨í’ˆ ì‚¬ìš© ì‹œ)
- `store`: ê¸€ë¡œë²Œ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ ê°€ëŠ¥ (ì¸ë²¤í† ë¦¬)

**í•„ë“œ ì„¤ëª…:**
- `id`: ê³ ìœ  ì‹ë³„ì (u64ë¡œ ì¶©ë¶„í•œ ë²”ìœ„ ì œê³µ)
- `name`: ì‚¬ìš©ì ì¹œí™”ì  ì•„ì´í…œ ì´ë¦„
- `item_type`: ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ (ìƒìˆ˜ ì°¸ì¡°)
- `power`: íš¨ê³¼ ê°•ë„ (ë¬´ê¸° ë°ë¯¸ì§€, ë¬¼ì•½ íšŒë³µëŸ‰ ë“±)

### í”Œë ˆì´ì–´ êµ¬ì¡°ì²´
```move
    struct Player has key {
        level: u8,
        exp: u64,
        health: u64,
        mana: u64,
        max_health: u64,
        max_mana: u64,
        inventory: vector<Item>,
        equipped_sword: option::Option<Item>,
        equipped_shield: option::Option<Item>,
        equipped_armor: option::Option<Item>,
    }
```

**ë¦¬ì†ŒìŠ¤ ì„¤ê³„:**
- `has key`: ê¸€ë¡œë²Œ ìŠ¤í† ë¦¬ì§€ì˜ ìµœìƒìœ„ ë¦¬ì†ŒìŠ¤ë¡œ ì €ì¥ ê°€ëŠ¥
- `level: u8`: 1-255 ë ˆë²¨ ì§€ì› (ëŒ€ë¶€ë¶„ ê²Œì„ì— ì¶©ë¶„)
- `exp: u64`: ëŒ€ìš©ëŸ‰ ê²½í—˜ì¹˜ ì²˜ë¦¬ ê°€ëŠ¥
- `inventory: vector<Item>`: ë™ì  í¬ê¸° ì¸ë²¤í† ë¦¬
- `equipped_*: option::Option<Item>`: ì„ íƒì  ì¥ë¹„ ìŠ¬ë¡¯

### í”Œë ˆì´ì–´ ì´ˆê¸°í™”
```move
    /// ê¸°ë³¸ ìŠ¤íƒ¯ê³¼ ë¹ˆ ì¸ë²¤í† ë¦¬ë¡œ ìƒˆ í”Œë ˆì´ì–´ ì´ˆê¸°í™”
    public fun init_player(account: &signer) {
        move_to(account, Player {
            level: 1,
            exp: 0,
            health: 100,
            mana: 50,
            max_health: 100,
            max_mana: 50,
            inventory: vector::empty<Item>(),
            equipped_sword: option::none<Item>(),
            equipped_shield: option::none<Item>(),
            equipped_armor: option::none<Item>(),
        });
    }
```

**ì´ˆê¸°í™” ì „ëµ:**
- `move_to(account, Player {...})`: í”Œë ˆì´ì–´ ë¦¬ì†ŒìŠ¤ë¥¼ ê³„ì • ì£¼ì†Œì— ì €ì¥
- ê· í˜•ì¡íŒ ì´ˆê¸° ìŠ¤íƒ¯ìœ¼ë¡œ ê²Œì„ ì‹œì‘
- ë¹ˆ ì»¨í…Œì´ë„ˆë“¤ì„ ì•ˆì „í•˜ê²Œ ì´ˆê¸°í™”

### ì¸ë²¤í† ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œ
```move
    /// í”Œë ˆì´ì–´ ì¸ë²¤í† ë¦¬ì— ì•„ì´í…œ ì¶”ê°€
    public fun add_item(account: &signer, item: Item) acquires Player {
        let player = borrow_global_mut<Player>(signer::address_of(account));
        vector::push_back(&mut player.inventory, item);
    }
```

**ë©”ëª¨ë¦¬ ê´€ë¦¬:**
- `acquires Player`: Move ì»´íŒŒì¼ëŸ¬ì—ê²Œ Player ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ì„ ì•Œë¦¼
- `borrow_global_mut`: í”Œë ˆì´ì–´ ë¦¬ì†ŒìŠ¤ì˜ ê°€ë³€ ì°¸ì¡° íšë“
- `signer::address_of(account)`: ì„œëª…ìë¥¼ ê³„ì • ì£¼ì†Œë¡œ ë³€í™˜

### ì•„ì´í…œ ìƒì„± í—¬í¼
```move
    /// í…ŒìŠ¤íŠ¸ ë° ê°œë°œìš© ì•„ì´í…œ ìƒì„± í•¨ìˆ˜
    public fun make_item(id: u64, name: string::String, item_type: u8, power: u64): Item {
        Item { id, name, item_type, power }
    }
    
    /// ì•„ì´í…œ íƒ€ì… ìƒìˆ˜ ì ‘ê·¼ì
    public fun type_sword(): u8 { TYPE_SWORD }
    public fun type_shield(): u8 { TYPE_SHIELD }
    public fun type_armor(): u8 { TYPE_ARMOR }
    public fun type_potion(): u8 { TYPE_POTION }
```

## âš”ï¸ ì¥ë¹„ ì‹œìŠ¤í…œ

### ê²€ ì¥ì°©
```move
    /// ì¸ë²¤í† ë¦¬ì—ì„œ ê²€ì„ ì¥ì°©
    public fun equip_sword(account: &signer, item_id: u64): bool acquires Player {
        let player = borrow_global_mut<Player>(signer::address_of(account));
        equip_specific(&mut player.inventory, item_id, TYPE_SWORD, &mut player.equipped_sword)
    }
```

### ë²”ìš© ì¥ë¹„ ë¡œì§
```move
    /// íŠ¹ì • íƒ€ì…ì˜ ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ì—ì„œ ì°¾ì•„ ì¥ì°©
    fun equip_specific(
        inventory: &mut vector<Item>, 
        item_id: u64, 
        required_type: u8,
        equip_slot: &mut option::Option<Item>
    ): bool {
        let i = 0;
        let len = vector::length(inventory);
        while (i < len) {
            let item_ref = vector::borrow(inventory, i);
            if (item_ref.id == item_id && item_ref.item_type == required_type) {
                let item = vector::remove(inventory, i);
                *equip_slot = option::some(item);
                return true;
            };
            i = i + 1;
        };
        false
    }
```

**ì•Œê³ ë¦¬ì¦˜ ë¶„ì„:**
- ì„ í˜• ê²€ìƒ‰ìœ¼ë¡œ O(n) ë³µì¡ë„
- `vector::remove`ë¡œ ì•„ì´í…œì„ ì¸ë²¤í† ë¦¬ì—ì„œ ì¥ë¹„ ìŠ¬ë¡¯ìœ¼ë¡œ ì´ë™
- íƒ€ì… ê²€ì¦ìœ¼ë¡œ ì˜ëª»ëœ ì¥ë¹„ ë°©ì§€
- ë¶ˆë¦° ë°˜í™˜ìœ¼ë¡œ ì„±ê³µ/ì‹¤íŒ¨ í‘œì‹œ

### ë°©íŒ¨ ë° ê°‘ì˜· ì¥ì°©
```move
    /// ì¸ë²¤í† ë¦¬ì—ì„œ ë°©íŒ¨ë¥¼ ì¥ì°©
    public fun equip_shield(account: &signer, item_id: u64): bool acquires Player {
        let player = borrow_global_mut<Player>(signer::address_of(account));
        equip_specific(&mut player.inventory, item_id, TYPE_SHIELD, &mut player.equipped_shield)
    }

    /// ì¸ë²¤í† ë¦¬ì—ì„œ ê°‘ì˜·ì„ ì¥ì°©
    public fun equip_armor(account: &signer, item_id: u64): bool acquires Player {
        let player = borrow_global_mut<Player>(signer::address_of(account));
        equip_specific(&mut player.inventory, item_id, TYPE_ARMOR, &mut player.equipped_armor)
    }
```

## ğŸ§ª ë¬¼ì•½ ì‹œìŠ¤í…œ

### ì²´ë ¥ íšŒë³µ ë¬¼ì•½
```move
    /// ë¬¼ì•½ì„ ì‚¬ìš©í•˜ì—¬ ì²´ë ¥ íšŒë³µ
    public fun use_potion(account: &signer, item_id: u64): bool acquires Player {
        let player = borrow_global_mut<Player>(signer::address_of(account));
        let i = 0;
        let len = vector::length(&player.inventory);
        while (i < len) {
            let item_ref = vector::borrow(&player.inventory, i);
            if (item_ref.id == item_id && item_ref.item_type == TYPE_POTION) {
                let potion = vector::remove(&mut player.inventory, i);
                player.health = min(player.health + potion.power, player.max_health);
                return true;
            };
            i = i + 1;
        };
        false
    }
```

**íšŒë³µ ë©”ì»¤ë‹ˆì¦˜:**
- `min(current + heal, max)`: ìµœëŒ€ ì²´ë ¥ ì´ˆê³¼ ë°©ì§€
- ë¬¼ì•½ ì†Œëª¨: ì¸ë²¤í† ë¦¬ì—ì„œ ì œê±°
- ì•ˆì „í•œ íƒ€ì… ê²€ì¦

## âš”ï¸ ì „íˆ¬ ì‹œìŠ¤í…œ

### ì  ê³µê²© ë©”ì»¤ë‹ˆì¦˜
```move
    /// í”Œë ˆì´ì–´ê°€ ì ì„ ê³µê²©. ì ì´ ìƒì¡´í•˜ë©´ ë°˜ê²©. ì ì´ ì£½ìœ¼ë©´ ê²½í—˜ì¹˜ íšë“.
    public fun attack_enemy(account: &signer, enemy: &mut enemies::Enemy): bool acquires Player {
        let player = borrow_global_mut<Player>(signer::address_of(account));

        // ë°ë¯¸ì§€ ê³„ì‚° (ì¥ì°©ëœ ë¬´ê¸° ê³ ë ¤)
        let damage = if (option::is_some(&player.equipped_sword)) {
            let sword_ref = option::borrow(&player.equipped_sword);
            sword_ref.power
        } else {
            5 // ê¸°ë³¸ ê³µê²©ë ¥
        };

        let killed = enemies::take_damage(enemy, damage);

        if (killed) {
            // ì  ì²˜ì¹˜ ì‹œ ê²½í—˜ì¹˜ íšë“
            slay_enemy(account, enemies::get_exp_reward(enemy));
            true
        } else {
            // ì  ìƒì¡´ ì‹œ ë°˜ê²©
            let enemy_attack = enemies::get_attack(enemy);
            if (player.health <= enemy_attack) {
                player.health = 0; // í”Œë ˆì´ì–´ ì‚¬ë§
            } else {
                player.health = player.health - enemy_attack;
            };
            false
        }
    }
```

**ì „íˆ¬ íë¦„:**
1. **ë°ë¯¸ì§€ ê³„ì‚°**: ì¥ì°© ë¬´ê¸° íŒŒì›Œ ë˜ëŠ” ê¸°ë³¸ ê³µê²©ë ¥
2. **ì  í”¼í•´ ì ìš©**: enemies ëª¨ë“ˆì˜ `take_damage` í˜¸ì¶œ
3. **ê²°ê³¼ ë¶„ê¸°**:
   - ì  ì²˜ì¹˜: ê²½í—˜ì¹˜ ë³´ìƒ
   - ì  ìƒì¡´: ë°˜ê²©ìœ¼ë¡œ í”Œë ˆì´ì–´ í”¼í•´

### ê²½í—˜ì¹˜ ë° ë ˆë²¨ì—… ì‹œìŠ¤í…œ
```move
    /// ì  ì²˜ì¹˜ ì‹œ ê²½í—˜ì¹˜ ë³´ìƒ ë° ë ˆë²¨ì—… ì²˜ë¦¬
    public fun slay_enemy(account: &signer, exp_reward: u64) acquires Player {
        let player = borrow_global_mut<Player>(signer::address_of(account));
        player.exp = player.exp + exp_reward;

        let required_exp = exp_required(player.level);
        while (player.exp >= required_exp) {
            player.exp = player.exp - required_exp;
            player.level = player.level + 1;
            player.max_health = player.max_health + 20;
            player.max_mana = player.max_mana + 10;
            player.health = player.max_health; // ë ˆë²¨ì—… ì‹œ ì™„ì „ íšŒë³µ
            player.mana = player.max_mana;
            required_exp = exp_required(player.level);
        };
    }
```

**ë ˆë²¨ì—… ë©”ì»¤ë‹ˆì¦˜:**
- ì—°ì† ë ˆë²¨ì—… ì§€ì› (`while` ë£¨í”„)
- ë ˆë²¨ë‹¹ ì²´ë ¥ +20, ë§ˆë‚˜ +10 ì„±ì¥
- ë ˆë²¨ì—… ì‹œ ì™„ì „ íšŒë³µ
- ì‚¬ìš©ëœ ê²½í—˜ì¹˜ ì°¨ê°

### ì§€ìˆ˜ì  ê²½í—˜ì¹˜ ì‹œìŠ¤í…œ
```move
    /// ë ˆë²¨ì—…ì— í•„ìš”í•œ ê²½í—˜ì¹˜ (ì§€ìˆ˜ì  ì¦ê°€)
    fun exp_required(level: u8): u64 {
        100 * (1u64 << (level - 1))
    }
```

**ê²½í—˜ì¹˜ ê³¡ì„ :**
- ë ˆë²¨ 1â†’2: 100 EXP (2^0 * 100)
- ë ˆë²¨ 2â†’3: 200 EXP (2^1 * 100)  
- ë ˆë²¨ 3â†’4: 400 EXP (2^2 * 100)
- ì§€ìˆ˜ì  ì¦ê°€ë¡œ í›„ë°˜ë¶€ ë„ì „ ì œê³µ

## ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜

### ìˆ˜í•™ í—¬í¼
```move
    /// ë‘ ê°’ ì¤‘ ìµœì†Ÿê°’ ë°˜í™˜
    fun min(a: u64, b: u64): u64 {
        if (a < b) a else b
    }

    /// ë‘ ê°’ ì¤‘ ìµœëŒ“ê°’ ë°˜í™˜  
    fun max(a: u64, b: u64): u64 {
        if (a > b) a else b
    }
```

### ê³µê°œ ê²Œí„° í•¨ìˆ˜
```move
    /// í”Œë ˆì´ì–´ ì •ë³´ ì¡°íšŒìš© ê³µê°œ í•¨ìˆ˜ë“¤
    public fun get_level(player: &Player): u8 { player.level }
    public fun get_exp(player: &Player): u64 { player.exp }
    public fun get_health(player: &Player): u64 { player.health }
    public fun get_mana(player: &Player): u64 { player.mana }
    public fun get_max_health(player: &Player): u64 { player.max_health }
    public fun get_max_mana(player: &Player): u64 { player.max_mana }
    
    /// ì¸ë²¤í† ë¦¬ ì •ë³´ ì¡°íšŒ
    public fun get_inventory_length(player: &Player): u64 {
        vector::length(&player.inventory)
    }
    
    /// ì¥ì°© ì¥ë¹„ í™•ì¸
    public fun has_equipped_sword(player: &Player): bool {
        option::is_some(&player.equipped_sword)
    }
    
    public fun has_equipped_shield(player: &Player): bool {
        option::is_some(&player.equipped_shield)
    }
    
    public fun has_equipped_armor(player: &Player): bool {
        option::is_some(&player.equipped_armor)
    }
```

## ğŸ— ëª¨ë“ˆ 2: ì  ì‹œìŠ¤í…œ (enemies.move)

### ëª¨ë“ˆ êµ¬ì¡°
```move
module move_slayers::enemies {
    use std::string;
```

### ì  êµ¬ì¡°ì²´
```move
    /// ì  ì •ì˜
    struct Enemy has copy, drop, store {
        name: string::String,
        health: u64,
        attack: u64,
        exp_reward: u64,
    }
```

**ì  ëŠ¥ë ¥:**
- `copy, drop, store`: ë³µì œ, ì†Œë©¸, ì €ì¥ ê°€ëŠ¥
- ì´ë¦„, ì²´ë ¥, ê³µê²©ë ¥, ê²½í—˜ì¹˜ ë³´ìƒì˜ ê¸°ë³¸ ì†ì„±

### ì  ìƒì„± íŒ©í† ë¦¬
```move
    /// ì´ˆë°˜ ê²Œì„ìš© ì•½í•œ ë©§ë¼ì§€ ìƒì„±
    public fun spawn_boar(): Enemy {
        Enemy {
            name: string::utf8(b"Boar"),
            health: 30,
            attack: 5,
            exp_reward: 50,
        }
    }
    
    /// ì¤‘ê¸‰ ì : ëŠ‘ëŒ€
    public fun spawn_wolf(): Enemy {
        Enemy {
            name: string::utf8(b"Wolf"),
            health: 60,
            attack: 12,
            exp_reward: 120,
        }
    }
    
    /// ê³ ê¸‰ ì : ì˜¤í¬
    public fun spawn_orc(): Enemy {
        Enemy {
            name: string::utf8(b"Orc"),
            health: 100,
            attack: 20,
            exp_reward: 200,
        }
    }
```

### ì „íˆ¬ ìƒí˜¸ì‘ìš©
```move
    /// ì ì—ê²Œ í”¼í•´ë¥¼ ì…í˜. ì ì´ ì£½ìœ¼ë©´ true ë°˜í™˜.
    public fun take_damage(enemy: &mut Enemy, amount: u64): bool {
        if (enemy.health <= amount) {
            enemy.health = 0;
            true
        } else {
            enemy.health = enemy.health - amount;
            false
        }
    }
```

### ì  ì •ë³´ ì ‘ê·¼ì
```move
    /// ì  ì •ë³´ ì¡°íšŒìš© ê³µê°œ í•¨ìˆ˜ë“¤
    public fun get_health(enemy: &Enemy): u64 { enemy.health }
    public fun get_attack(enemy: &Enemy): u64 { enemy.attack }
    public fun get_exp_reward(enemy: &Enemy): u64 { enemy.exp_reward }
    public fun get_name(enemy: &Enemy): &string::String { &enemy.name }
    
    /// ì ì´ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸
    public fun is_alive(enemy: &Enemy): bool {
        enemy.health > 0
    }
```

### ì»¤ìŠ¤í…€ ì  ìƒì„±
```move
    /// í…ŒìŠ¤íŠ¸ ë° í™•ì¥ìš© ì  íŒ©í† ë¦¬
    public fun make_enemy(
        name: string::String, 
        health: u64, 
        attack: u64, 
        exp_reward: u64
    ): Enemy {
        Enemy { name, health, attack, exp_reward }
    }
```

## ğŸ§ª ëª¨ë“ˆ 3: ì¢…í•© í…ŒìŠ¤íŠ¸ (hero_tests.move)

### í…ŒìŠ¤íŠ¸ ëª¨ë“ˆ ì„¤ì •
```move
#[test_only]
module move_slayers::hero_tests {
    use std::signer;
    use std::string;
    use std::vector;
    use std::option;
    use std::account;
    use move_slayers::hero;
    use move_slayers::enemies;
```

### í…ŒìŠ¤íŠ¸ í—¬í¼
```move
    // í…ŒìŠ¤íŠ¸ ê³„ì • ì£¼ì†Œ
    const PLAYER_ADDR: address = @0x1;

    // í…ŒìŠ¤íŠ¸ ì„œëª…ì ìƒì„± í—¬í¼
    fun create_test_signer(): signer {
        account::create_account_for_test(PLAYER_ADDR)
    }
    
    // í…ŒìŠ¤íŠ¸ìš© ê¸°ë³¸ ì•„ì´í…œë“¤
    fun create_test_sword(): hero::Item {
        hero::make_item(1, string::utf8(b"Iron Sword"), hero::type_sword(), 15)
    }
    
    fun create_test_shield(): hero::Item {
        hero::make_item(2, string::utf8(b"Wooden Shield"), hero::type_shield(), 8)
    }
    
    fun create_test_potion(): hero::Item {
        hero::make_item(3, string::utf8(b"Health Potion"), hero::type_potion(), 25)
    }
```

### í”Œë ˆì´ì–´ ìƒì„± í…ŒìŠ¤íŠ¸
```move
    #[test]
    fun test_hero_creation() {
        let player = create_test_signer();
        hero::init_player(&player);
        
        // í”Œë ˆì´ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ ì•„ì´í…œ ì¶”ê°€ë¡œ í™•ì¸
        let test_item = create_test_sword();
        hero::add_item(&player, test_item);
    }
```

### ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
```move
    #[test]
    fun test_inventory_management() {
        let player = create_test_signer();
        hero::init_player(&player);
        
        // ì—¬ëŸ¬ ì•„ì´í…œ ì¶”ê°€
        hero::add_item(&player, create_test_sword());
        hero::add_item(&player, create_test_shield());
        hero::add_item(&player, create_test_potion());
        
        // ì¸ë²¤í† ë¦¬ ê¸¸ì´ í™•ì¸ ë¡œì§ì€ ì‹¤ì œ êµ¬í˜„ì—ì„œ ì¶”ê°€ í•„ìš”
    }
```

### ì¥ë¹„ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
```move
    #[test]
    fun test_equipment_system() {
        let player = create_test_signer();
        hero::init_player(&player);
        
        // ì•„ì´í…œ ì¶”ê°€ í›„ ì¥ì°©
        let sword = create_test_sword();
        hero::add_item(&player, sword);
        
        // ê²€ ì¥ì°© í…ŒìŠ¤íŠ¸
        let equipped = hero::equip_sword(&player, 1);
        assert!(equipped, 0); // ì¥ì°© ì„±ê³µ í™•ì¸
        
        // ë°©íŒ¨ë„ ë™ì¼í•˜ê²Œ í…ŒìŠ¤íŠ¸
        let shield = create_test_shield();
        hero::add_item(&player, shield);
        let shield_equipped = hero::equip_shield(&player, 2);
        assert!(shield_equipped, 1);
    }
```

### ë¬¼ì•½ ì‚¬ìš© í…ŒìŠ¤íŠ¸
```move
    #[test]
    fun test_potion_usage() {
        let player = create_test_signer();
        hero::init_player(&player);
        
        // ì²´ë ¥ì„ ì„ì˜ë¡œ ê°ì†Œì‹œí‚¬ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, 
        // ì „íˆ¬ í›„ ë¬¼ì•½ ì‚¬ìš© í…ŒìŠ¤íŠ¸ë¡œ êµ¬í˜„
        let potion = create_test_potion();
        hero::add_item(&player, potion);
        
        let used = hero::use_potion(&player, 3);
        assert!(used, 0); // ë¬¼ì•½ ì‚¬ìš© ì„±ê³µ í™•ì¸
    }
```

### ì „íˆ¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
```move
    #[test]
    fun test_combat_system() {
        let player = create_test_signer();
        hero::init_player(&player);
        
        // ê²€ ì¥ì°©
        let sword = create_test_sword();
        hero::add_item(&player, sword);
        hero::equip_sword(&player, 1);
        
        // ì  ìƒì„±
        let mut boar = enemies::spawn_boar();
        
        // ì „íˆ¬ í…ŒìŠ¤íŠ¸
        let result = hero::attack_enemy(&player, &mut boar);
        
        // ë©§ë¼ì§€ê°€ ì£½ì—ˆê±°ë‚˜ ë°˜ê²©í–ˆì„ ê²ƒ
        if (result) {
            // ì  ì²˜ì¹˜ - ê²½í—˜ì¹˜ íšë“ í™•ì¸ ê°€ëŠ¥
            assert!(!enemies::is_alive(&boar), 0);
        } else {
            // ì  ìƒì¡´ - í”Œë ˆì´ì–´ê°€ í”¼í•´ë¥¼ ë°›ì•˜ì„ ê²ƒ
            assert!(enemies::is_alive(&boar), 1);
        }
    }
```

### ë ˆë²¨ë§ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
```move
    #[test]
    fun test_leveling_system() {
        let player = create_test_signer();
        hero::init_player(&player);
        
        // ì¶©ë¶„í•œ ê²½í—˜ì¹˜ë¡œ ì§ì ‘ ë ˆë²¨ì—… í…ŒìŠ¤íŠ¸
        hero::slay_enemy(&player, 100); // ë ˆë²¨ 1->2ì— í•„ìš”í•œ ê²½í—˜ì¹˜
        
        // ì¶”ê°€ ê²½í—˜ì¹˜ë¡œ ì—¬ëŸ¬ ë ˆë²¨ í…ŒìŠ¤íŠ¸
        hero::slay_enemy(&player, 300); // ë ˆë²¨ 2->3 (200) + ì¶”ê°€ 100
    }
```

### í†µí•© ê²Œì„í”Œë ˆì´ í…ŒìŠ¤íŠ¸
```move
    #[test]
    fun test_complete_gameplay_flow() {
        let player = create_test_signer();
        hero::init_player(&player);
        
        // 1. ì¥ë¹„ íšë“ ë° ì¥ì°©
        hero::add_item(&player, create_test_sword());
        hero::add_item(&player, create_test_shield());
        hero::add_item(&player, create_test_potion());
        
        hero::equip_sword(&player, 1);
        hero::equip_shield(&player, 2);
        
        // 2. ì—¬ëŸ¬ ì ê³¼ ì „íˆ¬
        let mut boar1 = enemies::spawn_boar();
        let mut boar2 = enemies::spawn_boar();
        let mut wolf = enemies::spawn_wolf();
        
        // ë©§ë¼ì§€ë“¤ê³¼ ì „íˆ¬
        hero::attack_enemy(&player, &mut boar1);
        hero::attack_enemy(&player, &mut boar2);
        
        // í•„ìš”ì‹œ ë¬¼ì•½ ì‚¬ìš©
        hero::use_potion(&player, 3);
        
        // ëŠ‘ëŒ€ì™€ ì „íˆ¬ (ë” ê°•í•œ ì )
        hero::attack_enemy(&player, &mut wolf);
        
        // ê²Œì„ ìƒíƒœê°€ ì¼ê´€ì„± ìˆê²Œ ìœ ì§€ë˜ëŠ”ì§€ í™•ì¸
    }
```

## ğŸš€ TypeScript SDK í†µí•©

### Move Slayers ê²Œì„ í´ë¼ì´ì–¸íŠ¸
```typescript
import {
  MovementClient,
  MovementAccount,
  Network
} from "@movementnetwork/ts-sdk";

interface PlayerStats {
  level: number;
  exp: number;
  health: number;
  mana: number;
  maxHealth: number;
  maxMana: number;
}

interface GameItem {
  id: number;
  name: string;
  itemType: number;
  power: number;
}

interface Enemy {
  name: string;
  health: number;
  attack: number;
  expReward: number;
}

class MoveSlayersClient {
  private client: MovementClient;
  private moduleAddress: string;
  
  constructor(client: MovementClient, moduleAddress: string) {
    this.client = client;
    this.moduleAddress = moduleAddress;
  }
  
  // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
  async initializePlayer(account: MovementAccount): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::hero::init_player`,
      type_arguments: [],
      arguments: []
    };
    
    const txn = await this.client.generateTransaction(account.address(), payload);
    const signedTxn = await this.client.signTransaction(account, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // í”Œë ˆì´ì–´ ì •ë³´ ì¡°íšŒ
  async getPlayerStats(playerAddress: string): Promise<PlayerStats | null> {
    try {
      const playerResource = await this.client.getAccountResource(
        playerAddress,
        `${this.moduleAddress}::hero::Player`
      );
      
      if (!playerResource) return null;
      
      const data = playerResource.data as any;
      return {
        level: parseInt(data.level),
        exp: parseInt(data.exp),
        health: parseInt(data.health),
        mana: parseInt(data.mana),
        maxHealth: parseInt(data.max_health),
        maxMana: parseInt(data.max_mana)
      };
    } catch (error) {
      console.error("Failed to get player stats:", error);
      return null;
    }
  }
  
  // ì•„ì´í…œ ì¶”ê°€
  async addItem(
    account: MovementAccount,
    id: number,
    name: string,
    itemType: number,
    power: number
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::hero::add_item`,
      type_arguments: [],
      arguments: [
        {
          id: id.toString(),
          name,
          item_type: itemType.toString(),
          power: power.toString()
        }
      ]
    };
    
    const txn = await this.client.generateTransaction(account.address(), payload);
    const signedTxn = await this.client.signTransaction(account, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ì¥ë¹„ ì°©ìš©
  async equipSword(account: MovementAccount, itemId: number): Promise<{
    success: boolean;
    transactionHash: string;
  }> {
    try {
      const payload = {
        type: "entry_function_payload",
        function: `${this.moduleAddress}::hero::equip_sword`,
        type_arguments: [],
        arguments: [itemId.toString()]
      };
      
      const txn = await this.client.generateTransaction(account.address(), payload);
      const signedTxn = await this.client.signTransaction(account, txn);
      const response = await this.client.submitTransaction(signedTxn);
      
      await this.client.waitForTransaction(response.hash);
      
      return {
        success: true,
        transactionHash: response.hash
      };
    } catch (error) {
      return {
        success: false,
        transactionHash: ""
      };
    }
  }
  
  // ë¬¼ì•½ ì‚¬ìš©
  async usePotion(account: MovementAccount, itemId: number): Promise<{
    success: boolean;
    transactionHash: string;
  }> {
    try {
      const payload = {
        type: "entry_function_payload",
        function: `${this.moduleAddress}::hero::use_potion`,
        type_arguments: [],
        arguments: [itemId.toString()]
      };
      
      const txn = await this.client.generateTransaction(account.address(), payload);
      const signedTxn = await this.client.signTransaction(account, txn);
      const response = await this.client.submitTransaction(signedTxn);
      
      await this.client.waitForTransaction(response.hash);
      
      return {
        success: true,
        transactionHash: response.hash
      };
    } catch (error) {
      return {
        success: false,
        transactionHash: ""
      };
    }
  }
  
  // ì  ìƒì„±
  async spawnEnemy(enemyType: 'boar' | 'wolf' | 'orc'): Promise<Enemy> {
    // í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œì—ì„œ ì  ì •ë³´ ë°˜í™˜ (ì‹¤ì œ ê²Œì„ì—ì„œëŠ” ì„œë²„ì—ì„œ ê´€ë¦¬)
    const enemies = {
      boar: { name: "Boar", health: 30, attack: 5, expReward: 50 },
      wolf: { name: "Wolf", health: 60, attack: 12, expReward: 120 },
      orc: { name: "Orc", health: 100, attack: 20, expReward: 200 }
    };
    
    return enemies[enemyType];
  }
  
  // ì „íˆ¬ ì‹¤í–‰
  async attackEnemy(
    account: MovementAccount,
    enemy: Enemy
  ): Promise<{
    playerWon: boolean;
    enemyDefeated: boolean;
    expGained: number;
    transactionHash: string;
  }> {
    // ì‹¤ì œë¡œëŠ” Move ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì „íˆ¬ ë¡œì§ ì‹¤í–‰
    // ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::hero::attack_enemy`,
      type_arguments: [],
      arguments: [
        // Enemy êµ¬ì¡°ì²´ë¥¼ ì¸ìë¡œ ì „ë‹¬
        enemy
      ]
    };
    
    try {
      const txn = await this.client.generateTransaction(account.address(), payload);
      const signedTxn = await this.client.signTransaction(account, txn);
      const response = await this.client.submitTransaction(signedTxn);
      
      await this.client.waitForTransaction(response.hash);
      
      // ì‹¤ì œë¡œëŠ” íŠ¸ëœì­ì…˜ ê²°ê³¼ì—ì„œ ì „íˆ¬ ê²°ê³¼ íŒŒì‹±
      return {
        playerWon: true,
        enemyDefeated: true,
        expGained: enemy.expReward,
        transactionHash: response.hash
      };
    } catch (error) {
      throw new Error(`Combat failed: ${error}`);
    }
  }
  
  // ê²Œì„ ìƒíƒœ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
  async monitorGameEvents(
    playerAddress: string,
    callback: (event: any) => void
  ): Promise<void> {
    const pollInterval = 2000; // 2ì´ˆë§ˆë‹¤
    
    const poll = async () => {
      try {
        const currentStats = await this.getPlayerStats(playerAddress);
        callback({
          type: 'player_stats_update',
          stats: currentStats,
          timestamp: Date.now()
        });
      } catch (error) {
        console.error("Failed to poll game state:", error);
      }
      
      setTimeout(poll, pollInterval);
    };
    
    poll();
  }
}

// React ê²Œì„ ì»´í¬ë„ŒíŠ¸ ì˜ˆì‹œ
interface GameComponentProps {
  gameClient: MoveSlayersClient;
  playerAccount: MovementAccount;
}

function MoveSlayersGame({ gameClient, playerAccount }: GameComponentProps) {
  const [playerStats, setPlayerStats] = useState<PlayerStats | null>(null);
  const [currentEnemy, setCurrentEnemy] = useState<Enemy | null>(null);
  const [gameLog, setGameLog] = useState<string[]>([]);
  
  useEffect(() => {
    // ê²Œì„ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì‹œì‘
    gameClient.monitorGameEvents(playerAccount.address(), (event) => {
      if (event.type === 'player_stats_update') {
        setPlayerStats(event.stats);
      }
    });
    
    // ì´ˆê¸° í”Œë ˆì´ì–´ ì •ë³´ ë¡œë“œ
    loadPlayerStats();
  }, []);
  
  const loadPlayerStats = async () => {
    const stats = await gameClient.getPlayerStats(playerAccount.address());
    setPlayerStats(stats);
  };
  
  const spawnRandomEnemy = async () => {
    const enemyTypes: ('boar' | 'wolf' | 'orc')[] = ['boar', 'wolf', 'orc'];
    const randomType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
    const enemy = await gameClient.spawnEnemy(randomType);
    setCurrentEnemy(enemy);
    
    addToGameLog(`A wild ${enemy.name} appears!`);
  };
  
  const attackCurrentEnemy = async () => {
    if (!currentEnemy) return;
    
    try {
      const result = await gameClient.attackEnemy(playerAccount, currentEnemy);
      
      if (result.enemyDefeated) {
        addToGameLog(`You defeated the ${currentEnemy.name}! Gained ${result.expGained} EXP.`);
        setCurrentEnemy(null);
      } else {
        addToGameLog(`You attacked the ${currentEnemy.name}, but it survived and counterattacked!`);
      }
      
      // í”Œë ˆì´ì–´ ì •ë³´ ìƒˆë¡œê³ ì¹¨
      await loadPlayerStats();
    } catch (error) {
      addToGameLog(`Combat failed: ${error}`);
    }
  };
  
  const addToGameLog = (message: string) => {
    setGameLog(prev => [...prev.slice(-9), `${new Date().toLocaleTimeString()}: ${message}`]);
  };
  
  return (
    <div className="move-slayers-game p-6 max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">ğŸ® Move Slayers RPG</h1>
      
      {/* í”Œë ˆì´ì–´ ì •ë³´ */}
      {playerStats && (
        <div className="player-stats bg-blue-100 p-4 rounded-lg mb-6">
          <h2 className="text-xl font-bold mb-2">ğŸ‘¤ Player Stats</h2>
          <div className="grid grid-cols-3 gap-4">
            <div>Level: {playerStats.level}</div>
            <div>EXP: {playerStats.exp}</div>
            <div>HP: {playerStats.health}/{playerStats.maxHealth}</div>
            <div>MP: {playerStats.mana}/{playerStats.maxMana}</div>
          </div>
        </div>
      )}
      
      {/* ì „íˆ¬ ì˜ì—­ */}
      <div className="combat-area bg-red-100 p-4 rounded-lg mb-6">
        <h2 className="text-xl font-bold mb-2">âš”ï¸ Combat</h2>
        {currentEnemy ? (
          <div>
            <p className="mb-2">ğŸ— {currentEnemy.name} (HP: {currentEnemy.health}, ATK: {currentEnemy.attack})</p>
            <button 
              onClick={attackCurrentEnemy}
              className="bg-red-500 text-white px-4 py-2 rounded mr-2"
            >
              Attack!
            </button>
          </div>
        ) : (
          <button 
            onClick={spawnRandomEnemy}
            className="bg-green-500 text-white px-4 py-2 rounded"
          >
            Find Enemy
          </button>
        )}
      </div>
      
      {/* ê²Œì„ ë¡œê·¸ */}
      <div className="game-log bg-gray-100 p-4 rounded-lg">
        <h2 className="text-xl font-bold mb-2">ğŸ“œ Game Log</h2>
        <div className="max-h-40 overflow-y-auto">
          {gameLog.map((log, index) => (
            <div key={index} className="text-sm">{log}</div>
          ))}
        </div>
      </div>
    </div>
  );
}

// ì‚¬ìš© ì˜ˆì‹œ
async function startMoveSlayersGame() {
  const client = new MovementClient({ network: Network.TESTNET });
  const gameClient = new MoveSlayersClient(client, "0x1::move_slayers");
  
  const playerAccount = new MovementAccount();
  
  // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
  await gameClient.initializePlayer(playerAccount);
  
  // ê¸°ë³¸ ì¥ë¹„ ì§€ê¸‰
  await gameClient.addItem(playerAccount, 1, "Starter Sword", 0, 10);
  await gameClient.addItem(playerAccount, 2, "Health Potion", 3, 25);
  
  // ê²Œì„ ì‹œì‘
  console.log("Move Slayers RPG started!");
}

export { MoveSlayersClient, type PlayerStats, type GameItem, type Enemy };
```

## ğŸ¯ í•µì‹¬ í•™ìŠµ í¬ì¸íŠ¸

### 1. ë¦¬ì†ŒìŠ¤ ì•ˆì „ì„±
```move
// âœ… Moveì˜ ë¦¬ì†ŒìŠ¤ ì‹œìŠ¤í…œ
struct Player has key {
    // í”Œë ˆì´ì–´ëŠ” ë³µì œë˜ê±°ë‚˜ ì‹¤ìˆ˜ë¡œ ì†Œì‹¤ë  ìˆ˜ ì—†ìŒ
}

// âœ… ì•ˆì „í•œ ë¦¬ì†ŒìŠ¤ ì´ë™
move_to(account, Player { ... }); // ê³„ì •ìœ¼ë¡œ ë¦¬ì†ŒìŠ¤ ì´ë™
let player = borrow_global_mut<Player>(addr); // ì•ˆì „í•œ ì°¸ì¡°
```

### 2. ëª¨ë“ˆí™” ì„¤ê³„
```move
// âœ… ê´€ì‹¬ì‚¬ ë¶„ë¦¬
module move_slayers::hero {    // í”Œë ˆì´ì–´ ë¡œì§
module move_slayers::enemies { // ì  ì‹œìŠ¤í…œ
```

### 3. ì˜¨ì²´ì¸ ìƒíƒœ ê´€ë¦¬
```move
// âœ… ê¸€ë¡œë²Œ ìŠ¤í† ë¦¬ì§€ í™œìš©
public fun init_player(account: &signer) {
    move_to(account, Player { ... }); // ê³„ì •ì— í”Œë ˆì´ì–´ ë°ì´í„° ì €ì¥
}
```

### 4. ì—ëŸ¬ ì²˜ë¦¬
```move
// âœ… ë¶ˆë¦° ë°˜í™˜ìœ¼ë¡œ ì„±ê³µ/ì‹¤íŒ¨ í‘œì‹œ
public fun equip_sword(account: &signer, item_id: u64): bool
```

### 5. í…ŒìŠ¤íŠ¸ ì£¼ë„ ê°œë°œ
```move
#[test]
fun test_complete_gameplay_flow() {
    // ì „ì²´ ê²Œì„í”Œë ˆì´ íë¦„ í…ŒìŠ¤íŠ¸
}
```

## ğŸš€ í™•ì¥ ì•„ì´ë””ì–´

### ì¦‰ì‹œ êµ¬í˜„ ê°€ëŠ¥í•œ ê¸°ëŠ¥ë“¤:

#### ğŸª **ì•„ì´í…œ ìƒì  ì‹œìŠ¤í…œ**
```move
module move_slayers::shop {
    struct Shop has key {
        items: vector<ShopItem>,
        gold_prices: vector<u64>,
    }
    
    public fun buy_item(account: &signer, shop_item_id: u64) {
        // ê³¨ë“œ ì°¨ê° í›„ ì•„ì´í…œ ì§€ê¸‰
    }
}
```

#### ğŸ° **ë˜ì „ ì‹œìŠ¤í…œ**
```move
module move_slayers::dungeons {
    struct Dungeon has key {
        name: string::String,
        floors: vector<Floor>,
        entry_cost: u64,
    }
    
    public fun enter_dungeon(account: &signer, dungeon_id: u64) {
        // ë˜ì „ ì…ì¥ ë° ì§„í–‰ ë¡œì§
    }
}
```

#### ğŸ¯ **í€˜ìŠ¤íŠ¸ ì‹œìŠ¤í…œ**
```move
module move_slayers::quests {
    struct Quest has copy, drop, store {
        id: u64,
        title: string::String,
        description: string::String,
        requirements: QuestRequirements,
        rewards: QuestRewards,
        completed: bool,
    }
}
```

#### ğŸ‘¥ **ê¸¸ë“œ ì‹œìŠ¤í…œ**
```move
module move_slayers::guilds {
    struct Guild has key {
        name: string::String,
        members: vector<address>,
        guild_level: u64,
        treasury: u64,
    }
}
```

### ê³ ê¸‰ í™•ì¥ ê¸°ëŠ¥ë“¤:

#### ğŸ’ **NFT í†µí•©**
- ë…íŠ¹í•œ ì•„ì´í…œì„ NFTë¡œ ë°œí–‰
- í”Œë ˆì´ì–´ ìºë¦­í„°ë¥¼ NFTë¡œ ê±°ë˜ ê°€ëŠ¥
- ê¸¸ë“œ íœ˜ì¥ ë° ì—…ì  NFT

#### ğŸŒ **ë©€í‹°í”Œë ˆì´ì–´ ê¸°ëŠ¥**
- ì‹¤ì‹œê°„ PvP ì „íˆ¬
- í˜‘ë™ ë ˆì´ë“œ ë˜ì „
- ë¦¬ë”ë³´ë“œ ì‹œìŠ¤í…œ

#### ğŸ’° **ê²Œì„ ê²½ì œ**
- ê²Œì„ ë‚´ í™”í ì‹œìŠ¤í…œ
- í”Œë ˆì´ì–´ ê°„ ê±°ë˜
- ê²½ë§¤ì¥ ì‹œìŠ¤í…œ

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### Move ì–¸ì–´ ì‹¬í™”
- [Move Book](https://move-language.github.io/move/)
- [Movement ê°œë°œì ë¬¸ì„œ](https://docs.movementnetwork.xyz/)
- [Move íŒ¨í„´ ë° ê´€ìš©êµ¬](https://github.com/move-language/move/tree/main/language/documentation/examples)

### ê²Œì„ ê°œë°œ ë¦¬ì†ŒìŠ¤
- [ì˜¨ì²´ì¸ ê²Œì„ ì„¤ê³„ íŒ¨í„´](https://ethereum.org/en/developers/docs/gaming/)
- [ë¸”ë¡ì²´ì¸ ê²Œì„ ê²½ì œí•™](https://medium.com/blockchain-game-alliance)
- [Web3 ê²Œì„ ê°œë°œ ê°€ì´ë“œ](https://docs.alchemy.com/docs/how-to-build-a-web3-game)

### Movement ìƒíƒœê³„
- [Movement Discord](https://discord.gg/movementnetwork)
- [Movement GitHub](https://github.com/movementlabsxyz)
- [ê°œë°œì í¬ëŸ¼](https://forum.movementnetwork.xyz)

---

**ì¶•í•˜í•©ë‹ˆë‹¤!** ğŸ‰ 

ì´ì œ Move ì–¸ì–´ë¡œ ì™„ì „í•œ ì˜¨ì²´ì¸ RPGë¥¼ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Move SlayersëŠ” ì‹œì‘ì ì¼ ë¿ì…ë‹ˆë‹¤. ì—¬ëŸ¬ë¶„ì˜ ì°½ì˜ë ¥ìœ¼ë¡œ ë”ìš± í¥ë¯¸ì§„ì§„í•œ ë¸”ë¡ì²´ì¸ ê²Œì„ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”!

*Movement Networkì—ì„œ ì°¨ì„¸ëŒ€ ê²Œì„ì˜ ë¯¸ë˜ë¥¼ ê°œì²™í•˜ì„¸ìš”!* ğŸ®âœ¨