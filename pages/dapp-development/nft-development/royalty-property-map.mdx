# ğŸ¨ NFT ë¡œì—´í‹° ë° Property Map

Movement Networkì—ì„œ NFT ë¡œì—´í‹° ì‹œìŠ¤í…œê³¼ Property Mapì„ êµ¬í˜„í•˜ëŠ” ì™„ì „í•œ ê°€ì´ë“œì…ë‹ˆë‹¤. ì°½ì‘ìì˜ ì§€ì†ì ì¸ ìˆ˜ìµì„ ë³´ì¥í•˜ê³  NFT ë©”íƒ€ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë°°ì›Œë´…ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- NFT ë¡œì—´í‹° ì‹œìŠ¤í…œì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Property Mapì„ í™œìš©í•œ ë©”íƒ€ë°ì´í„° ê´€ë¦¬ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë™ì  NFT ì†ì„± ì—…ë°ì´íŠ¸ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ìˆ˜ìˆ˜ë£Œ ë¶„ë°° ì‹œìŠ¤í…œì„ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- 2ì°¨ íŒë§¤ ì¶”ì  ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ’° NFT ë¡œì—´í‹° ì‹œìŠ¤í…œ

### ë¡œì—´í‹°ì˜ ê°œë…
NFT ë¡œì—´í‹°ëŠ” ì°½ì‘ìê°€ ìì‹ ì˜ ì‘í’ˆì´ 2ì°¨ ì‹œì¥ì—ì„œ ê±°ë˜ë  ë•Œë§ˆë‹¤ ì¼ì • ë¹„ìœ¨ì˜ ìˆ˜ìˆ˜ë£Œë¥¼ ë°›ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

```move
module nft_royalty::royalty_system {
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    use std::option::{Self, Option};
    use aptos_framework::object::{Self, Object, ConstructorRef};
    use aptos_framework::fungible_asset::{Self, Metadata};
    use aptos_framework::primary_fungible_store;
    use aptos_token_objects::collection;
    use aptos_token_objects::token;
    use aptos_token_objects::property_map;
    
    /// ë¡œì—´í‹° ì •ë³´
    struct RoyaltyInfo has key, store, copy, drop {
        /// ë¡œì—´í‹° ìˆ˜ì‹ ìë“¤ê³¼ ë¹„ìœ¨
        recipients: vector<RoyaltyRecipient>,
        /// ì´ ë¡œì—´í‹° ë¹„ìœ¨ (basis points, 10000 = 100%)
        total_rate: u64,
        /// ë¡œì—´í‹° ì ìš© ì—¬ë¶€
        enabled: bool,
        /// ìµœì†Œ ê±°ë˜ ê¸ˆì•¡ (ë¡œì—´í‹° ì ìš© ê¸°ì¤€)
        minimum_sale_amount: u64,
        /// ìƒì„± ì‹œê°„
        created_at: u64
    }
    
    /// ë¡œì—´í‹° ìˆ˜ì‹ ì
    struct RoyaltyRecipient has store, copy, drop {
        /// ìˆ˜ì‹ ì ì£¼ì†Œ
        recipient: address,
        /// ë¹„ìœ¨ (basis points)
        rate: u64,
        /// ì„¤ëª…
        description: String
    }
    
    /// NFT ê±°ë˜ ê¸°ë¡
    struct SaleRecord has key, store {
        /// NFT ê°ì²´
        nft: Object<token::Token>,
        /// ê±°ë˜ ê¸°ë¡ë“¤
        sales: vector<SaleInfo>
    }
    
    /// ê±°ë˜ ì •ë³´
    struct SaleInfo has store, copy, drop {
        /// íŒë§¤ì
        seller: address,
        /// êµ¬ë§¤ì
        buyer: address,
        /// ê±°ë˜ ê°€ê²©
        price: u64,
        /// ì§€ë¶ˆ í† í°
        payment_token: Object<Metadata>,
        /// ë¡œì—´í‹° ì§€ë¶ˆ ê¸ˆì•¡
        royalty_paid: u64,
        /// ê±°ë˜ ì‹œê°„
        timestamp: u64,
        /// ê±°ë˜ ìœ í˜• (direct, auction, offer ë“±)
        sale_type: String
    }
    
    /// ë¡œì—´í‹° í’€ (ìˆ˜ìˆ˜ë£Œ ë¶„ë°°ìš©)
    struct RoyaltyPool has key {
        /// í† í°ë³„ ëˆ„ì  ë¡œì—´í‹°
        accumulated_royalties: simple_map::SimpleMap<Object<Metadata>, u64>,
        /// ìˆ˜ì‹ ìë³„ ì²­êµ¬ ê°€ëŠ¥ ê¸ˆì•¡
        claimable_amounts: simple_map::SimpleMap<address, simple_map::SimpleMap<Object<Metadata>, u64>>,
        /// ì´ ë¡œì—´í‹° ìˆ˜ì§‘ ê¸ˆì•¡
        total_collected: u64,
        /// ì´ ë¶„ë°° ê¸ˆì•¡
        total_distributed: u64
    }
    
    /// ë¡œì—´í‹° ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    public fun initialize_royalty_system(admin: &signer) {
        move_to(admin, RoyaltyPool {
            accumulated_royalties: simple_map::create(),
            claimable_amounts: simple_map::create(),
            total_collected: 0,
            total_distributed: 0
        });
    }
    
    /// NFTì— ë¡œì—´í‹° ì„¤ì •
    public fun set_royalty(
        creator: &signer,
        nft: Object<token::Token>,
        recipients: vector<address>,
        rates: vector<u64>,
        descriptions: vector<String>,
        minimum_sale_amount: u64
    ) {
        let creator_addr = signer::address_of(creator);
        
        // NFT ì†Œìœ ê¶Œ í™•ì¸
        assert!(object::is_owner(nft, creator_addr), E_NOT_OWNER);
        
        // ì…ë ¥ ê²€ì¦
        let recipients_len = vector::length(&recipients);
        assert!(recipients_len == vector::length(&rates), E_MISMATCHED_ARRAYS);
        assert!(recipients_len == vector::length(&descriptions), E_MISMATCHED_ARRAYS);
        assert!(recipients_len > 0, E_EMPTY_RECIPIENTS);
        
        // ë¡œì—´í‹° ìˆ˜ì‹ ì êµ¬ì„±
        let royalty_recipients = vector::empty<RoyaltyRecipient>();
        let mut total_rate = 0u64;
        let i = 0;
        
        while (i < recipients_len) {
            let recipient = *vector::borrow(&recipients, i);
            let rate = *vector::borrow(&rates, i);
            let description = *vector::borrow(&descriptions, i);
            
            assert!(rate > 0, E_ZERO_RATE);
            assert!(rate <= 10000, E_RATE_TOO_HIGH); // ìµœëŒ€ 100%
            
            vector::push_back(&mut royalty_recipients, RoyaltyRecipient {
                recipient,
                rate,
                description
            });
            
            total_rate = total_rate + rate;
            i = i + 1;
        };
        
        // ì´ ë¡œì—´í‹° ë¹„ìœ¨ ê²€ì¦ (ìµœëŒ€ 10% = 1000 basis points)
        assert!(total_rate <= 1000, E_TOTAL_RATE_TOO_HIGH);
        
        // ë¡œì—´í‹° ì •ë³´ ì €ì¥
        let royalty_info = RoyaltyInfo {
            recipients: royalty_recipients,
            total_rate,
            enabled: true,
            minimum_sale_amount,
            created_at: timestamp::now_seconds()
        };
        
        // NFT ê°ì²´ì— ë¡œì—´í‹° ì •ë³´ ì €ì¥
        move_to(&object::generate_signer(&nft), royalty_info);
    }
    
    /// NFT íŒë§¤ ì‹œ ë¡œì—´í‹° ì²˜ë¦¬
    public fun process_sale_royalty(
        seller: &signer,
        buyer: &signer,
        nft: Object<token::Token>,
        sale_price: u64,
        payment_token: Object<Metadata>,
        sale_type: String
    ) acquires RoyaltyInfo, SaleRecord, RoyaltyPool {
        let seller_addr = signer::address_of(seller);
        let buyer_addr = signer::address_of(buyer);
        
        // ë¡œì—´í‹° ì •ë³´ í™•ì¸
        let nft_addr = object::object_address(&nft);
        if (!exists<RoyaltyInfo>(nft_addr)) {
            // ë¡œì—´í‹° ì—†ìŒ - ê±°ë˜ ê¸°ë¡ë§Œ ì €ì¥
            record_sale(nft, seller_addr, buyer_addr, sale_price, payment_token, 0, sale_type);
            return
        };
        
        let royalty_info = borrow_global<RoyaltyInfo>(nft_addr);
        
        // ë¡œì—´í‹° ë¹„í™œì„±í™” ë˜ëŠ” ìµœì†Œ ê¸ˆì•¡ ë¯¸ë‹¬ ì‹œ
        if (!royalty_info.enabled || sale_price < royalty_info.minimum_sale_amount) {
            record_sale(nft, seller_addr, buyer_addr, sale_price, payment_token, 0, sale_type);
            return
        };
        
        // ë¡œì—´í‹° ê³„ì‚° ë° ë¶„ë°°
        let total_royalty = (sale_price * royalty_info.total_rate) / 10000;
        
        if (total_royalty > 0) {
            distribute_royalty(seller, payment_token, total_royalty, &royalty_info.recipients);
        };
        
        // ê±°ë˜ ê¸°ë¡
        record_sale(nft, seller_addr, buyer_addr, sale_price, payment_token, total_royalty, sale_type);
    }
    
    /// ë¡œì—´í‹° ë¶„ë°°
    fun distribute_royalty(
        payer: &signer,
        payment_token: Object<Metadata>,
        total_royalty: u64,
        recipients: &vector<RoyaltyRecipient>
    ) acquires RoyaltyPool {
        let pool = borrow_global_mut<RoyaltyPool>(@nft_royalty);
        
        let i = 0;
        let recipients_len = vector::length(recipients);
        
        while (i < recipients_len) {
            let recipient_info = vector::borrow(recipients, i);
            let recipient_amount = (total_royalty * recipient_info.rate) / 
                                 calculate_total_rate(recipients);
            
            if (recipient_amount > 0) {
                // ì§ì ‘ ì „ì†¡ ë˜ëŠ” í’€ì— ëˆ„ì 
                if (can_direct_transfer(recipient_info.recipient, payment_token)) {
                    // ì§ì ‘ ì „ì†¡
                    let royalty_fa = primary_fungible_store::withdraw(payer, payment_token, recipient_amount);
                    primary_fungible_store::deposit(recipient_info.recipient, royalty_fa);
                } else {
                    // í’€ì— ëˆ„ì  (ë‚˜ì¤‘ì— ì²­êµ¬)
                    accumulate_royalty_in_pool(pool, recipient_info.recipient, payment_token, recipient_amount);
                    
                    // ì§€ë¶ˆìì—ê²Œì„œ í’€ë¡œ ì´ì „
                    let royalty_fa = primary_fungible_store::withdraw(payer, payment_token, recipient_amount);
                    primary_fungible_store::deposit(@nft_royalty, royalty_fa);
                }
            };
            
            i = i + 1;
        };
        
        pool.total_collected = pool.total_collected + total_royalty;
    }
    
    /// í’€ì— ë¡œì—´í‹° ëˆ„ì 
    fun accumulate_royalty_in_pool(
        pool: &mut RoyaltyPool,
        recipient: address,
        token: Object<Metadata>,
        amount: u64
    ) {
        // í† í°ë³„ ëˆ„ì 
        if (simple_map::contains_key(&pool.accumulated_royalties, &token)) {
            let current = simple_map::borrow_mut(&mut pool.accumulated_royalties, &token);
            *current = *current + amount;
        } else {
            simple_map::add(&mut pool.accumulated_royalties, token, amount);
        };
        
        // ìˆ˜ì‹ ìë³„ ì²­êµ¬ ê°€ëŠ¥ ê¸ˆì•¡
        if (simple_map::contains_key(&pool.claimable_amounts, &recipient)) {
            let recipient_map = simple_map::borrow_mut(&mut pool.claimable_amounts, &recipient);
            if (simple_map::contains_key(recipient_map, &token)) {
                let current = simple_map::borrow_mut(recipient_map, &token);
                *current = *current + amount;
            } else {
                simple_map::add(recipient_map, token, amount);
            }
        } else {
            let mut new_map = simple_map::create<Object<Metadata>, u64>();
            simple_map::add(&mut new_map, token, amount);
            simple_map::add(&mut pool.claimable_amounts, recipient, new_map);
        }
    }
    
    /// ë¡œì—´í‹° ì²­êµ¬
    public fun claim_royalty(
        recipient: &signer,
        token: Object<Metadata>
    ) acquires RoyaltyPool {
        let recipient_addr = signer::address_of(recipient);
        let pool = borrow_global_mut<RoyaltyPool>(@nft_royalty);
        
        assert!(simple_map::contains_key(&pool.claimable_amounts, &recipient_addr), E_NO_CLAIMABLE_ROYALTY);
        
        let recipient_map = simple_map::borrow_mut(&mut pool.claimable_amounts, &recipient_addr);
        assert!(simple_map::contains_key(recipient_map, &token), E_NO_CLAIMABLE_TOKEN);
        
        let claimable_amount = simple_map::remove(recipient_map, &token);
        assert!(claimable_amount > 0, E_ZERO_CLAIMABLE);
        
        // ë¡œì—´í‹° ì „ì†¡
        let royalty_fa = primary_fungible_store::withdraw(&account::create_signer(@nft_royalty), token, claimable_amount);
        primary_fungible_store::deposit(recipient_addr, royalty_fa);
        
        pool.total_distributed = pool.total_distributed + claimable_amount;
    }
    
    /// ê±°ë˜ ê¸°ë¡
    fun record_sale(
        nft: Object<token::Token>,
        seller: address,
        buyer: address,
        price: u64,
        payment_token: Object<Metadata>,
        royalty_paid: u64,
        sale_type: String
    ) acquires SaleRecord {
        let nft_addr = object::object_address(&nft);
        
        let sale_info = SaleInfo {
            seller,
            buyer,
            price,
            payment_token,
            royalty_paid,
            timestamp: timestamp::now_seconds(),
            sale_type
        };
        
        if (exists<SaleRecord>(nft_addr)) {
            let record = borrow_global_mut<SaleRecord>(nft_addr);
            vector::push_back(&mut record.sales, sale_info);
        } else {
            let new_record = SaleRecord {
                nft,
                sales: vector::singleton(sale_info)
            };
            move_to(&object::generate_signer(&nft), new_record);
        }
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun calculate_total_rate(recipients: &vector<RoyaltyRecipient>): u64 {
        let mut total = 0u64;
        let i = 0;
        while (i < vector::length(recipients)) {
            total = total + vector::borrow(recipients, i).rate;
            i = i + 1;
        };
        total
    }
    
    fun can_direct_transfer(recipient: address, token: Object<Metadata>): bool {
        primary_fungible_store::is_frozen(recipient, token) == false
    }
    
    // ì¡°íšŒ í•¨ìˆ˜ë“¤
    
    /// NFT ë¡œì—´í‹° ì •ë³´ ì¡°íšŒ
    public fun get_royalty_info(nft: Object<token::Token>): Option<RoyaltyInfo> acquires RoyaltyInfo {
        let nft_addr = object::object_address(&nft);
        if (exists<RoyaltyInfo>(nft_addr)) {
            option::some(*borrow_global<RoyaltyInfo>(nft_addr))
        } else {
            option::none()
        }
    }
    
    /// NFT ê±°ë˜ ê¸°ë¡ ì¡°íšŒ
    public fun get_sale_history(nft: Object<token::Token>): vector<SaleInfo> acquires SaleRecord {
        let nft_addr = object::object_address(&nft);
        if (exists<SaleRecord>(nft_addr)) {
            borrow_global<SaleRecord>(nft_addr).sales
        } else {
            vector::empty()
        }
    }
    
    /// ì²­êµ¬ ê°€ëŠ¥í•œ ë¡œì—´í‹° ì¡°íšŒ
    public fun get_claimable_royalty(
        recipient: address,
        token: Object<Metadata>
    ): u64 acquires RoyaltyPool {
        let pool = borrow_global<RoyaltyPool>(@nft_royalty);
        
        if (simple_map::contains_key(&pool.claimable_amounts, &recipient)) {
            let recipient_map = simple_map::borrow(&pool.claimable_amounts, &recipient);
            if (simple_map::contains_key(recipient_map, &token)) {
                *simple_map::borrow(recipient_map, &token)
            } else {
                0
            }
        } else {
            0
        }
    }
    
    // ì—ëŸ¬ ì½”ë“œ
    const E_NOT_OWNER: u64 = 1;
    const E_MISMATCHED_ARRAYS: u64 = 2;
    const E_EMPTY_RECIPIENTS: u64 = 3;
    const E_ZERO_RATE: u64 = 4;
    const E_RATE_TOO_HIGH: u64 = 5;
    const E_TOTAL_RATE_TOO_HIGH: u64 = 6;
    const E_NO_CLAIMABLE_ROYALTY: u64 = 7;
    const E_NO_CLAIMABLE_TOKEN: u64 = 8;
    const E_ZERO_CLAIMABLE: u64 = 9;
}
```

## ğŸ—ºï¸ Property Map í™œìš©

Property Mapì€ NFTì˜ ë©”íƒ€ë°ì´í„°ë¥¼ ì˜¨ì²´ì¸ì—ì„œ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

```move
module nft_metadata::property_system {
    use std::string::{Self, String};
    use std::vector;
    use std::option::{Self, Option};
    use aptos_framework::object::{Self, Object};
    use aptos_token_objects::token;
    use aptos_token_objects::property_map::{Self, PropertyMap};
    use aptos_framework::timestamp;
    
    /// NFT ì†ì„± íƒ€ì…
    struct PropertyType has copy, drop, store {
        name: String,
        type_info: String,  // "string", "u64", "bool", "address", "vector<u8>"
        mutable: bool,
        required: bool,
        default_value: Option<vector<u8>>
    }
    
    /// NFT ìŠ¤í‚¤ë§ˆ (ì»¬ë ‰ì…˜ë³„ ì†ì„± ì •ì˜)
    struct NFTSchema has key, store {
        collection: Object<collection::Collection>,
        properties: vector<PropertyType>,
        version: u64,
        created_at: u64,
        updated_at: u64
    }
    
    /// ë™ì  ì†ì„± ì—…ë°ì´íŠ¸ ê¶Œí•œ
    struct UpdatePermission has key, store {
        nft: Object<token::Token>,
        authorized_updaters: vector<address>,
        update_rules: vector<UpdateRule>
    }
    
    /// ì—…ë°ì´íŠ¸ ê·œì¹™
    struct UpdateRule has store, copy, drop {
        property_name: String,
        updater_role: String,  // "owner", "creator", "admin", "anyone"
        conditions: vector<String>  // ì—…ë°ì´íŠ¸ ì¡°ê±´ë“¤
    }
    
    /// ì†ì„± ë³€ê²½ ê¸°ë¡
    struct PropertyHistory has key, store {
        nft: Object<token::Token>,
        changes: vector<PropertyChange>
    }
    
    /// ì†ì„± ë³€ê²½ ì •ë³´
    struct PropertyChange has store, copy, drop {
        property_name: String,
        old_value: vector<u8>,
        new_value: vector<u8>,
        updater: address,
        timestamp: u64,
        reason: String
    }
    
    /// NFT ìŠ¤í‚¤ë§ˆ ìƒì„±
    public fun create_nft_schema(
        creator: &signer,
        collection: Object<collection::Collection>,
        property_names: vector<String>,
        property_types: vector<String>,
        mutability: vector<bool>,
        required: vector<bool>
    ) {
        let creator_addr = signer::address_of(creator);
        
        // ì»¬ë ‰ì…˜ ì†Œìœ ê¶Œ í™•ì¸
        assert!(collection::creator(collection) == creator_addr, E_NOT_COLLECTION_CREATOR);
        
        // ì…ë ¥ ê²€ì¦
        let len = vector::length(&property_names);
        assert!(len == vector::length(&property_types), E_MISMATCHED_ARRAYS);
        assert!(len == vector::length(&mutability), E_MISMATCHED_ARRAYS);
        assert!(len == vector::length(&required), E_MISMATCHED_ARRAYS);
        
        // ì†ì„± íƒ€ì… êµ¬ì„±
        let mut properties = vector::empty<PropertyType>();
        let i = 0;
        
        while (i < len) {
            let property = PropertyType {
                name: *vector::borrow(&property_names, i),
                type_info: *vector::borrow(&property_types, i),
                mutable: *vector::borrow(&mutability, i),
                required: *vector::borrow(&required, i),
                default_value: option::none()
            };
            
            vector::push_back(&mut properties, property);
            i = i + 1;
        };
        
        // ìŠ¤í‚¤ë§ˆ ì €ì¥
        let schema = NFTSchema {
            collection,
            properties,
            version: 1,
            created_at: timestamp::now_seconds(),
            updated_at: timestamp::now_seconds()
        };
        
        move_to(creator, schema);
    }
    
    /// NFT ì†ì„± ì„¤ì • (ìƒì„± ì‹œ)
    public fun set_initial_properties(
        creator: &signer,
        nft: Object<token::Token>,
        property_names: vector<String>,
        property_values: vector<vector<u8>>,
        property_types: vector<String>
    ) acquires NFTSchema {
        let creator_addr = signer::address_of(creator);
        let collection = token::collection_object(nft);
        
        // ê¶Œí•œ í™•ì¸
        assert!(token::creator(nft) == creator_addr, E_NOT_TOKEN_CREATOR);
        
        // ìŠ¤í‚¤ë§ˆ í™•ì¸
        assert!(exists<NFTSchema>(creator_addr), E_NO_SCHEMA);
        let schema = borrow_global<NFTSchema>(creator_addr);
        
        // ì…ë ¥ ê²€ì¦
        let len = vector::length(&property_names);
        assert!(len == vector::length(&property_values), E_MISMATCHED_ARRAYS);
        assert!(len == vector::length(&property_types), E_MISMATCHED_ARRAYS);
        
        // Property Map ìƒì„±
        let mut keys = vector::empty<String>();
        let mut values = vector::empty<vector<u8>>();
        let mut types = vector::empty<String>();
        
        let i = 0;
        while (i < len) {
            let name = *vector::borrow(&property_names, i);
            let value = *vector::borrow(&property_values, i);
            let type_info = *vector::borrow(&property_types, i);
            
            // ìŠ¤í‚¤ë§ˆ ê²€ì¦
            validate_property_against_schema(schema, &name, &value, &type_info);
            
            vector::push_back(&mut keys, name);
            vector::push_back(&mut values, value);
            vector::push_back(&mut types, type_info);
            
            i = i + 1;
        };
        
        // Property Map ìƒì„± ë° ì ìš©
        let property_map = property_map::init(&keys, &values, &types);
        property_map::add_typed(&mut property_map, string::utf8(b"created_at"), timestamp::now_seconds());
        
        // NFTì— Property Map ì ìš© (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í† í° ìƒì„± ì‹œ í¬í•¨)
        // ì—¬ê¸°ì„œëŠ” ì˜ˆì‹œë¡œ ë³„ë„ ë¦¬ì†ŒìŠ¤ì— ì €ì¥
        move_to(&object::generate_signer(&nft), PropertyHistory {
            nft,
            changes: vector::empty()
        });
    }
    
    /// NFT ì†ì„± ì—…ë°ì´íŠ¸
    public fun update_property(
        updater: &signer,
        nft: Object<token::Token>,
        property_name: String,
        new_value: vector<u8>,
        reason: String
    ) acquires UpdatePermission, PropertyHistory, NFTSchema {
        let updater_addr = signer::address_of(updater);
        let nft_addr = object::object_address(&nft);
        
        // ì—…ë°ì´íŠ¸ ê¶Œí•œ í™•ì¸
        if (exists<UpdatePermission>(nft_addr)) {
            let permission = borrow_global<UpdatePermission>(nft_addr);
            assert!(can_update_property(permission, updater_addr, &property_name), E_NO_UPDATE_PERMISSION);
        } else {
            // ê¸°ë³¸ ê¶Œí•œ: NFT ì†Œìœ ìë§Œ ê°€ëŠ¥
            assert!(object::is_owner(nft, updater_addr), E_NOT_NFT_OWNER);
        };
        
        // ìŠ¤í‚¤ë§ˆ ê²€ì¦
        let collection = token::collection_object(nft);
        let creator = token::creator(nft);
        if (exists<NFTSchema>(creator)) {
            let schema = borrow_global<NFTSchema>(creator);
            validate_property_mutability(schema, &property_name);
        };
        
        // í˜„ì¬ ê°’ ê°€ì ¸ì˜¤ê¸°
        let current_property_map = token::property_map(nft);
        let old_value = if (property_map::contains_key(&current_property_map, &property_name)) {
            property_map::read_bytes(&current_property_map, &property_name)
        } else {
            vector::empty<u8>()
        };
        
        // ì†ì„± ì—…ë°ì´íŠ¸ (ì‹¤ì œë¡œëŠ” NFT ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸)
        // ì—¬ê¸°ì„œëŠ” ë³€ê²½ ê¸°ë¡ë§Œ ì €ì¥
        record_property_change(nft, property_name, old_value, new_value, updater_addr, reason);
    }
    
    /// ë°°ì¹˜ ì†ì„± ì—…ë°ì´íŠ¸
    public fun batch_update_properties(
        updater: &signer,
        nft: Object<token::Token>,
        property_names: vector<String>,
        new_values: vector<vector<u8>>,
        reason: String
    ) acquires UpdatePermission, PropertyHistory, NFTSchema {
        let len = vector::length(&property_names);
        assert!(len == vector::length(&new_values), E_MISMATCHED_ARRAYS);
        
        let i = 0;
        while (i < len) {
            let name = *vector::borrow(&property_names, i);
            let value = *vector::borrow(&new_values, i);
            
            update_property(updater, nft, name, value, reason);
            i = i + 1;
        }
    }
    
    /// ì¡°ê±´ë¶€ ì†ì„± ì—…ë°ì´íŠ¸
    public fun conditional_update_property(
        updater: &signer,
        nft: Object<token::Token>,
        property_name: String,
        new_value: vector<u8>,
        condition: String,  // "if_greater_than", "if_less_than", "if_equals", etc.
        condition_value: vector<u8>,
        reason: String
    ) acquires UpdatePermission, PropertyHistory, NFTSchema {
        // ì¡°ê±´ í™•ì¸
        let current_property_map = token::property_map(nft);
        if (property_map::contains_key(&current_property_map, &property_name)) {
            let current_value = property_map::read_bytes(&current_property_map, &property_name);
            
            if (evaluate_condition(&current_value, &condition, &condition_value)) {
                update_property(updater, nft, property_name, new_value, reason);
            }
        }
    }
    
    /// ì‹œê°„ ê¸°ë°˜ ì†ì„± ì—…ë°ì´íŠ¸
    public fun time_based_update(
        updater: &signer,
        nft: Object<token::Token>,
        property_name: String,
        new_value: vector<u8>,
        valid_from: u64,
        valid_until: u64,
        reason: String
    ) acquires UpdatePermission, PropertyHistory, NFTSchema {
        let current_time = timestamp::now_seconds();
        
        assert!(current_time >= valid_from, E_UPDATE_NOT_READY);
        assert!(current_time <= valid_until, E_UPDATE_EXPIRED);
        
        update_property(updater, nft, property_name, new_value, reason);
    }
    
    /// ì§„í™”í˜• NFT ì†ì„± ì—…ë°ì´íŠ¸
    public fun evolve_nft(
        owner: &signer,
        nft: Object<token::Token>,
        evolution_level: u64,
        new_properties: vector<String>,
        new_values: vector<vector<u8>>
    ) acquires UpdatePermission, PropertyHistory, NFTSchema {
        let owner_addr = signer::address_of(owner);
        assert!(object::is_owner(nft, owner_addr), E_NOT_NFT_OWNER);
        
        // í˜„ì¬ ë ˆë²¨ í™•ì¸
        let current_property_map = token::property_map(nft);
        let current_level = if (property_map::contains_key(&current_property_map, &string::utf8(b"level"))) {
            property_map::read_u64(&current_property_map, &string::utf8(b"level"))
        } else {
            0
        };
        
        assert!(evolution_level > current_level, E_INVALID_EVOLUTION);
        
        // ë ˆë²¨ ì—…ë°ì´íŠ¸
        update_property(owner, nft, string::utf8(b"level"), bcs::to_bytes(&evolution_level), string::utf8(b"evolution"));
        
        // ìƒˆë¡œìš´ ì†ì„±ë“¤ ì—…ë°ì´íŠ¸
        batch_update_properties(owner, nft, new_properties, new_values, string::utf8(b"evolution"));
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    
    /// ìŠ¤í‚¤ë§ˆ ê²€ì¦
    fun validate_property_against_schema(
        schema: &NFTSchema,
        property_name: &String,
        value: &vector<u8>,
        type_info: &String
    ) {
        let i = 0;
        let found = false;
        
        while (i < vector::length(&schema.properties)) {
            let property_type = vector::borrow(&schema.properties, i);
            if (&property_type.name == property_name) {
                assert!(&property_type.type_info == type_info, E_TYPE_MISMATCH);
                found = true;
                break
            };
            i = i + 1;
        };
        
        assert!(found, E_PROPERTY_NOT_IN_SCHEMA);
    }
    
    /// ì†ì„± ë³€ê²½ ê°€ëŠ¥ì„± ê²€ì¦
    fun validate_property_mutability(schema: &NFTSchema, property_name: &String) {
        let i = 0;
        while (i < vector::length(&schema.properties)) {
            let property_type = vector::borrow(&schema.properties, i);
            if (&property_type.name == property_name) {
                assert!(property_type.mutable, E_PROPERTY_IMMUTABLE);
                break
            };
            i = i + 1;
        }
    }
    
    /// ì—…ë°ì´íŠ¸ ê¶Œí•œ í™•ì¸
    fun can_update_property(
        permission: &UpdatePermission,
        updater: address,
        property_name: &String
    ): bool {
        // ê¶Œí•œì ëª©ë¡ í™•ì¸
        if (vector::contains(&permission.authorized_updaters, &updater)) {
            return true
        };
        
        // ì—…ë°ì´íŠ¸ ê·œì¹™ í™•ì¸
        let i = 0;
        while (i < vector::length(&permission.update_rules)) {
            let rule = vector::borrow(&permission.update_rules, i);
            if (&rule.property_name == property_name) {
                return evaluate_update_rule(rule, updater, permission.nft)
            };
            i = i + 1;
        };
        
        false
    }
    
    /// ì—…ë°ì´íŠ¸ ê·œì¹™ í‰ê°€
    fun evaluate_update_rule(rule: &UpdateRule, updater: address, nft: Object<token::Token>): bool {
        if (rule.updater_role == string::utf8(b"owner")) {
            object::is_owner(nft, updater)
        } else if (rule.updater_role == string::utf8(b"creator")) {
            token::creator(nft) == updater
        } else if (rule.updater_role == string::utf8(b"anyone")) {
            true
        } else {
            false
        }
    }
    
    /// ì¡°ê±´ í‰ê°€
    fun evaluate_condition(
        current_value: &vector<u8>,
        condition: &String,
        condition_value: &vector<u8>
    ): bool {
        if (condition == &string::utf8(b"if_equals")) {
            current_value == condition_value
        } else if (condition == &string::utf8(b"if_not_equals")) {
            current_value != condition_value
        } else {
            // ë‹¤ë¥¸ ì¡°ê±´ë“¤ì€ íƒ€ì…ë³„ë¡œ êµ¬í˜„ í•„ìš”
            false
        }
    }
    
    /// ì†ì„± ë³€ê²½ ê¸°ë¡
    fun record_property_change(
        nft: Object<token::Token>,
        property_name: String,
        old_value: vector<u8>,
        new_value: vector<u8>,
        updater: address,
        reason: String
    ) acquires PropertyHistory {
        let nft_addr = object::object_address(&nft);
        
        let change = PropertyChange {
            property_name,
            old_value,
            new_value,
            updater,
            timestamp: timestamp::now_seconds(),
            reason
        };
        
        if (exists<PropertyHistory>(nft_addr)) {
            let history = borrow_global_mut<PropertyHistory>(nft_addr);
            vector::push_back(&mut history.changes, change);
        } else {
            let new_history = PropertyHistory {
                nft,
                changes: vector::singleton(change)
            };
            move_to(&object::generate_signer(&nft), new_history);
        }
    }
    
    // ì¡°íšŒ í•¨ìˆ˜ë“¤
    
    /// NFT ì†ì„± ì¡°íšŒ
    public fun get_property_value(nft: Object<token::Token>, property_name: String): Option<vector<u8>> {
        let property_map = token::property_map(nft);
        if (property_map::contains_key(&property_map, &property_name)) {
            option::some(property_map::read_bytes(&property_map, &property_name))
        } else {
            option::none()
        }
    }
    
    /// NFT ëª¨ë“  ì†ì„± ì¡°íšŒ
    public fun get_all_properties(nft: Object<token::Token>): PropertyMap {
        token::property_map(nft)
    }
    
    /// ì†ì„± ë³€ê²½ ê¸°ë¡ ì¡°íšŒ
    public fun get_property_history(nft: Object<token::Token>): vector<PropertyChange> acquires PropertyHistory {
        let nft_addr = object::object_address(&nft);
        if (exists<PropertyHistory>(nft_addr)) {
            borrow_global<PropertyHistory>(nft_addr).changes
        } else {
            vector::empty()
        }
    }
    
    /// íŠ¹ì • ì†ì„±ì˜ ë³€ê²½ ê¸°ë¡ ì¡°íšŒ
    public fun get_property_change_history(
        nft: Object<token::Token>,
        property_name: String
    ): vector<PropertyChange> acquires PropertyHistory {
        let all_changes = get_property_history(nft);
        let mut filtered_changes = vector::empty<PropertyChange>();
        
        let i = 0;
        while (i < vector::length(&all_changes)) {
            let change = vector::borrow(&all_changes, i);
            if (change.property_name == property_name) {
                vector::push_back(&mut filtered_changes, *change);
            };
            i = i + 1;
        };
        
        filtered_changes
    }
    
    // ì—ëŸ¬ ì½”ë“œ
    const E_NOT_COLLECTION_CREATOR: u64 = 1;
    const E_NOT_TOKEN_CREATOR: u64 = 2;
    const E_NOT_NFT_OWNER: u64 = 3;
    const E_MISMATCHED_ARRAYS: u64 = 4;
    const E_NO_SCHEMA: u64 = 5;
    const E_NO_UPDATE_PERMISSION: u64 = 6;
    const E_PROPERTY_IMMUTABLE: u64 = 7;
    const E_TYPE_MISMATCH: u64 = 8;
    const E_PROPERTY_NOT_IN_SCHEMA: u64 = 9;
    const E_UPDATE_NOT_READY: u64 = 10;
    const E_UPDATE_EXPIRED: u64 = 11;
    const E_INVALID_EVOLUTION: u64 = 12;
}
```

## ğŸ® ì‹¤ì „ í™œìš© ì˜ˆì‹œ

### ê²Œì´ë° NFT ì‹œìŠ¤í…œ
```move
module gaming_nft::character_system {
    use std::string;
    use nft_royalty::royalty_system;
    use nft_metadata::property_system;
    use aptos_token_objects::token;
    
    /// ê²Œì„ ìºë¦­í„° NFT ìƒì„±
    public fun create_game_character(
        creator: &signer,
        collection: Object<collection::Collection>,
        name: string::String,
        description: string::String,
        initial_level: u64,
        character_class: string::String,
        rarity: string::String
    ): Object<token::Token> {
        // NFT ìƒì„±
        let nft = token::create_named_token(
            creator,
            collection,
            description,
            name,
            option::none(),
            string::utf8(b"https://game.example.com/character/")
        );
        
        // ì´ˆê¸° ì†ì„± ì„¤ì •
        let property_names = vector[
            string::utf8(b"level"),
            string::utf8(b"class"),
            string::utf8(b"rarity"),
            string::utf8(b"experience"),
            string::utf8(b"strength"),
            string::utf8(b"agility"),
            string::utf8(b"intelligence")
        ];
        
        let property_values = vector[
            bcs::to_bytes(&initial_level),
            bcs::to_bytes(&character_class),
            bcs::to_bytes(&rarity),
            bcs::to_bytes(&0u64), // ì´ˆê¸° ê²½í—˜ì¹˜
            bcs::to_bytes(&get_initial_stat(rarity, string::utf8(b"strength"))),
            bcs::to_bytes(&get_initial_stat(rarity, string::utf8(b"agility"))),
            bcs::to_bytes(&get_initial_stat(rarity, string::utf8(b"intelligence")))
        ];
        
        let property_types = vector[
            string::utf8(b"u64"),
            string::utf8(b"string"),
            string::utf8(b"string"),
            string::utf8(b"u64"),
            string::utf8(b"u64"),
            string::utf8(b"u64"),
            string::utf8(b"u64")
        ];
        
        property_system::set_initial_properties(
            creator,
            nft,
            property_names,
            property_values,
            property_types
        );
        
        // ë¡œì—´í‹° ì„¤ì • (5% ì°½ì‘ì, 2% ê²Œì„ ê°œë°œì‚¬)
        royalty_system::set_royalty(
            creator,
            nft,
            vector[signer::address_of(creator), @gaming_nft],
            vector[500, 200], // 5%, 2%
            vector[string::utf8(b"Creator Royalty"), string::utf8(b"Game Dev Fee")],
            1000000 // ìµœì†Œ ê±°ë˜ ê¸ˆì•¡: 1 APT
        );
        
        nft
    }
    
    /// ìºë¦­í„° ë ˆë²¨ì—…
    public fun level_up_character(
        owner: &signer,
        nft: Object<token::Token>,
        experience_gained: u64
    ) {
        // ê²½í—˜ì¹˜ ì—…ë°ì´íŠ¸
        property_system::update_property(
            owner,
            nft,
            string::utf8(b"experience"),
            bcs::to_bytes(&experience_gained),
            string::utf8(b"level_up")
        );
        
        // ë ˆë²¨ í™•ì¸ ë° ì—…ë°ì´íŠ¸
        let current_level = get_character_level(nft);
        let new_level = calculate_level_from_experience(experience_gained);
        
        if (new_level > current_level) {
            property_system::update_property(
                owner,
                nft,
                string::utf8(b"level"),
                bcs::to_bytes(&new_level),
                string::utf8(b"level_up")
            );
            
            // ìŠ¤íƒ¯ ì¦ê°€
            increase_character_stats(owner, nft, new_level - current_level);
        }
    }
    
    /// ìºë¦­í„° ì§„í™”
    public fun evolve_character(
        owner: &signer,
        nft: Object<token::Token>,
        evolution_materials: vector<Object<token::Token>>
    ) {
        let current_level = get_character_level(nft);
        assert!(current_level >= 50, E_INSUFFICIENT_LEVEL);
        
        // ì§„í™” ì¬ë£Œ í™•ì¸ ë° ì†Œê°
        validate_and_burn_materials(owner, evolution_materials);
        
        // ì§„í™” ì†ì„± ì¶”ê°€
        let evolution_properties = vector[
            string::utf8(b"evolved"),
            string::utf8(b"evolution_tier"),
            string::utf8(b"special_ability")
        ];
        
        let evolution_values = vector[
            bcs::to_bytes(&true),
            bcs::to_bytes(&1u64),
            bcs::to_bytes(&string::utf8(b"Fire Breath"))
        ];
        
        property_system::batch_update_properties(
            owner,
            nft,
            evolution_properties,
            evolution_values,
            string::utf8(b"character_evolution")
        );
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun get_initial_stat(rarity: string::String, stat_name: string::String): u64 {
        if (rarity == string::utf8(b"Legendary")) {
            100
        } else if (rarity == string::utf8(b"Epic")) {
            80
        } else if (rarity == string::utf8(b"Rare")) {
            60
        } else {
            40
        }
    }
    
    fun get_character_level(nft: Object<token::Token>): u64 {
        let level_value = property_system::get_property_value(nft, string::utf8(b"level"));
        if (option::is_some(&level_value)) {
            bcs::from_bytes<u64>(*option::borrow(&level_value))
        } else {
            1
        }
    }
    
    fun calculate_level_from_experience(experience: u64): u64 {
        // ê°„ë‹¨í•œ ë ˆë²¨ ê³„ì‚° ê³µì‹
        ((experience / 1000) + 1)
    }
    
    fun increase_character_stats(owner: &signer, nft: Object<token::Token>, level_increase: u64) {
        let stat_names = vector[
            string::utf8(b"strength"),
            string::utf8(b"agility"),
            string::utf8(b"intelligence")
        ];
        
        let i = 0;
        while (i < vector::length(&stat_names)) {
            let stat_name = *vector::borrow(&stat_names, i);
            let current_value = property_system::get_property_value(nft, stat_name);
            
            if (option::is_some(&current_value)) {
                let current_stat = bcs::from_bytes<u64>(*option::borrow(&current_value));
                let new_stat = current_stat + (level_increase * 5); // ë ˆë²¨ë‹¹ 5ì”© ì¦ê°€
                
                property_system::update_property(
                    owner,
                    nft,
                    stat_name,
                    bcs::to_bytes(&new_stat),
                    string::utf8(b"level_up_bonus")
                );
            };
            
            i = i + 1;
        }
    }
    
    fun validate_and_burn_materials(
        owner: &signer,
        materials: vector<Object<token::Token>>
    ) {
        // ì§„í™” ì¬ë£Œ ê²€ì¦ ë° ì†Œê° ë¡œì§
        assert!(!vector::is_empty(&materials), E_NO_MATERIALS);
        // ì‹¤ì œë¡œëŠ” ê° ì¬ë£Œì˜ ì†ì„±ì„ í™•ì¸í•˜ê³  ì ì ˆí•œ ì¬ë£Œì¸ì§€ ê²€ì¦
        // ê·¸ë¦¬ê³  ì†Œê° ì²˜ë¦¬
    }
    
    const E_INSUFFICIENT_LEVEL: u64 = 1;
    const E_NO_MATERIALS: u64 = 2;
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

NFT ë¡œì—´í‹°ì™€ Property Mapì„ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[NFT ë§ˆì¼“í”Œë ˆì´ìŠ¤ êµ¬ì¶• â†’](./nft-marketplace)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Aptos Token Objects](https://aptos.dev/standards/digital-asset)
- [Property Map ê°€ì´ë“œ](https://aptos.dev/standards/digital-asset#property-map)
- [NFT ë¡œì—´í‹° í‘œì¤€](https://aptos.dev/standards/digital-asset#royalty)

---

*Movement Networkì—ì„œ ì§„í™”í•˜ëŠ” NFT ìƒíƒœê³„ë¥¼ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ¨âœ¨*