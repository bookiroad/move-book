# ğŸ¨ NFT ê°œë… & Collection ì„¤ê³„

Movement Networkì—ì„œ NFTì˜ ê¸°ë³¸ ê°œë…ë¶€í„° í™•ì¥ ê°€ëŠ¥í•œ ì»¬ë ‰ì…˜ ì„¤ê³„ê¹Œì§€ ì™„ì „íˆ ë§ˆìŠ¤í„°í•˜ëŠ” ê°€ì´ë“œì…ë‹ˆë‹¤. Move ì–¸ì–´ì˜ ë¦¬ì†ŒìŠ¤ ëª¨ë¸ì„ í™œìš©í•œ ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ NFT ì‹œìŠ¤í…œì„ êµ¬ì¶•í•©ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- Movement NFTì˜ í•µì‹¬ ê°œë…ê³¼ ì•„í‚¤í…ì²˜ë¥¼ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í™•ì¥ ê°€ëŠ¥í•œ NFT ì»¬ë ‰ì…˜ì„ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- Move ë¦¬ì†ŒìŠ¤ ëª¨ë¸ì„ í™œìš©í•œ ì•ˆì „í•œ NFT êµ¬í˜„ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë‹¤ì–‘í•œ NFT ì‚¬ìš© ì‚¬ë¡€ì— ë§ëŠ” ì„¤ê³„ íŒ¨í„´ì„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ’ Movement NFT ê¸°ì´ˆ ê°œë…

### NFT (Non-Fungible Token)ë€?
```
NFT = ëŒ€ì²´ ë¶ˆê°€ëŠ¥í•œ í† í°

ğŸ”‘ í•µì‹¬ íŠ¹ì§•:
â”œâ”€â”€ ê³ ìœ ì„± (Uniqueness): ê° í† í°ì´ ê³ ìœ í•œ ì‹ë³„ìë¥¼ ê°€ì§
â”œâ”€â”€ ì†Œìœ ê¶Œ (Ownership): ëª…í™•í•œ ì†Œìœ ì ì •ë³´
â”œâ”€â”€ ì „ì†¡ ê°€ëŠ¥ì„± (Transferability): ì†Œìœ ê¶Œ ì´ì „ ê°€ëŠ¥
â”œâ”€â”€ ì§„ìœ„ì„± (Authenticity): ë¸”ë¡ì²´ì¸ìœ¼ë¡œ ê²€ì¦ëœ ì§„ë³¸ì„±
â””â”€â”€ í¬ì†Œì„± (Scarcity): ì œí•œëœ ìˆ˜ëŸ‰ ë˜ëŠ” ê³ ìœ í•œ íŠ¹ì„±
```

### Movement NFT vs ë‹¤ë¥¸ ì²´ì¸ NFT
```typescript
// Movement NFTì˜ ì¥ì 
const MOVEMENT_NFT_ADVANTAGES = {
  safety: {
    resourceModel: "Move ë¦¬ì†ŒìŠ¤ë¡œ ìì‚° ë³´í˜¸",
    compileTimeCheck: "ì»´íŒŒì¼ íƒ€ì„ ì•ˆì „ì„± ê²€ì¦",
    noDoubleSpending: "ì´ì¤‘ ì§€ì¶œ ë°©ì§€ ë³´ì¥"
  },
  
  performance: {
    highTPS: "ì´ˆë‹¹ 10,000+ íŠ¸ëœì­ì…˜ ì²˜ë¦¬",
    lowLatency: "ë°€ë¦¬ì´ˆ ë‹¨ìœ„ ì™„ê²°ì„±",
    lowGasFees: "ê²½ì œì ì¸ ë¯¼íŒ… ë° ê±°ë˜ ë¹„ìš©"
  },
  
  flexibility: {
    dynamicNFT: "ì§„í™”í•˜ëŠ” NFT ì§€ì›",
    composability: "ë‹¤ë¥¸ í”„ë¡œí† ì½œê³¼ ì‰¬ìš´ ì¡°í•©",
    upgradeability: "ìŠ¤ë§ˆíŠ¸ ì—…ê·¸ë ˆì´ë“œ íŒ¨í„´"
  }
};
```

### Move ë¦¬ì†ŒìŠ¤ ëª¨ë¸ê³¼ NFT
```move
// Moveì—ì„œ NFTëŠ” ë¦¬ì†ŒìŠ¤ë¡œ í‘œí˜„ë©ë‹ˆë‹¤
module nft_basics::simple_nft {
    use std::string::{Self, String};
    use std::signer;
    use aptos_framework::object::{Self, Object};
    
    /// NFTë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¦¬ì†ŒìŠ¤ êµ¬ì¡°ì²´
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct SimpleNFT has key {
        name: String,
        description: String,
        image: String,
        creator: address,
        owner: address,
        created_at: u64
    }
    
    /// NFT ë¯¼íŒ… (ìƒì„±)
    public fun mint_nft(
        creator: &signer,
        name: String,
        description: String,
        image: String
    ): Object<SimpleNFT> {
        let creator_addr = signer::address_of(creator);
        
        // Object ìƒì„± ë° NFT ë¦¬ì†ŒìŠ¤ ì €ì¥
        let constructor_ref = object::create_object(creator_addr);
        let object_signer = object::generate_signer(&constructor_ref);
        
        let nft = SimpleNFT {
            name,
            description,
            image,
            creator: creator_addr,
            owner: creator_addr,
            created_at: timestamp::now_seconds()
        };
        
        move_to(&object_signer, nft);
        object::object_from_constructor_ref<SimpleNFT>(&constructor_ref)
    }
    
    /// NFT ì†Œìœ ê¶Œ í™•ì¸
    public fun get_owner(nft_object: Object<SimpleNFT>): address acquires SimpleNFT {
        let nft_addr = object::object_address(&nft_object);
        let nft = borrow_global<SimpleNFT>(nft_addr);
        nft.owner
    }
    
    /// NFT ì „ì†¡
    public fun transfer(
        owner: &signer,
        nft_object: Object<SimpleNFT>,
        to: address
    ) acquires SimpleNFT {
        let owner_addr = signer::address_of(owner);
        let nft_addr = object::object_address(&nft_object);
        let nft = borrow_global_mut<SimpleNFT>(nft_addr);
        
        // ì†Œìœ ê¶Œ í™•ì¸
        assert!(nft.owner == owner_addr, E_NOT_OWNER);
        
        // ì†Œìœ ê¶Œ ì´ì „
        nft.owner = to;
        
        // ì´ë²¤íŠ¸ ë°œìƒ (ì‹¤ì œë¡œëŠ” event ëª¨ë“ˆ ì‚¬ìš©)
        // emit_transfer_event(owner_addr, to, nft_addr);
    }
}
```

## ğŸ—ï¸ NFT ì»¬ë ‰ì…˜ ì•„í‚¤í…ì²˜ ì„¤ê³„

### ì»¬ë ‰ì…˜ êµ¬ì¡° ì„¤ê³„
```move
module nft_collection::digital_art {
    use std::string::{Self, String};
    use std::vector;
    use std::option::{Self, Option};
    use aptos_framework::object::{Self, Object, ConstructorRef, DeleteRef};
    use aptos_framework::timestamp;
    use aptos_std::smart_table::{Self, SmartTable};
    
    /// ì»¬ë ‰ì…˜ ë©”íƒ€ë°ì´í„°
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct Collection has key {
        name: String,
        description: String,
        image: String,
        creator: address,
        
        // ì»¬ë ‰ì…˜ ì„¤ì •
        max_supply: Option<u64>,
        current_supply: u64,
        is_mutable: bool,
        
        // ì‹œê°„ ì œí•œ
        mint_start_time: Option<u64>,
        mint_end_time: Option<u64>,
        
        // ê°€ê²© ì •ì±…
        mint_price: u64,
        whitelist_price: Option<u64>,
        
        // ê¶Œí•œ ê´€ë¦¬
        minters: vector<address>,
        whitelist: SmartTable<address, bool>,
        
        // ë©”íƒ€ë°ì´í„°
        base_uri: String,
        royalty_percentage: u64,  // basis points (100 = 1%)
        
        // í†µê³„
        total_minted: u64,
        total_burned: u64
    }
    
    /// ê°œë³„ NFT í† í°
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct Token has key {
        collection: Object<Collection>,
        token_id: u64,
        name: String,
        description: String,
        image: String,
        
        // íŠ¹ì„± (traits)
        attributes: SmartTable<String, String>,
        
        // ë©”íƒ€ë°ì´í„°
        rarity_rank: Option<u64>,
        generation: u64,
        
        // ìƒíƒœ
        is_burned: bool,
        created_at: u64,
        last_transfer_at: u64
    }
    
    /// ì»¬ë ‰ì…˜ ìƒì„±
    public fun create_collection(
        creator: &signer,
        name: String,
        description: String,
        image: String,
        max_supply: Option<u64>,
        mint_price: u64,
        royalty_percentage: u64,
        base_uri: String
    ): Object<Collection> {
        let creator_addr = signer::address_of(creator);
        
        // ì…ë ¥ ê²€ì¦
        assert!(royalty_percentage <= 1000, E_INVALID_ROYALTY); // ìµœëŒ€ 10%
        assert!(string::length(&name) > 0, E_EMPTY_NAME);
        
        // Collection Object ìƒì„±
        let constructor_ref = object::create_object(creator_addr);
        let object_signer = object::generate_signer(&constructor_ref);
        
        let collection = Collection {
            name,
            description,
            image,
            creator: creator_addr,
            max_supply,
            current_supply: 0,
            is_mutable: true,
            mint_start_time: option::none(),
            mint_end_time: option::none(),
            mint_price,
            whitelist_price: option::none(),
            minters: vector::singleton(creator_addr),
            whitelist: smart_table::new(),
            base_uri,
            royalty_percentage,
            total_minted: 0,
            total_burned: 0
        };
        
        move_to(&object_signer, collection);
        object::object_from_constructor_ref<Collection>(&constructor_ref)
    }
    
    /// NFT ë¯¼íŒ… (í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì§€ì›)
    public fun mint_nft(
        minter: &signer,
        collection_obj: Object<Collection>,
        to: address,
        name: String,
        description: String,
        image: String,
        attributes: vector<(String, String)>
    ): Object<Token> acquires Collection {
        let minter_addr = signer::address_of(minter);
        let collection_addr = object::object_address(&collection_obj);
        let collection = borrow_global_mut<Collection>(collection_addr);
        
        // ë¯¼íŒ… ê¶Œí•œ í™•ì¸
        assert!(
            vector::contains(&collection.minters, &minter_addr) || 
            collection.creator == minter_addr,
            E_NOT_AUTHORIZED_MINTER
        );
        
        // ê³µê¸‰ëŸ‰ ì œí•œ í™•ì¸
        if (option::is_some(&collection.max_supply)) {
            let max_supply = *option::borrow(&collection.max_supply);
            assert!(collection.current_supply < max_supply, E_MAX_SUPPLY_REACHED);
        };
        
        // ì‹œê°„ ì œí•œ í™•ì¸
        let current_time = timestamp::now_seconds();
        if (option::is_some(&collection.mint_start_time)) {
            let start_time = *option::borrow(&collection.mint_start_time);
            assert!(current_time >= start_time, E_MINT_NOT_STARTED);
        };
        
        if (option::is_some(&collection.mint_end_time)) {
            let end_time = *option::borrow(&collection.mint_end_time);
            assert!(current_time <= end_time, E_MINT_ENDED);
        };
        
        // í† í° ID ìƒì„± (í˜„ì¬ ê³µê¸‰ëŸ‰ + 1)
        let token_id = collection.current_supply + 1;
        
        // Token Object ìƒì„±
        let constructor_ref = object::create_object(collection.creator);
        let object_signer = object::generate_signer(&constructor_ref);
        
        // ì†ì„± í…Œì´ë¸” ìƒì„±
        let attributes_table = smart_table::new();
        let i = 0;
        while (i < vector::length(&attributes)) {
            let (key, value) = *vector::borrow(&attributes, i);
            smart_table::add(&mut attributes_table, key, value);
            i = i + 1;
        };
        
        let token = Token {
            collection: collection_obj,
            token_id,
            name,
            description,
            image,
            attributes: attributes_table,
            rarity_rank: option::none(),
            generation: 1,
            is_burned: false,
            created_at: current_time,
            last_transfer_at: current_time
        };
        
        move_to(&object_signer, token);
        
        // ì»¬ë ‰ì…˜ í†µê³„ ì—…ë°ì´íŠ¸
        collection.current_supply = collection.current_supply + 1;
        collection.total_minted = collection.total_minted + 1;
        
        // ì†Œìœ ê¶Œì„ 'to' ì£¼ì†Œë¡œ ì„¤ì • (Object ì†Œìœ ê¶Œ)
        let linear_transfer_ref = object::generate_linear_transfer_ref(&constructor_ref);
        object::transfer_with_ref(linear_transfer_ref, to);
        
        object::object_from_constructor_ref<Token>(&constructor_ref)
    }
    
    /// ë°°ì¹˜ ë¯¼íŒ… (ê°€ìŠ¤ íš¨ìœ¨ì )
    public fun batch_mint(
        minter: &signer,
        collection_obj: Object<Collection>,
        recipients: vector<address>,
        names: vector<String>,
        descriptions: vector<String>,
        images: vector<String>,
        attributes_list: vector<vector<(String, String)>>
    ): vector<Object<Token>> acquires Collection {
        let tokens = vector::empty();
        let i = 0;
        let count = vector::length(&recipients);
        
        // ëª¨ë“  ë²¡í„°ì˜ ê¸¸ì´ê°€ ê°™ì€ì§€ í™•ì¸
        assert!(
            vector::length(&names) == count &&
            vector::length(&descriptions) == count &&
            vector::length(&images) == count &&
            vector::length(&attributes_list) == count,
            E_MISMATCHED_ARRAYS
        );
        
        while (i < count) {
            let recipient = *vector::borrow(&recipients, i);
            let name = *vector::borrow(&names, i);
            let description = *vector::borrow(&descriptions, i);
            let image = *vector::borrow(&images, i);
            let attributes = *vector::borrow(&attributes_list, i);
            
            let token = mint_nft(
                minter,
                collection_obj,
                recipient,
                name,
                description,
                image,
                attributes
            );
            
            vector::push_back(&mut tokens, token);
            i = i + 1;
        };
        
        tokens
    }
    
    /// í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬
    public fun add_to_whitelist(
        creator: &signer,
        collection_obj: Object<Collection>,
        addresses: vector<address>
    ) acquires Collection {
        let creator_addr = signer::address_of(creator);
        let collection_addr = object::object_address(&collection_obj);
        let collection = borrow_global_mut<Collection>(collection_addr);
        
        assert!(collection.creator == creator_addr, E_NOT_CREATOR);
        
        let i = 0;
        while (i < vector::length(&addresses)) {
            let addr = *vector::borrow(&addresses, i);
            smart_table::upsert(&mut collection.whitelist, addr, true);
            i = i + 1;
        }
    }
    
    /// ë¯¼íŒ… ì‹œê°„ ì„¤ì •
    public fun set_mint_time(
        creator: &signer,
        collection_obj: Object<Collection>,
        start_time: Option<u64>,
        end_time: Option<u64>
    ) acquires Collection {
        let creator_addr = signer::address_of(creator);
        let collection_addr = object::object_address(&collection_obj);
        let collection = borrow_global_mut<Collection>(collection_addr);
        
        assert!(collection.creator == creator_addr, E_NOT_CREATOR);
        assert!(collection.is_mutable, E_COLLECTION_IMMUTABLE);
        
        collection.mint_start_time = start_time;
        collection.mint_end_time = end_time;
    }
    
    /// ì»¬ë ‰ì…˜ ì •ë³´ ì¡°íšŒ
    public fun get_collection_info(collection_obj: Object<Collection>): CollectionInfo acquires Collection {
        let collection_addr = object::object_address(&collection_obj);
        let collection = borrow_global<Collection>(collection_addr);
        
        CollectionInfo {
            name: collection.name,
            description: collection.description,
            creator: collection.creator,
            max_supply: collection.max_supply,
            current_supply: collection.current_supply,
            mint_price: collection.mint_price,
            royalty_percentage: collection.royalty_percentage,
            total_minted: collection.total_minted,
            is_mint_active: is_mint_active(collection)
        }
    }
    
    /// í† í° ì •ë³´ ì¡°íšŒ
    public fun get_token_info(token_obj: Object<Token>): TokenInfo acquires Token {
        let token_addr = object::object_address(&token_obj);
        let token = borrow_global<Token>(token_addr);
        
        TokenInfo {
            collection: token.collection,
            token_id: token.token_id,
            name: token.name,
            description: token.description,
            owner: object::owner(token_obj),
            rarity_rank: token.rarity_rank,
            generation: token.generation,
            created_at: token.created_at
        }
    }
    
    // êµ¬ì¡°ì²´ ì •ì˜
    struct CollectionInfo has drop {
        name: String,
        description: String,
        creator: address,
        max_supply: Option<u64>,
        current_supply: u64,
        mint_price: u64,
        royalty_percentage: u64,
        total_minted: u64,
        is_mint_active: bool
    }
    
    struct TokenInfo has drop {
        collection: Object<Collection>,
        token_id: u64,
        name: String,
        description: String,
        owner: address,
        rarity_rank: Option<u64>,
        generation: u64,
        created_at: u64
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun is_mint_active(collection: &Collection): bool {
        let current_time = timestamp::now_seconds();
        
        // ì‹œì‘ ì‹œê°„ í™•ì¸
        if (option::is_some(&collection.mint_start_time)) {
            let start_time = *option::borrow(&collection.mint_start_time);
            if (current_time < start_time) return false;
        };
        
        // ì¢…ë£Œ ì‹œê°„ í™•ì¸
        if (option::is_some(&collection.mint_end_time)) {
            let end_time = *option::borrow(&collection.mint_end_time);
            if (current_time > end_time) return false;
        };
        
        // ê³µê¸‰ëŸ‰ í™•ì¸
        if (option::is_some(&collection.max_supply)) {
            let max_supply = *option::borrow(&collection.max_supply);
            if (collection.current_supply >= max_supply) return false;
        };
        
        true
    }
    
    // ì—ëŸ¬ ì½”ë“œ
    const E_NOT_OWNER: u64 = 1;
    const E_INVALID_ROYALTY: u64 = 2;
    const E_EMPTY_NAME: u64 = 3;
    const E_NOT_AUTHORIZED_MINTER: u64 = 4;
    const E_MAX_SUPPLY_REACHED: u64 = 5;
    const E_MINT_NOT_STARTED: u64 = 6;
    const E_MINT_ENDED: u64 = 7;
    const E_NOT_CREATOR: u64 = 8;
    const E_COLLECTION_IMMUTABLE: u64 = 9;
    const E_MISMATCHED_ARRAYS: u64 = 10;
}
```

## ğŸ¨ ë‹¤ì–‘í•œ NFT ì„¤ê³„ íŒ¨í„´

### 1. ì œë„ˆëŸ¬í‹°ë¸Œ NFT ì»¬ë ‰ì…˜
```move
module generative_nft::art_collection {
    use std::vector;
    use std::string::{Self, String};
    use aptos_std::smart_table::{Self, SmartTable};
    use aptos_framework::randomness;
    
    /// ì œë„ˆëŸ¬í‹°ë¸Œ íŠ¹ì„± ì •ì˜
    struct TraitCategory has store, drop {
        name: String,
        traits: vector<Trait>,
        rarity_weights: vector<u64>  // ê° íŠ¹ì„±ì˜ í¬ê·€ë„ ê°€ì¤‘ì¹˜
    }
    
    struct Trait has store, drop, copy {
        name: String,
        image: String,
        rarity: u64  // 10000 = 100%
    }
    
    /// ì œë„ˆëŸ¬í‹°ë¸Œ ì„¤ì •
    struct GenerativeConfig has key {
        trait_categories: vector<TraitCategory>,
        total_combinations: u64,
        generated_combinations: SmartTable<vector<u8>, bool>,  // ì¤‘ë³µ ë°©ì§€
        rarity_distribution: SmartTable<u64, u64>  // í¬ê·€ë„ë³„ ê°œìˆ˜
    }
    
    /// ëœë¤ NFT ìƒì„±
    public fun generate_random_nft(
        collection_obj: Object<Collection>,
        seed: vector<u8>
    ): (String, String, vector<(String, String)>) acquires GenerativeConfig {
        let config = borrow_global_mut<GenerativeConfig>(@generative_nft);
        
        let mut attributes = vector::empty();
        let mut combination_hash = vector::empty();
        let mut rarity_score = 0;
        
        let i = 0;
        while (i < vector::length(&config.trait_categories)) {
            let category = vector::borrow(&config.trait_categories, i);
            
            // ê°€ì¤‘ì¹˜ ê¸°ë°˜ ëœë¤ ì„ íƒ
            let selected_trait_index = weighted_random_selection(
                &category.rarity_weights,
                &seed,
                i
            );
            
            let selected_trait = vector::borrow(&category.traits, selected_trait_index);
            
            vector::push_back(&mut attributes, (category.name, selected_trait.name));
            vector::append(&mut combination_hash, string::bytes(&selected_trait.name));
            rarity_score = rarity_score + selected_trait.rarity;
            
            i = i + 1;
        };
        
        // ì¤‘ë³µ ì¡°í•© í™•ì¸
        assert!(
            !smart_table::contains(&config.generated_combinations, combination_hash),
            E_DUPLICATE_COMBINATION
        );
        
        smart_table::add(&mut config.generated_combinations, combination_hash, true);
        
        // í¬ê·€ë„ ê¸°ë°˜ ì´ë¦„ ë° ì„¤ëª… ìƒì„±
        let (name, description) = generate_metadata_by_rarity(rarity_score, &attributes);
        
        (name, description, attributes)
    }
    
    /// ê°€ì¤‘ì¹˜ ê¸°ë°˜ ëœë¤ ì„ íƒ
    fun weighted_random_selection(
        weights: &vector<u64>,
        seed: &vector<u8>,
        salt: u64
    ): u64 {
        let total_weight = vector::fold(weights, 0, |acc, weight| acc + *weight);
        
        // ì‹œë“œì™€ ì†”íŠ¸ë¥¼ ì´ìš©í•œ ì˜ì‚¬ ëœë¤ ìƒì„±
        let random_seed = hash_with_salt(seed, salt);
        let random_value = bytes_to_u64(&random_seed) % total_weight;
        
        let mut cumulative_weight = 0;
        let i = 0;
        while (i < vector::length(weights)) {
            cumulative_weight = cumulative_weight + *vector::borrow(weights, i);
            if (random_value < cumulative_weight) {
                return i
            };
            i = i + 1;
        };
        
        vector::length(weights) - 1
    }
    
    fun generate_metadata_by_rarity(
        rarity_score: u64,
        attributes: &vector<(String, String)>
    ): (String, String) {
        let rarity_tier = if (rarity_score >= 9000) {
            string::utf8(b"Legendary")
        } else if (rarity_score >= 7000) {
            string::utf8(b"Epic")
        } else if (rarity_score >= 5000) {
            string::utf8(b"Rare")
        } else if (rarity_score >= 3000) {
            string::utf8(b"Uncommon")
        } else {
            string::utf8(b"Common")
        };
        
        let name = rarity_tier;
        string::append_utf8(&mut name, b" Art #");
        
        let description = string::utf8(b"A ");
        string::append(&mut description, rarity_tier);
        string::append_utf8(&mut description, b" generative art piece with unique traits.");
        
        (name, description)
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun hash_with_salt(seed: &vector<u8>, salt: u64): vector<u8> {
        let mut combined = *seed;
        let salt_bytes = u64_to_bytes(salt);
        vector::append(&mut combined, salt_bytes);
        
        // ì‹¤ì œë¡œëŠ” cryptographic hash ì‚¬ìš©
        combined  // placeholder
    }
    
    fun bytes_to_u64(bytes: &vector<u8>): u64 {
        // ë°”ì´íŠ¸ ë°°ì—´ì„ u64ë¡œ ë³€í™˜
        if (vector::is_empty(bytes)) return 0;
        
        let mut result = 0;
        let i = 0;
        let len = std::math::min(vector::length(bytes), 8);
        
        while (i < len) {
            let byte = *vector::borrow(bytes, i);
            result = result + ((byte as u64) << (i * 8));
            i = i + 1;
        };
        
        result
    }
    
    fun u64_to_bytes(value: u64): vector<u8> {
        let mut bytes = vector::empty();
        let mut temp = value;
        
        while (temp > 0) {
            vector::push_back(&mut bytes, (temp % 256) as u8);
            temp = temp / 256;
        };
        
        if (vector::is_empty(&bytes)) {
            vector::push_back(&mut bytes, 0);
        };
        
        bytes
    }
    
    const E_DUPLICATE_COMBINATION: u64 = 100;
}
```

### 2. ì§„í™”í˜• NFT (Dynamic NFT)
```move
module dynamic_nft::evolving_character {
    use std::string::String;
    use aptos_framework::timestamp;
    
    /// ì§„í™” ê°€ëŠ¥í•œ ìºë¦­í„° NFT
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct EvolvingCharacter has key {
        // ê¸°ë³¸ ì •ë³´
        name: String,
        class: String,  // "Warrior", "Mage", "Archer" ë“±
        
        // ë ˆë²¨ ì‹œìŠ¤í…œ
        level: u64,
        experience: u64,
        experience_to_next_level: u64,
        
        // ìŠ¤íƒ¯
        strength: u64,
        intelligence: u64,
        agility: u64,
        vitality: u64,
        
        // ì§„í™” ìƒíƒœ
        evolution_stage: u64,  // 0: Basic, 1: Advanced, 2: Master, 3: Legendary
        evolution_requirements: vector<EvolutionRequirement>,
        
        // íšë“í•œ ì•„ì´í…œê³¼ ìŠ¤í‚¬
        equipped_items: vector<Object<GameItem>>,
        learned_skills: vector<String>,
        
        // ì‹œê°„ ê¸°ë°˜ íŠ¹ì„±
        created_at: u64,
        last_activity: u64,
        total_play_time: u64,
        
        // ì„±ì·¨ ë° íˆìŠ¤í† ë¦¬
        achievements: vector<String>,
        battle_history: vector<BattleRecord>,
        
        // ë©”íƒ€ë°ì´í„° (ë³€ê²½ ê°€ëŠ¥)
        current_image: String,
        description: String
    }
    
    struct EvolutionRequirement has store, drop, copy {
        requirement_type: u8,  // 0: level, 1: item, 2: achievement, 3: time
        value: u64,
        description: String,
        is_met: bool
    }
    
    struct BattleRecord has store, drop, copy {
        opponent: address,
        result: u8,  // 0: loss, 1: draw, 2: win
        experience_gained: u64,
        timestamp: u64
    }
    
    /// ê²½í—˜ì¹˜ ì¶”ê°€ ë° ë ˆë²¨ì—… ì²´í¬
    public fun gain_experience(
        owner: &signer,
        character_obj: Object<EvolvingCharacter>,
        exp_amount: u64
    ) acquires EvolvingCharacter {
        let owner_addr = signer::address_of(owner);
        assert!(object::owner(character_obj) == owner_addr, E_NOT_OWNER);
        
        let character_addr = object::object_address(&character_obj);
        let character = borrow_global_mut<EvolvingCharacter>(character_addr);
        
        character.experience = character.experience + exp_amount;
        character.last_activity = timestamp::now_seconds();
        
        // ë ˆë²¨ì—… ì²´í¬
        while (character.experience >= character.experience_to_next_level) {
            level_up(character);
        };
        
        // ì§„í™” ì¡°ê±´ ì²´í¬
        check_evolution_requirements(character);
    }
    
    /// ë ˆë²¨ì—… ì²˜ë¦¬
    fun level_up(character: &mut EvolvingCharacter) {
        character.level = character.level + 1;
        character.experience = character.experience - character.experience_to_next_level;
        character.experience_to_next_level = calculate_next_level_exp(character.level);
        
        // ìŠ¤íƒ¯ ì¦ê°€ (í´ë˜ìŠ¤ë³„ ì°¨ë³„í™”)
        let stat_increases = get_stat_increases_by_class(&character.class);
        character.strength = character.strength + stat_increases.strength;
        character.intelligence = character.intelligence + stat_increases.intelligence;
        character.agility = character.agility + stat_increases.agility;
        character.vitality = character.vitality + stat_increases.vitality;
        
        // íŠ¹ì • ë ˆë²¨ì—ì„œ ìƒˆë¡œìš´ ìŠ¤í‚¬ ìŠµë“
        let new_skills = get_skills_for_level(character.level, &character.class);
        vector::append(&mut character.learned_skills, new_skills);
    }
    
    /// ì§„í™” ì¡°ê±´ í™•ì¸ ë° ì‹¤í–‰
    fun check_evolution_requirements(character: &mut EvolvingCharacter) {
        let mut all_requirements_met = true;
        let current_time = timestamp::now_seconds();
        
        let i = 0;
        while (i < vector::length(&character.evolution_requirements)) {
            let requirement = vector::borrow_mut(&mut character.evolution_requirements, i);
            
            if (!requirement.is_met) {
                match (requirement.requirement_type) {
                    0 => {  // Level requirement
                        if (character.level >= requirement.value) {
                            requirement.is_met = true;
                        }
                    },
                    1 => {  // Item requirement
                        if (has_required_item(character, requirement.value)) {
                            requirement.is_met = true;
                        }
                    },
                    2 => {  // Achievement requirement
                        if (has_achievement(character, &requirement.description)) {
                            requirement.is_met = true;
                        }
                    },
                    3 => {  // Time requirement
                        let time_since_creation = current_time - character.created_at;
                        if (time_since_creation >= requirement.value) {
                            requirement.is_met = true;
                        }
                    },
                    _ => {}
                }
            };
            
            if (!requirement.is_met) {
                all_requirements_met = false;
            };
            
            i = i + 1;
        };
        
        // ëª¨ë“  ì¡°ê±´ì´ ì¶©ì¡±ë˜ë©´ ì§„í™”
        if (all_requirements_met && character.evolution_stage < 3) {
            evolve_character(character);
        }
    }
    
    /// ìºë¦­í„° ì§„í™” ì‹¤í–‰
    fun evolve_character(character: &mut EvolvingCharacter) {
        character.evolution_stage = character.evolution_stage + 1;
        
        // ì§„í™”ì— ë”°ë¥¸ ìŠ¤íƒ¯ ëŒ€í­ ì¦ê°€
        let evolution_bonus = get_evolution_stat_bonus(character.evolution_stage);
        character.strength = character.strength + evolution_bonus.strength;
        character.intelligence = character.intelligence + evolution_bonus.intelligence;
        character.agility = character.agility + evolution_bonus.agility;
        character.vitality = character.vitality + evolution_bonus.vitality;
        
        // ìƒˆë¡œìš´ ì§„í™” ìš”êµ¬ì‚¬í•­ ì„¤ì •
        character.evolution_requirements = get_next_evolution_requirements(character.evolution_stage);
        
        // ì´ë¯¸ì§€ ë° ì„¤ëª… ì—…ë°ì´íŠ¸
        let (new_image, new_description) = get_evolution_metadata(
            &character.class,
            character.evolution_stage
        );
        character.current_image = new_image;
        character.description = new_description;
        
        // ì§„í™” ì„±ì·¨ ì¶”ê°€
        let achievement = get_evolution_achievement_name(character.evolution_stage);
        vector::push_back(&mut character.achievements, achievement);
    }
    
    /// ì „íˆ¬ ì°¸ì—¬ ë° ê²°ê³¼ ê¸°ë¡
    public fun participate_in_battle(
        owner: &signer,
        character_obj: Object<EvolvingCharacter>,
        opponent: address,
        result: u8,
        experience_gained: u64
    ) acquires EvolvingCharacter {
        let owner_addr = signer::address_of(owner);
        assert!(object::owner(character_obj) == owner_addr, E_NOT_OWNER);
        
        let character_addr = object::object_address(&character_obj);
        let character = borrow_global_mut<EvolvingCharacter>(character_addr);
        
        // ì „íˆ¬ ê¸°ë¡ ì¶”ê°€
        let battle_record = BattleRecord {
            opponent,
            result,
            experience_gained,
            timestamp: timestamp::now_seconds()
        };
        vector::push_back(&mut character.battle_history, battle_record);
        
        // ê²½í—˜ì¹˜ íšë“
        gain_experience(owner, character_obj, experience_gained);
        
        // ì „íˆ¬ ê´€ë ¨ ì„±ì·¨ ì²´í¬
        check_battle_achievements(character);
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    struct StatIncrease has drop {
        strength: u64,
        intelligence: u64,
        agility: u64,
        vitality: u64
    }
    
    fun get_stat_increases_by_class(class: &String): StatIncrease {
        if (class == &string::utf8(b"Warrior")) {
            StatIncrease { strength: 3, intelligence: 1, agility: 2, vitality: 2 }
        } else if (class == &string::utf8(b"Mage")) {
            StatIncrease { strength: 1, intelligence: 3, agility: 1, vitality: 2 }
        } else if (class == &string::utf8(b"Archer")) {
            StatIncrease { strength: 2, intelligence: 1, agility: 3, vitality: 2 }
        } else {
            StatIncrease { strength: 2, intelligence: 2, agility: 2, vitality: 2 }
        }
    }
    
    fun calculate_next_level_exp(level: u64): u64 {
        // ë ˆë²¨ì—…ì— í•„ìš”í•œ ê²½í—˜ì¹˜ ê³„ì‚° (ì§€ìˆ˜ì  ì¦ê°€)
        100 + (level * level * 50)
    }
    
    fun get_skills_for_level(level: u64, class: &String): vector<String> {
        let skills = vector::empty();
        
        // íŠ¹ì • ë ˆë²¨ì—ì„œë§Œ ìŠ¤í‚¬ ìŠµë“
        if (level % 5 == 0) {  // 5ë ˆë²¨ë§ˆë‹¤
            if (class == &string::utf8(b"Warrior")) {
                if (level == 5) vector::push_back(&mut skills, string::utf8(b"Power Strike"));
                if (level == 10) vector::push_back(&mut skills, string::utf8(b"Shield Bash"));
                if (level == 15) vector::push_back(&mut skills, string::utf8(b"Berserker Rage"));
            } else if (class == &string::utf8(b"Mage")) {
                if (level == 5) vector::push_back(&mut skills, string::utf8(b"Fireball"));
                if (level == 10) vector::push_back(&mut skills, string::utf8(b"Ice Shard"));
                if (level == 15) vector::push_back(&mut skills, string::utf8(b"Lightning Bolt"));
            }
            // ... ë‹¤ë¥¸ í´ë˜ìŠ¤ë“¤
        };
        
        skills
    }
    
    fun has_required_item(character: &EvolvingCharacter, item_id: u64): bool {
        // ì¥ì°©ëœ ì•„ì´í…œ ì¤‘ì—ì„œ íŠ¹ì • ì•„ì´í…œ í™•ì¸
        // ì‹¤ì œë¡œëŠ” GameItemì˜ ID ì²´í¬ ë¡œì§ í•„ìš”
        !vector::is_empty(&character.equipped_items)  // placeholder
    }
    
    fun has_achievement(character: &EvolvingCharacter, achievement: &String): bool {
        vector::contains(&character.achievements, achievement)
    }
    
    fun get_evolution_stat_bonus(evolution_stage: u64): StatIncrease {
        match (evolution_stage) {
            1 => StatIncrease { strength: 10, intelligence: 10, agility: 10, vitality: 10 },
            2 => StatIncrease { strength: 25, intelligence: 25, agility: 25, vitality: 25 },
            3 => StatIncrease { strength: 50, intelligence: 50, agility: 50, vitality: 50 },
            _ => StatIncrease { strength: 0, intelligence: 0, agility: 0, vitality: 0 }
        }
    }
    
    fun get_next_evolution_requirements(stage: u64): vector<EvolutionRequirement> {
        let requirements = vector::empty();
        
        match (stage) {
            1 => {  // Advanced to Master
                vector::push_back(&mut requirements, EvolutionRequirement {
                    requirement_type: 0,
                    value: 25,
                    description: string::utf8(b"Reach level 25"),
                    is_met: false
                });
                vector::push_back(&mut requirements, EvolutionRequirement {
                    requirement_type: 2,
                    value: 0,
                    description: string::utf8(b"Win 10 battles"),
                    is_met: false
                });
            },
            2 => {  // Master to Legendary
                vector::push_back(&mut requirements, EvolutionRequirement {
                    requirement_type: 0,
                    value: 50,
                    description: string::utf8(b"Reach level 50"),
                    is_met: false
                });
                vector::push_back(&mut requirements, EvolutionRequirement {
                    requirement_type: 3,
                    value: 2592000, // 30 days
                    description: string::utf8(b"30 days since creation"),
                    is_met: false
                });
            },
            _ => {}
        };
        
        requirements
    }
    
    fun get_evolution_metadata(class: &String, stage: u64): (String, String) {
        let stage_name = if (stage == 1) {
            string::utf8(b"Advanced")
        } else if (stage == 2) {
            string::utf8(b"Master")
        } else if (stage == 3) {
            string::utf8(b"Legendary")
        } else {
            string::utf8(b"Basic")
        };
        
        let image = string::utf8(b"https://nft.example.com/images/");
        string::append(&mut image, *class);
        string::append_utf8(&mut image, b"_");
        string::append(&mut image, stage_name);
        string::append_utf8(&mut image, b".png");
        
        let description = string::utf8(b"A ");
        string::append(&mut description, stage_name);
        string::append_utf8(&mut description, b" ");
        string::append(&mut description, *class);
        string::append_utf8(&mut description, b" that has evolved through battles and experience.");
        
        (image, description)
    }
    
    fun get_evolution_achievement_name(stage: u64): String {
        match (stage) {
            1 => string::utf8(b"First Evolution"),
            2 => string::utf8(b"Master Warrior"),
            3 => string::utf8(b"Legendary Hero"),
            _ => string::utf8(b"Basic Achievement")
        }
    }
    
    fun check_battle_achievements(character: &mut EvolvingCharacter) {
        let wins = count_battle_wins(&character.battle_history);
        
        if (wins >= 10 && !has_achievement(character, &string::utf8(b"Win 10 battles"))) {
            vector::push_back(&mut character.achievements, string::utf8(b"Win 10 battles"));
        };
        
        if (wins >= 50 && !has_achievement(character, &string::utf8(b"Battle Veteran"))) {
            vector::push_back(&mut character.achievements, string::utf8(b"Battle Veteran"));
        };
        
        if (wins >= 100 && !has_achievement(character, &string::utf8(b"War Champion"))) {
            vector::push_back(&mut character.achievements, string::utf8(b"War Champion"));
        };
    }
    
    fun count_battle_wins(battle_history: &vector<BattleRecord>): u64 {
        let mut wins = 0;
        let i = 0;
        
        while (i < vector::length(battle_history)) {
            let record = vector::borrow(battle_history, i);
            if (record.result == 2) {  // win = 2
                wins = wins + 1;
            };
            i = i + 1;
        };
        
        wins
    }
    
    const E_NOT_OWNER: u64 = 1;
}
```

### 3. ìœ í‹¸ë¦¬í‹° NFT (Membership & Access)
```move
module utility_nft::membership_pass {
    use std::string::{Self, String};
    use std::vector;
    use aptos_framework::timestamp;
    use aptos_std::smart_table::{Self, SmartTable};
    
    /// ë©¤ë²„ì‹­ íŒ¨ìŠ¤ NFT
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MembershipPass has key {
        // ë©¤ë²„ì‹­ ì •ë³´
        tier: String,  // "Bronze", "Silver", "Gold", "Platinum"
        tier_level: u8,  // 1, 2, 3, 4
        
        // ìœ íš¨ ê¸°ê°„
        issued_at: u64,
        expires_at: Option<u64>,  // Noneì´ë©´ í‰ìƒ ë©¤ë²„ì‹­
        last_used: u64,
        
        // í˜œíƒ ë° ê¶Œí•œ
        benefits: SmartTable<String, BenefitInfo>,
        access_level: u64,  // ì ‘ê·¼ ê¶Œí•œ ë ˆë²¨
        
        // ì‚¬ìš© í†µê³„
        total_usage_count: u64,
        monthly_usage_count: u64,
        last_reset_month: u64,
        
        // í¬ì¸íŠ¸ ì‹œìŠ¤í…œ
        loyalty_points: u64,
        lifetime_points: u64,
        
        // íŠ¹ë³„ ê¶Œí•œ
        special_privileges: vector<String>,
        referral_code: String,
        referred_by: Option<address>
    }
    
    struct BenefitInfo has store, drop, copy {
        benefit_type: String,
        usage_limit: Option<u64>,
        current_usage: u64,
        discount_percentage: u64,  // basis points
        description: String
    }
    
    /// ë©¤ë²„ì‹­ íŒ¨ìŠ¤ ë°œê¸‰
    public fun mint_membership_pass(
        issuer: &signer,
        to: address,
        tier: String,
        expires_at: Option<u64>
    ): Object<MembershipPass> {
        let issuer_addr = signer::address_of(issuer);
        
        // í‹°ì–´ ë ˆë²¨ ê²°ì •
        let tier_level = get_tier_level(&tier);
        assert!(tier_level > 0, E_INVALID_TIER);
        
        // Object ìƒì„±
        let constructor_ref = object::create_object(issuer_addr);
        let object_signer = object::generate_signer(&constructor_ref);
        
        let current_time = timestamp::now_seconds();
        let referral_code = generate_referral_code(to, current_time);
        
        let membership = MembershipPass {
            tier,
            tier_level,
            issued_at: current_time,
            expires_at,
            last_used: 0,
            benefits: create_tier_benefits(tier_level),
            access_level: tier_level * 25, // 25, 50, 75, 100
            total_usage_count: 0,
            monthly_usage_count: 0,
            last_reset_month: get_current_month(),
            loyalty_points: 0,
            lifetime_points: 0,
            special_privileges: get_tier_privileges(tier_level),
            referral_code,
            referred_by: option::none()
        };
        
        move_to(&object_signer, membership);
        
        // ì†Œìœ ê¶Œì„ 'to' ì£¼ì†Œë¡œ ì„¤ì •
        let linear_transfer_ref = object::generate_linear_transfer_ref(&constructor_ref);
        object::transfer_with_ref(linear_transfer_ref, to);
        
        object::object_from_constructor_ref<MembershipPass>(&constructor_ref)
    }
    
    /// ë©¤ë²„ì‹­ í˜œíƒ ì‚¬ìš©
    public fun use_benefit(
        user: &signer,
        membership_obj: Object<MembershipPass>,
        benefit_type: String,
        usage_amount: u64
    ): (bool, u64) acquires MembershipPass {
        let user_addr = signer::address_of(user);
        assert!(object::owner(membership_obj) == user_addr, E_NOT_OWNER);
        
        let membership_addr = object::object_address(&membership_obj);
        let membership = borrow_global_mut<MembershipPass>(membership_addr);
        
        // ë§Œë£Œ í™•ì¸
        assert!(is_membership_valid(membership), E_MEMBERSHIP_EXPIRED);
        
        // ì›”ë³„ ì‚¬ìš©ëŸ‰ ë¦¬ì…‹ ì²´í¬
        let current_month = get_current_month();
        if (current_month != membership.last_reset_month) {
            membership.monthly_usage_count = 0;
            membership.last_reset_month = current_month;
        };
        
        // í˜œíƒ ì¡´ì¬ í™•ì¸
        assert!(
            smart_table::contains(&membership.benefits, benefit_type),
            E_BENEFIT_NOT_AVAILABLE
        );
        
        let benefit = smart_table::borrow_mut(&mut membership.benefits, benefit_type);
        
        // ì‚¬ìš© í•œë„ í™•ì¸
        if (option::is_some(&benefit.usage_limit)) {
            let limit = *option::borrow(&benefit.usage_limit);
            assert!(benefit.current_usage + usage_amount <= limit, E_USAGE_LIMIT_EXCEEDED);
        };
        
        // í˜œíƒ ì‚¬ìš© ì²˜ë¦¬
        benefit.current_usage = benefit.current_usage + usage_amount;
        membership.total_usage_count = membership.total_usage_count + usage_amount;
        membership.monthly_usage_count = membership.monthly_usage_count + usage_amount;
        membership.last_used = timestamp::now_seconds();
        
        // ë¡œì—´í‹° í¬ì¸íŠ¸ ì ë¦½
        let points_earned = calculate_loyalty_points(membership.tier_level, usage_amount);
        membership.loyalty_points = membership.loyalty_points + points_earned;
        membership.lifetime_points = membership.lifetime_points + points_earned;
        
        (true, benefit.discount_percentage)
    }
    
    /// ë©¤ë²„ì‹­ ì—…ê·¸ë ˆì´ë“œ
    public fun upgrade_membership(
        upgrader: &signer,
        membership_obj: Object<MembershipPass>,
        new_tier: String
    ) acquires MembershipPass {
        let upgrader_addr = signer::address_of(upgrader);
        assert!(object::owner(membership_obj) == upgrader_addr, E_NOT_OWNER);
        
        let membership_addr = object::object_address(&membership_obj);
        let membership = borrow_global_mut<MembershipPass>(membership_addr);
        
        let new_tier_level = get_tier_level(&new_tier);
        assert!(new_tier_level > membership.tier_level, E_INVALID_UPGRADE);
        
        // ì—…ê·¸ë ˆì´ë“œ ìê²© í™•ì¸ (í¬ì¸íŠ¸ ê¸°ë°˜)
        let required_points = get_upgrade_required_points(new_tier_level);
        assert!(membership.loyalty_points >= required_points, E_INSUFFICIENT_POINTS);
        
        // í¬ì¸íŠ¸ ì°¨ê°
        membership.loyalty_points = membership.loyalty_points - required_points;
        
        // í‹°ì–´ ì—…ê·¸ë ˆì´ë“œ
        membership.tier = new_tier;
        membership.tier_level = new_tier_level;
        membership.access_level = new_tier_level * 25;
        
        // ìƒˆë¡œìš´ í˜œíƒìœ¼ë¡œ ì—…ë°ì´íŠ¸
        membership.benefits = create_tier_benefits(new_tier_level);
        membership.special_privileges = get_tier_privileges(new_tier_level);
    }
    
    /// ì¶”ì²œ ì‹œìŠ¤í…œ
    public fun refer_new_member(
        referrer: &signer,
        membership_obj: Object<MembershipPass>,
        new_member: address
    ): String acquires MembershipPass {
        let referrer_addr = signer::address_of(referrer);
        assert!(object::owner(membership_obj) == referrer_addr, E_NOT_OWNER);
        
        let membership_addr = object::object_address(&membership_obj);
        let membership = borrow_global_mut<MembershipPass>(membership_addr);
        
        // ì¶”ì²œ ë³´ìƒ ì§€ê¸‰
        let referral_bonus = get_referral_bonus(membership.tier_level);
        membership.loyalty_points = membership.loyalty_points + referral_bonus;
        
        membership.referral_code
    }
    
    /// ë©¤ë²„ì‹­ ìƒíƒœ ì¡°íšŒ
    public fun get_membership_status(
        membership_obj: Object<MembershipPass>
    ): MembershipStatus acquires MembershipPass {
        let membership_addr = object::object_address(&membership_obj);
        let membership = borrow_global<MembershipPass>(membership_addr);
        
        MembershipStatus {
            tier: membership.tier,
            tier_level: membership.tier_level,
            is_valid: is_membership_valid(membership),
            expires_at: membership.expires_at,
            access_level: membership.access_level,
            loyalty_points: membership.loyalty_points,
            lifetime_points: membership.lifetime_points,
            total_usage: membership.total_usage_count,
            monthly_usage: membership.monthly_usage_count,
            available_benefits: get_available_benefits(&membership.benefits),
            special_privileges: membership.special_privileges
        }
    }
    
    struct MembershipStatus has drop {
        tier: String,
        tier_level: u8,
        is_valid: bool,
        expires_at: Option<u64>,
        access_level: u64,
        loyalty_points: u64,
        lifetime_points: u64,
        total_usage: u64,
        monthly_usage: u64,
        available_benefits: vector<String>,
        special_privileges: vector<String>
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun get_tier_level(tier: &String): u8 {
        if (tier == &string::utf8(b"Bronze")) 1
        else if (tier == &string::utf8(b"Silver")) 2
        else if (tier == &string::utf8(b"Gold")) 3
        else if (tier == &string::utf8(b"Platinum")) 4
        else 0
    }
    
    fun create_tier_benefits(tier_level: u8): SmartTable<String, BenefitInfo> {
        let benefits = smart_table::new();
        
        match (tier_level) {
            1 => {  // Bronze
                smart_table::add(&mut benefits, string::utf8(b"discount"), BenefitInfo {
                    benefit_type: string::utf8(b"discount"),
                    usage_limit: option::some(5),
                    current_usage: 0,
                    discount_percentage: 500, // 5%
                    description: string::utf8(b"5% discount on purchases")
                });
            },
            2 => {  // Silver
                smart_table::add(&mut benefits, string::utf8(b"discount"), BenefitInfo {
                    benefit_type: string::utf8(b"discount"),
                    usage_limit: option::some(10),
                    current_usage: 0,
                    discount_percentage: 1000, // 10%
                    description: string::utf8(b"10% discount on purchases")
                });
                smart_table::add(&mut benefits, string::utf8(b"early_access"), BenefitInfo {
                    benefit_type: string::utf8(b"early_access"),
                    usage_limit: option::none(),
                    current_usage: 0,
                    discount_percentage: 0,
                    description: string::utf8(b"Early access to new features")
                });
            },
            3 => {  // Gold
                smart_table::add(&mut benefits, string::utf8(b"discount"), BenefitInfo {
                    benefit_type: string::utf8(b"discount"),
                    usage_limit: option::some(20),
                    current_usage: 0,
                    discount_percentage: 1500, // 15%
                    description: string::utf8(b"15% discount on purchases")
                });
                smart_table::add(&mut benefits, string::utf8(b"priority_support"), BenefitInfo {
                    benefit_type: string::utf8(b"priority_support"),
                    usage_limit: option::none(),
                    current_usage: 0,
                    discount_percentage: 0,
                    description: string::utf8(b"Priority customer support")
                });
            },
            4 => {  // Platinum
                smart_table::add(&mut benefits, string::utf8(b"discount"), BenefitInfo {
                    benefit_type: string::utf8(b"discount"),
                    usage_limit: option::none(),
                    current_usage: 0,
                    discount_percentage: 2000, // 20%
                    description: string::utf8(b"20% discount on all purchases")
                });
                smart_table::add(&mut benefits, string::utf8(b"exclusive_access"), BenefitInfo {
                    benefit_type: string::utf8(b"exclusive_access"),
                    usage_limit: option::none(),
                    current_usage: 0,
                    discount_percentage: 0,
                    description: string::utf8(b"Exclusive access to premium features")
                });
            },
            _ => {}
        };
        
        benefits
    }
    
    fun get_tier_privileges(tier_level: u8): vector<String> {
        let privileges = vector::empty();
        
        match (tier_level) {
            1 => {
                vector::push_back(&mut privileges, string::utf8(b"basic_features"));
            },
            2 => {
                vector::push_back(&mut privileges, string::utf8(b"basic_features"));
                vector::push_back(&mut privileges, string::utf8(b"early_access"));
            },
            3 => {
                vector::push_back(&mut privileges, string::utf8(b"basic_features"));
                vector::push_back(&mut privileges, string::utf8(b"early_access"));
                vector::push_back(&mut privileges, string::utf8(b"priority_support"));
                vector::push_back(&mut privileges, string::utf8(b"api_access"));
            },
            4 => {
                vector::push_back(&mut privileges, string::utf8(b"basic_features"));
                vector::push_back(&mut privileges, string::utf8(b"early_access"));
                vector::push_back(&mut privileges, string::utf8(b"priority_support"));
                vector::push_back(&mut privileges, string::utf8(b"api_access"));
                vector::push_back(&mut privileges, string::utf8(b"exclusive_events"));
                vector::push_back(&mut privileges, string::utf8(b"white_glove_service"));
            },
            _ => {}
        };
        
        privileges
    }
    
    fun is_membership_valid(membership: &MembershipPass): bool {
        if (option::is_some(&membership.expires_at)) {
            let expires_at = *option::borrow(&membership.expires_at);
            timestamp::now_seconds() <= expires_at
        } else {
            true  // í‰ìƒ ë©¤ë²„ì‹­
        }
    }
    
    fun get_current_month(): u64 {
        // í˜„ì¬ ì›”ì„ ê³„ì‚° (1970ë…„ 1ì›”ë¶€í„° ê²½ê³¼í•œ ì›” ìˆ˜)
        timestamp::now_seconds() / (30 * 24 * 3600)  // ëŒ€ëµì ì¸ ì›” ê³„ì‚°
    }
    
    fun calculate_loyalty_points(tier_level: u8, usage_amount: u64): u64 {
        let multiplier = match (tier_level) {
            1 => 1,
            2 => 2,
            3 => 3,
            4 => 5,
            _ => 1
        };
        
        usage_amount * multiplier
    }
    
    fun get_upgrade_required_points(tier_level: u8): u64 {
        match (tier_level) {
            2 => 1000,   // Bronze to Silver
            3 => 5000,   // Silver to Gold
            4 => 15000,  // Gold to Platinum
            _ => 0
        }
    }
    
    fun get_referral_bonus(tier_level: u8): u64 {
        match (tier_level) {
            1 => 100,
            2 => 250,
            3 => 500,
            4 => 1000,
            _ => 50
        }
    }
    
    fun generate_referral_code(user: address, timestamp: u64): String {
        // ì‚¬ìš©ì ì£¼ì†Œì™€ íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ì¡°í•©í•´ ê³ ìœ  ì½”ë“œ ìƒì„±
        let addr_bytes = bcs::to_bytes(&user);
        let time_bytes = bcs::to_bytes(&timestamp);
        
        // ê°„ë‹¨í•œ í•´ì‹± (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ë¡œì§ í•„ìš”)
        let hash = vector::length(&addr_bytes) + vector::length(&time_bytes) + timestamp;
        
        let code = string::utf8(b"REF");
        let hash_str = u64_to_string(hash % 1000000); // 6ìë¦¬ ìˆ«ì
        string::append(&mut code, hash_str);
        
        code
    }
    
    fun get_available_benefits(benefits: &SmartTable<String, BenefitInfo>): vector<String> {
        let available = vector::empty();
        
        smart_table::for_each_ref(benefits, |benefit_type, benefit_info| {
            if (option::is_none(&benefit_info.usage_limit) || 
                benefit_info.current_usage < *option::borrow(&benefit_info.usage_limit)) {
                vector::push_back(&mut available, *benefit_type);
            }
        });
        
        available
    }
    
    fun u64_to_string(value: u64): String {
        if (value == 0) {
            return string::utf8(b"0")
        };
        
        let digits = vector::empty();
        let mut temp = value;
        
        while (temp > 0) {
            let digit = (temp % 10) as u8;
            vector::push_back(&mut digits, digit + 48); // ASCII '0' = 48
            temp = temp / 10;
        };
        
        vector::reverse(&mut digits);
        string::utf8(digits)
    }
    
    // ì—ëŸ¬ ì½”ë“œ
    const E_INVALID_TIER: u64 = 1;
    const E_NOT_OWNER: u64 = 2;
    const E_MEMBERSHIP_EXPIRED: u64 = 3;
    const E_BENEFIT_NOT_AVAILABLE: u64 = 4;
    const E_USAGE_LIMIT_EXCEEDED: u64 = 5;
    const E_INVALID_UPGRADE: u64 = 6;
    const E_INSUFFICIENT_POINTS: u64 = 7;
}
```

## ğŸ¯ NFT ì„¤ê³„ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### í™•ì¥ ê°€ëŠ¥í•œ ì„¤ê³„ ì›ì¹™
```move
// âœ… ì¢‹ì€ ì˜ˆ: í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°
module scalable_nft::base {
    use aptos_std::smart_table::{Self, SmartTable};
    
    struct BaseNFT has key {
        // í•µì‹¬ ë°ì´í„°
        core_data: CoreData,
        
        // í™•ì¥ ê°€ëŠ¥í•œ ë©”íƒ€ë°ì´í„°
        extended_attributes: SmartTable<String, AttributeValue>,
        
        // ë²„ì „ ê´€ë¦¬
        schema_version: u64,
        
        // ì—…ê·¸ë ˆì´ë“œ ì§€ì›
        upgrade_capability: Option<UpgradeCapability>
    }
    
    struct AttributeValue has store, drop, copy {
        value_type: u8,  // 0: string, 1: number, 2: boolean, 3: vector
        string_value: Option<String>,
        number_value: Option<u64>,
        boolean_value: Option<bool>,
        vector_value: Option<vector<u8>>
    }
}

// âŒ ë‚˜ìœ ì˜ˆ: ê³ ì •ëœ êµ¬ì¡°
module fixed_nft::example {
    struct FixedNFT has key {
        name: String,
        description: String,
        // ìƒˆë¡œìš´ ì†ì„± ì¶”ê°€ê°€ ì–´ë ¤ì›€
        // ì—…ê·¸ë ˆì´ë“œ ë¶ˆê°€ëŠ¥
    }
}
```

### ê°€ìŠ¤ íš¨ìœ¨ì ì¸ íŒ¨í„´
```move
// âœ… ê°€ìŠ¤ ìµœì í™” íŒ¨í„´
public fun batch_mint_optimized(
    creator: &signer,
    collection_obj: Object<Collection>,
    mint_data: vector<MintData>
) {
    // ì‚¬ì „ ê²€ì¦ì„ í•œ ë²ˆì— ìˆ˜í–‰
    validate_batch_mint_preconditions(&mint_data, collection_obj);
    
    // ë°°ì¹˜ ì²˜ë¦¬ë¡œ ë°˜ë³µ ì‘ì—… ìµœì†Œí™”
    let i = 0;
    let len = vector::length(&mint_data);
    
    while (i < len) {
        let data = vector::borrow(&mint_data, i);
        mint_single_optimized(creator, collection_obj, data);
        i = i + 1;
    };
    
    // ì´ë²¤íŠ¸ë¥¼ ë§ˆì§€ë§‰ì— í•œ ë²ˆì— ë°œìƒ
    emit_batch_mint_event(len);
}

// âŒ ê°€ìŠ¤ ë¹„íš¨ìœ¨ì ì¸ íŒ¨í„´
public fun individual_mint_calls(
    creator: &signer,
    collection_obj: Object<Collection>,
    mint_data: vector<MintData>
) {
    let i = 0;
    while (i < vector::length(&mint_data)) {
        let data = vector::borrow(&mint_data, i);
        // ë§¤ë²ˆ ê°œë³„ ê²€ì¦ê³¼ ì´ë²¤íŠ¸ ë°œìƒ - ê°€ìŠ¤ ë‚­ë¹„
        mint_nft_individual(creator, collection_obj, data);
        i = i + 1;
    }
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

NFT ê°œë…ê³¼ ì»¬ë ‰ì…˜ ì„¤ê³„ë¥¼ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[Token Standard & Metadata â†’](/dapp-development/nft-development/token-standard-metadata)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement NFT í‘œì¤€](https://docs.movementnetwork.xyz/nft-standard)
- [Object ëª¨ë¸ ê°€ì´ë“œ](https://docs.movementnetwork.xyz/objects)
- [NFT ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤](https://docs.movementnetwork.xyz/nft-best-practices)

---

*Movement Networkì—ì„œ í˜ì‹ ì ì´ê³  í™•ì¥ ê°€ëŠ¥í•œ NFT ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ¨âš¡*