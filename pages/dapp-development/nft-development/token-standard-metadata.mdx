# ğŸ“‹ Token Standard & Metadata

Movement Networkì˜ NFT í‘œì¤€ê³¼ ë©”íƒ€ë°ì´í„° ì‹œìŠ¤í…œì„ ì™„ì „íˆ ë§ˆìŠ¤í„°í•˜ëŠ” ê°€ì´ë“œì…ë‹ˆë‹¤. íš¨ìœ¨ì ì¸ ë©”íƒ€ë°ì´í„° ê´€ë¦¬ë¶€í„° IPFS í†µí•©ê¹Œì§€, í”„ë¡œë•ì…˜ ë ˆë²¨ì˜ NFT ì‹œìŠ¤í…œ êµ¬ì¶• ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- Movement Token Standardì˜ ëª¨ë“  ê¸°ëŠ¥ì„ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ìµœì í™”ëœ JSON ë©”íƒ€ë°ì´í„° ìŠ¤í‚¤ë§ˆë¥¼ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- IPFSì™€ ë¶„ì‚° ì €ì¥ ì‹œìŠ¤í…œì„ í†µí•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì˜¨ì²´ì¸ê³¼ ì˜¤í”„ì²´ì¸ ë©”íƒ€ë°ì´í„° ì „ëµì„ ê²°ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸ì™€ ë²„ì „ ê´€ë¦¬ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ—ï¸ Movement Token Standard ì‹¬í™”

### Token Standard ì•„í‚¤í…ì²˜
```move
module movement_token::digital_asset {
    use std::string::{Self, String};
    use std::option::{Self, Option};
    use aptos_framework::object::{Self, Object, ConstructorRef, DeleteRef};
    use aptos_token_objects::collection::{Self, Collection};
    use aptos_token_objects::token::{Self, Token};
    use aptos_token_objects::property_map::{Self, PropertyMap};
    use aptos_token_objects::royalty::{Self, Royalty};
    
    /// Movement Tokenì˜ í™•ì¥ëœ êµ¬ì¡°
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct MovementToken has key {
        // ê¸°ë³¸ ë©”íƒ€ë°ì´í„°
        name: String,
        description: String,
        uri: String,
        
        // í™•ì¥ ì†ì„±
        properties: PropertyMap,
        
        // ë²„ì „ ê´€ë¦¬
        metadata_version: u64,
        schema_version: String,
        
        // ì—…ë°ì´íŠ¸ ì´ë ¥
        update_history: vector<MetadataUpdate>,
        
        // ì ‘ê·¼ ì œì–´
        mutability_config: TokenMutabilityConfig,
        
        // ì¶”ê°€ ê¸°ëŠ¥
        utility_functions: vector<String>,
        interaction_count: u64,
        last_interaction: u64
    }
    
    /// ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸ ê¸°ë¡
    struct MetadataUpdate has store, drop, copy {
        field_name: String,
        old_value: String,
        new_value: String,
        updated_by: address,
        timestamp: u64,
        reason: String
    }
    
    /// í† í° ê°€ë³€ì„± ì„¤ì •
    struct TokenMutabilityConfig has store, drop, copy {
        description_mutable: bool,
        uri_mutable: bool,
        properties_mutable: bool,
        royalty_mutable: bool,
        
        // ì œí•œëœ ê°€ë³€ì„±
        mutation_limit: Option<u64>,
        current_mutations: u64,
        
        // ê¶Œí•œ ê¸°ë°˜ ë³€ê²½
        authorized_mutators: vector<address>
    }
    
    /// í‘œì¤€ í˜¸í™˜ í† í° ìƒì„±
    public fun create_standard_token(
        creator: &signer,
        collection: Object<Collection>,
        name: String,
        description: String,
        uri: String,
        properties: PropertyMap,
        royalty: Option<Royalty>,
        mutability_config: TokenMutabilityConfig
    ): Object<MovementToken> {
        let creator_addr = signer::address_of(creator);
        
        // ê¸°ë³¸ í† í° ìƒì„± (Aptos Token Objects ì‚¬ìš©)
        let constructor_ref = token::create_named_token(
            creator,
            collection::name(collection),
            description,
            name,
            royalty,
            uri
        );
        
        let token_signer = object::generate_signer(&constructor_ref);
        
        // í™•ì¥ëœ MovementToken ë¦¬ì†ŒìŠ¤ ì¶”ê°€
        let movement_token = MovementToken {
            name,
            description,
            uri,
            properties,
            metadata_version: 1,
            schema_version: string::utf8(b"1.0.0"),
            update_history: vector::empty(),
            mutability_config,
            utility_functions: vector::empty(),
            interaction_count: 0,
            last_interaction: timestamp::now_seconds()
        };
        
        move_to(&token_signer, movement_token);
        
        // ì†ì„± ì„¤ì • (í‘œì¤€ í˜¸í™˜)
        if (!property_map::is_empty(&properties)) {
            token::add_property(&constructor_ref, properties);
        };
        
        object::object_from_constructor_ref<MovementToken>(&constructor_ref)
    }
    
    /// ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸ (ê¶Œí•œ í™•ì¸ í¬í•¨)
    public fun update_token_metadata(
        updater: &signer,
        token_obj: Object<MovementToken>,
        field: String,
        new_value: String,
        reason: String
    ) acquires MovementToken {
        let updater_addr = signer::address_of(updater);
        let token_addr = object::object_address(&token_obj);
        let token = borrow_global_mut<MovementToken>(token_addr);
        
        // ê¶Œí•œ í™•ì¸
        assert!(
            vector::contains(&token.mutability_config.authorized_mutators, &updater_addr) ||
            object::owner(token_obj) == updater_addr,
            E_NOT_AUTHORIZED_TO_UPDATE
        );
        
        // ê°€ë³€ì„± í™•ì¸
        assert!(is_field_mutable(&token.mutability_config, &field), E_FIELD_NOT_MUTABLE);
        
        // ë³€ê²½ íšŸìˆ˜ ì œí•œ í™•ì¸
        if (option::is_some(&token.mutability_config.mutation_limit)) {
            let limit = *option::borrow(&token.mutability_config.mutation_limit);
            assert!(token.mutability_config.current_mutations < limit, E_MUTATION_LIMIT_EXCEEDED);
        };
        
        // ê¸°ì¡´ ê°’ ì €ì¥
        let old_value = get_field_value(token, &field);
        
        // ìƒˆ ê°’ ì„¤ì •
        set_field_value(token, &field, &new_value);
        
        // ì—…ë°ì´íŠ¸ ê¸°ë¡ ì¶”ê°€
        let update_record = MetadataUpdate {
            field_name: field,
            old_value,
            new_value,
            updated_by: updater_addr,
            timestamp: timestamp::now_seconds(),
            reason
        };
        
        vector::push_back(&mut token.update_history, update_record);
        token.mutability_config.current_mutations = token.mutability_config.current_mutations + 1;
        token.metadata_version = token.metadata_version + 1;
    }
    
    /// ë°°ì¹˜ ì†ì„± ì—…ë°ì´íŠ¸
    public fun batch_update_properties(
        updater: &signer,
        token_obj: Object<MovementToken>,
        property_updates: vector<(String, PropertyValue)>,
        reason: String
    ) acquires MovementToken {
        let updater_addr = signer::address_of(updater);
        let token_addr = object::object_address(&token_obj);
        let token = borrow_global_mut<MovementToken>(token_addr);
        
        // ê¶Œí•œ í™•ì¸
        assert!(
            vector::contains(&token.mutability_config.authorized_mutators, &updater_addr) ||
            object::owner(token_obj) == updater_addr,
            E_NOT_AUTHORIZED_TO_UPDATE
        );
        
        assert!(token.mutability_config.properties_mutable, E_PROPERTIES_NOT_MUTABLE);
        
        let i = 0;
        while (i < vector::length(&property_updates)) {
            let (key, value) = *vector::borrow(&property_updates, i);
            
            // ê¸°ì¡´ ê°’ ê°€ì ¸ì˜¤ê¸°
            let old_value = if (property_map::contains_key(&token.properties, &key)) {
                property_value_to_string(property_map::read(&token.properties, &key))
            } else {
                string::utf8(b"")
            };
            
            // ìƒˆ ê°’ ì„¤ì •
            property_map::add(&mut token.properties, key, value);
            
            // ì—…ë°ì´íŠ¸ ê¸°ë¡
            let update_record = MetadataUpdate {
                field_name: key,
                old_value,
                new_value: property_value_to_string(&value),
                updated_by: updater_addr,
                timestamp: timestamp::now_seconds(),
                reason
            };
            
            vector::push_back(&mut token.update_history, update_record);
            i = i + 1;
        };
        
        token.metadata_version = token.metadata_version + 1;
    }
    
    /// í† í° ìƒí˜¸ì‘ìš© ê¸°ë¡
    public fun record_interaction(
        user: &signer,
        token_obj: Object<MovementToken>,
        interaction_type: String
    ) acquires MovementToken {
        let token_addr = object::object_address(&token_obj);
        let token = borrow_global_mut<MovementToken>(token_addr);
        
        token.interaction_count = token.interaction_count + 1;
        token.last_interaction = timestamp::now_seconds();
        
        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ì— ìƒí˜¸ì‘ìš© íƒ€ì… ì¶”ê°€ (ì¤‘ë³µ ì œê±°)
        if (!vector::contains(&token.utility_functions, &interaction_type)) {
            vector::push_back(&mut token.utility_functions, interaction_type);
        };
    }
    
    /// í† í° ì •ë³´ ì¡°íšŒ
    public fun get_token_info(token_obj: Object<MovementToken>): TokenInfo acquires MovementToken {
        let token_addr = object::object_address(&token_obj);
        let token = borrow_global<MovementToken>(token_addr);
        
        TokenInfo {
            name: token.name,
            description: token.description,
            uri: token.uri,
            owner: object::owner(token_obj),
            creator: token::creator(token_obj),
            collection: token::collection_object(token_obj),
            metadata_version: token.metadata_version,
            schema_version: token.schema_version,
            interaction_count: token.interaction_count,
            last_interaction: token.last_interaction,
            update_count: vector::length(&token.update_history),
            utility_functions: token.utility_functions,
            is_mutable: is_token_mutable(&token.mutability_config)
        }
    }
    
    struct TokenInfo has drop {
        name: String,
        description: String,
        uri: String,
        owner: address,
        creator: address,
        collection: Object<Collection>,
        metadata_version: u64,
        schema_version: String,
        interaction_count: u64,
        last_interaction: u64,
        update_count: u64,
        utility_functions: vector<String>,
        is_mutable: bool
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    fun is_field_mutable(config: &TokenMutabilityConfig, field: &String): bool {
        if (field == &string::utf8(b"description")) {
            config.description_mutable
        } else if (field == &string::utf8(b"uri")) {
            config.uri_mutable
        } else if (field == &string::utf8(b"properties")) {
            config.properties_mutable
        } else {
            false
        }
    }
    
    fun get_field_value(token: &MovementToken, field: &String): String {
        if (field == &string::utf8(b"description")) {
            token.description
        } else if (field == &string::utf8(b"uri")) {
            token.uri
        } else if (field == &string::utf8(b"name")) {
            token.name
        } else {
            string::utf8(b"")
        }
    }
    
    fun set_field_value(token: &mut MovementToken, field: &String, value: &String) {
        if (field == &string::utf8(b"description")) {
            token.description = *value;
        } else if (field == &string::utf8(b"uri")) {
            token.uri = *value;
        }
        // nameì€ ë¶ˆë³€
    }
    
    fun is_token_mutable(config: &TokenMutabilityConfig): bool {
        config.description_mutable || config.uri_mutable || config.properties_mutable
    }
    
    fun property_value_to_string(value: &PropertyValue): String {
        // PropertyValueë¥¼ Stringìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ë¡œì§
        // ì‹¤ì œë¡œëŠ” PropertyValueì˜ íƒ€ì…ì— ë”°ë¼ ì ì ˆíˆ ë³€í™˜
        string::utf8(b"property_value")  // placeholder
    }
    
    // ì—ëŸ¬ ì½”ë“œ
    const E_NOT_AUTHORIZED_TO_UPDATE: u64 = 1;
    const E_FIELD_NOT_MUTABLE: u64 = 2;
    const E_MUTATION_LIMIT_EXCEEDED: u64 = 3;
    const E_PROPERTIES_NOT_MUTABLE: u64 = 4;
}
```

## ğŸ“„ JSON ë©”íƒ€ë°ì´í„° ìŠ¤í‚¤ë§ˆ ì„¤ê³„

### OpenSea í˜¸í™˜ í‘œì¤€ ë©”íƒ€ë°ì´í„°
```typescript
// Movement NFT ë©”íƒ€ë°ì´í„° í‘œì¤€ ìŠ¤í‚¤ë§ˆ
interface MovementNFTMetadata {
  // í•„ìˆ˜ í•„ë“œ
  name: string;
  description: string;
  image: string;
  
  // í™•ì¥ í•„ë“œ
  external_url?: string;
  animation_url?: string;
  youtube_url?: string;
  
  // ì†ì„± (OpenSea í˜¸í™˜)
  attributes: Array<{
    trait_type: string;
    value: string | number;
    display_type?: "number" | "date" | "boost_number" | "boost_percentage";
    max_value?: number;
  }>;
  
  // Movement íŠ¹í™” í•„ë“œ
  movement_metadata: {
    schema_version: string;
    created_at: number;
    updated_at: number;
    creator: string;
    collection: string;
    token_standard: "movement-nft-v1";
    
    // ë™ì  ì†ì„±
    dynamic_attributes?: Array<{
      name: string;
      type: "string" | "number" | "boolean" | "object";
      mutable: boolean;
      current_value: any;
      history?: Array<{
        value: any;
        timestamp: number;
        block_height: number;
      }>;
    }>;
    
    // ìœ í‹¸ë¦¬í‹° ì •ë³´
    utility: {
      functions: string[];
      access_rights: string[];
      expiry_date?: number;
      usage_count: number;
    };
    
    // ë¡œì—´í‹° ì •ë³´
    royalty: {
      percentage: number; // basis points
      recipients: Array<{
        address: string;
        share: number; // basis points
      }>;
    };
    
    // ì œì‘ ì •ë³´
    provenance: {
      artist?: string;
      creation_method: "hand_drawn" | "generative" | "ai_generated" | "photography" | "other";
      software_used?: string[];
      creation_date: number;
      edition_info?: {
        edition_number: number;
        total_editions: number;
      };
    };
  };
  
  // ì»¬ë ‰ì…˜ ì •ë³´
  collection: {
    name: string;
    family?: string;
    description?: string;
    image?: string;
    external_url?: string;
  };
  
  // ê²Œì„ ê´€ë ¨ ì†ì„± (í•´ë‹¹í•˜ëŠ” ê²½ìš°)
  game_attributes?: {
    level?: number;
    experience?: number;
    rarity_rank?: number;
    stats?: Record<string, number>;
    equipped_items?: string[];
    abilities?: string[];
  };
}

// ë©”íƒ€ë°ì´í„° ê²€ì¦ í´ë˜ìŠ¤
class MetadataValidator {
  static validate(metadata: MovementNFTMetadata): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];
    
    // í•„ìˆ˜ í•„ë“œ í™•ì¸
    if (!metadata.name || metadata.name.trim().length === 0) {
      errors.push("Name is required");
    }
    
    if (!metadata.description || metadata.description.trim().length === 0) {
      errors.push("Description is required");
    }
    
    if (!metadata.image || !this.isValidUrl(metadata.image)) {
      errors.push("Valid image URL is required");
    }
    
    // URL ê²€ì¦
    if (metadata.external_url && !this.isValidUrl(metadata.external_url)) {
      warnings.push("External URL format may be invalid");
    }
    
    if (metadata.animation_url && !this.isValidUrl(metadata.animation_url)) {
      warnings.push("Animation URL format may be invalid");
    }
    
    // ì†ì„± ê²€ì¦
    if (!metadata.attributes || metadata.attributes.length === 0) {
      warnings.push("No attributes defined - consider adding traits");
    }
    
    metadata.attributes?.forEach((attr, index) => {
      if (!attr.trait_type || !attr.value) {
        errors.push(`Attribute ${index}: trait_type and value are required`);
      }
    });
    
    // Movement íŠ¹í™” í•„ë“œ ê²€ì¦
    if (metadata.movement_metadata) {
      if (!metadata.movement_metadata.schema_version) {
        errors.push("Movement metadata schema_version is required");
      }
      
      // ë¡œì—´í‹° ê²€ì¦
      if (metadata.movement_metadata.royalty) {
        const royalty = metadata.movement_metadata.royalty;
        if (royalty.percentage < 0 || royalty.percentage > 1000) {
          errors.push("Royalty percentage must be between 0 and 1000 basis points (0-10%)");
        }
        
        const totalShares = royalty.recipients.reduce((sum, recipient) => sum + recipient.share, 0);
        if (totalShares !== 10000) {
          errors.push("Royalty recipient shares must sum to 10000 basis points (100%)");
        }
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  
  private static isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}
```

### ë©”íƒ€ë°ì´í„° ìƒì„± ë„êµ¬
```typescript
// NFT ë©”íƒ€ë°ì´í„° ë¹Œë” í´ë˜ìŠ¤
class NFTMetadataBuilder {
  private metadata: Partial<MovementNFTMetadata> = {
    attributes: [],
    movement_metadata: {
      schema_version: "1.0.0",
      created_at: Date.now(),
      updated_at: Date.now(),
      token_standard: "movement-nft-v1",
      utility: {
        functions: [],
        access_rights: [],
        usage_count: 0
      },
      provenance: {
        creation_method: "other",
        creation_date: Date.now()
      }
    }
  };
  
  // ê¸°ë³¸ ì •ë³´ ì„¤ì •
  setBasicInfo(name: string, description: string, imageUrl: string): this {
    this.metadata.name = name;
    this.metadata.description = description;
    this.metadata.image = imageUrl;
    return this;
  }
  
  // ì†ì„± ì¶”ê°€
  addAttribute(traitType: string, value: string | number, displayType?: string): this {
    if (!this.metadata.attributes) {
      this.metadata.attributes = [];
    }
    
    this.metadata.attributes.push({
      trait_type: traitType,
      value,
      display_type: displayType
    });
    
    return this;
  }
  
  // ë™ì  ì†ì„± ì¶”ê°€
  addDynamicAttribute(
    name: string,
    type: "string" | "number" | "boolean" | "object",
    initialValue: any,
    mutable: boolean = true
  ): this {
    if (!this.metadata.movement_metadata.dynamic_attributes) {
      this.metadata.movement_metadata.dynamic_attributes = [];
    }
    
    this.metadata.movement_metadata.dynamic_attributes.push({
      name,
      type,
      mutable,
      current_value: initialValue
    });
    
    return this;
  }
  
  // ë¡œì—´í‹° ì„¤ì •
  setRoyalty(percentage: number, recipients: Array<{address: string, share: number}>): this {
    this.metadata.movement_metadata.royalty = {
      percentage,
      recipients
    };
    return this;
  }
  
  // ì»¬ë ‰ì…˜ ì •ë³´ ì„¤ì •
  setCollection(name: string, description?: string, imageUrl?: string): this {
    this.metadata.collection = {
      name,
      description,
      image: imageUrl
    };
    return this;
  }
  
  // ê²Œì„ ì†ì„± ì„¤ì •
  setGameAttributes(attributes: {
    level?: number;
    experience?: number;
    rarity_rank?: number;
    stats?: Record<string, number>;
  }): this {
    this.metadata.game_attributes = attributes;
    return this;
  }
  
  // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ì¶”ê°€
  addUtilityFunction(functionName: string): this {
    this.metadata.movement_metadata.utility.functions.push(functionName);
    return this;
  }
  
  // ì œì‘ ì •ë³´ ì„¤ì •
  setProvenance(info: {
    artist?: string;
    creation_method: "hand_drawn" | "generative" | "ai_generated" | "photography" | "other";
    software_used?: string[];
  }): this {
    Object.assign(this.metadata.movement_metadata.provenance, info);
    return this;
  }
  
  // ë©”íƒ€ë°ì´í„° ë¹Œë“œ ë° ê²€ì¦
  build(): MovementNFTMetadata {
    const metadata = this.metadata as MovementNFTMetadata;
    
    // í•„ìˆ˜ í•„ë“œ í™•ì¸
    if (!metadata.name || !metadata.description || !metadata.image) {
      throw new Error("Name, description, and image are required");
    }
    
    // ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸ ì‹œê°„ ì„¤ì •
    metadata.movement_metadata.updated_at = Date.now();
    
    // ê²€ì¦
    const validation = MetadataValidator.validate(metadata);
    if (!validation.isValid) {
      throw new Error(`Metadata validation failed: ${validation.errors.join(", ")}`);
    }
    
    return metadata;
  }
  
  // JSON ë¬¸ìì—´ë¡œ ë³€í™˜
  toJSON(): string {
    return JSON.stringify(this.build(), null, 2);
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const nftMetadata = new NFTMetadataBuilder()
  .setBasicInfo(
    "Cosmic Dragon #1",
    "A legendary cosmic dragon with mystical powers",
    "ipfs://QmYourImageHash"
  )
  .addAttribute("Rarity", "Legendary")
  .addAttribute("Element", "Cosmic")
  .addAttribute("Power Level", 9000, "number")
  .addAttribute("Birth Date", Date.now(), "date")
  .addDynamicAttribute("Level", "number", 1, true)
  .addDynamicAttribute("Experience", "number", 0, true)
  .setRoyalty(500, [{ address: "0x123...", share: 10000 }]) // 5% royalty
  .setCollection("Cosmic Dragons", "A collection of mystical dragons")
  .setGameAttributes({
    level: 1,
    experience: 0,
    rarity_rank: 1,
    stats: {
      strength: 95,
      intelligence: 88,
      agility: 76,
      defense: 92
    }
  })
  .addUtilityFunction("battle")
  .addUtilityFunction("breeding")
  .setProvenance({
    artist: "CosmicArtist",
    creation_method: "generative",
    software_used: ["Photoshop", "AI Tools"]
  })
  .build();
```

## ğŸŒ IPFS í†µí•© ë° ë¶„ì‚° ì €ì¥

### IPFS ë©”íƒ€ë°ì´í„° ê´€ë¦¬ì
```typescript
import { create, IPFSHTTPClient } from 'ipfs-http-client';
import { Web3Storage, File } from 'web3.storage';
import pinataSDK from '@pinata/sdk';

class IPFSMetadataManager {
  private ipfs: IPFSHTTPClient;
  private web3Storage?: Web3Storage;
  private pinata?: any;
  
  constructor(config: {
    ipfsNodeUrl?: string;
    web3StorageToken?: string;
    pinataApiKey?: string;
    pinataSecretKey?: string;
  }) {
    // IPFS ë…¸ë“œ ì—°ê²°
    this.ipfs = create({
      url: config.ipfsNodeUrl || 'https://ipfs.infura.io:5001/api/v0'
    });
    
    // Web3.Storage ì„¤ì •
    if (config.web3StorageToken) {
      this.web3Storage = new Web3Storage({ 
        token: config.web3StorageToken 
      });
    }
    
    // Pinata ì„¤ì •
    if (config.pinataApiKey && config.pinataSecretKey) {
      this.pinata = new pinataSDK(config.pinataApiKey, config.pinataSecretKey);
    }
  }
  
  // ì´ë¯¸ì§€ íŒŒì¼ ì—…ë¡œë“œ
  async uploadImage(
    imageFile: File | Buffer,
    fileName: string,
    options: {
      pin: boolean;
      provider: 'ipfs' | 'web3storage' | 'pinata';
    } = { pin: true, provider: 'ipfs' }
  ): Promise<string> {
    try {
      let cid: string;
      
      switch (options.provider) {
        case 'web3storage':
          if (!this.web3Storage) throw new Error('Web3.Storage not configured');
          const file = new File([imageFile], fileName);
          cid = await this.web3Storage.put([file]);
          break;
          
        case 'pinata':
          if (!this.pinata) throw new Error('Pinata not configured');
          const pinataResult = await this.pinata.pinFileToIPFS(imageFile, {
            pinataMetadata: { name: fileName }
          });
          cid = pinataResult.IpfsHash;
          break;
          
        default: // 'ipfs'
          const addResult = await this.ipfs.add(imageFile);
          cid = addResult.cid.toString();
          
          if (options.pin) {
            await this.ipfs.pin.add(cid);
          }
          break;
      }
      
      return `ipfs://${cid}`;
    } catch (error) {
      throw new Error(`Failed to upload image: ${error.message}`);
    }
  }
  
  // ë©”íƒ€ë°ì´í„° JSON ì—…ë¡œë“œ
  async uploadMetadata(
    metadata: MovementNFTMetadata,
    options: {
      pin: boolean;
      provider: 'ipfs' | 'web3storage' | 'pinata';
      compress: boolean;
    } = { pin: true, provider: 'ipfs', compress: false }
  ): Promise<string> {
    try {
      let metadataJson = JSON.stringify(metadata, null, options.compress ? 0 : 2);
      
      // ì••ì¶• ì˜µì…˜ì´ í™œì„±í™”ëœ ê²½ìš°
      if (options.compress) {
        metadataJson = this.compressMetadata(metadataJson);
      }
      
      const buffer = Buffer.from(metadataJson, 'utf8');
      let cid: string;
      
      switch (options.provider) {
        case 'web3storage':
          if (!this.web3Storage) throw new Error('Web3.Storage not configured');
          const file = new File([buffer], 'metadata.json', { type: 'application/json' });
          cid = await this.web3Storage.put([file]);
          break;
          
        case 'pinata':
          if (!this.pinata) throw new Error('Pinata not configured');
          const pinataResult = await this.pinata.pinJSONToIPFS(metadata, {
            pinataMetadata: { name: `${metadata.name}_metadata` }
          });
          cid = pinataResult.IpfsHash;
          break;
          
        default: // 'ipfs'
          const addResult = await this.ipfs.add(buffer);
          cid = addResult.cid.toString();
          
          if (options.pin) {
            await this.ipfs.pin.add(cid);
          }
          break;
      }
      
      return `ipfs://${cid}`;
    } catch (error) {
      throw new Error(`Failed to upload metadata: ${error.message}`);
    }
  }
  
  // ì „ì²´ NFT ì—ì…‹ ì—…ë¡œë“œ (ì´ë¯¸ì§€ + ë©”íƒ€ë°ì´í„°)
  async uploadCompleteNFTAsset(
    imageFile: File | Buffer,
    metadata: Omit<MovementNFTMetadata, 'image'>,
    options: {
      imageFileName: string;
      pin: boolean;
      provider: 'ipfs' | 'web3storage' | 'pinata';
      compress: boolean;
    }
  ): Promise<{ imageUri: string; metadataUri: string }> {
    // 1. ì´ë¯¸ì§€ ì—…ë¡œë“œ
    console.log('Uploading image...');
    const imageUri = await this.uploadImage(imageFile, options.imageFileName, {
      pin: options.pin,
      provider: options.provider
    });
    
    // 2. ë©”íƒ€ë°ì´í„°ì— ì´ë¯¸ì§€ URI ì¶”ê°€
    const completeMetadata: MovementNFTMetadata = {
      ...metadata,
      image: imageUri
    };
    
    // 3. ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ
    console.log('Uploading metadata...');
    const metadataUri = await this.uploadMetadata(completeMetadata, {
      pin: options.pin,
      provider: options.provider,
      compress: options.compress
    });
    
    return { imageUri, metadataUri };
  }
  
  // ë©”íƒ€ë°ì´í„° ì¡°íšŒ
  async getMetadata(ipfsUri: string): Promise<MovementNFTMetadata> {
    try {
      const cid = ipfsUri.replace('ipfs://', '');
      const chunks = [];
      
      for await (const chunk of this.ipfs.cat(cid)) {
        chunks.push(chunk);
      }
      
      const buffer = Buffer.concat(chunks);
      const metadataJson = buffer.toString('utf8');
      
      return JSON.parse(metadataJson) as MovementNFTMetadata;
    } catch (error) {
      throw new Error(`Failed to get metadata: ${error.message}`);
    }
  }
  
  // ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸ (ìƒˆ ë²„ì „ ìƒì„±)
  async updateMetadata(
    originalUri: string,
    updates: Partial<MovementNFTMetadata>,
    options: {
      pin: boolean;
      provider: 'ipfs' | 'web3storage' | 'pinata';
    } = { pin: true, provider: 'ipfs' }
  ): Promise<string> {
    // 1. ê¸°ì¡´ ë©”íƒ€ë°ì´í„° ì¡°íšŒ
    const originalMetadata = await this.getMetadata(originalUri);
    
    // 2. ì—…ë°ì´íŠ¸ ì ìš©
    const updatedMetadata: MovementNFTMetadata = {
      ...originalMetadata,
      ...updates,
      movement_metadata: {
        ...originalMetadata.movement_metadata,
        ...updates.movement_metadata,
        updated_at: Date.now()
      }
    };
    
    // 3. ìƒˆ ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ
    return await this.uploadMetadata(updatedMetadata, {
      pin: options.pin,
      provider: options.provider,
      compress: false
    });
  }
  
  // ë°°ì¹˜ ì—…ë¡œë“œ
  async batchUploadAssets(
    assets: Array<{
      imageFile: File | Buffer;
      metadata: Omit<MovementNFTMetadata, 'image'>;
      imageFileName: string;
    }>,
    options: {
      pin: boolean;
      provider: 'ipfs' | 'web3storage' | 'pinata';
      concurrency: number;
    } = { pin: true, provider: 'ipfs', concurrency: 3 }
  ): Promise<Array<{ imageUri: string; metadataUri: string; index: number }>> {
    const results = [];
    const batches = this.createBatches(assets, options.concurrency);
    
    for (const batch of batches) {
      const batchPromises = batch.map(async ({ asset, index }) => {
        try {
          const result = await this.uploadCompleteNFTAsset(
            asset.imageFile,
            asset.metadata,
            {
              imageFileName: asset.imageFileName,
              pin: options.pin,
              provider: options.provider,
              compress: false
            }
          );
          
          return { ...result, index };
        } catch (error) {
          console.error(`Failed to upload asset ${index}:`, error);
          throw error;
        }
      });
      
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);
      
      // ë°°ì¹˜ ê°„ ì§€ì—° (API ì œí•œ ëŒ€ì‘)
      if (batches.indexOf(batch) < batches.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    return results.sort((a, b) => a.index - b.index);
  }
  
  // ë©”íƒ€ë°ì´í„° ì••ì¶• (ì„ íƒì )
  private compressMetadata(metadataJson: string): string {
    // ë¶ˆí•„ìš”í•œ ê³µë°± ì œê±° ë° ë°ì´í„° ìµœì í™”
    const metadata = JSON.parse(metadataJson);
    
    // ë¹ˆ ë°°ì—´ì´ë‚˜ ê°ì²´ ì œê±°
    Object.keys(metadata).forEach(key => {
      if (Array.isArray(metadata[key]) && metadata[key].length === 0) {
        delete metadata[key];
      } else if (typeof metadata[key] === 'object' && Object.keys(metadata[key]).length === 0) {
        delete metadata[key];
      }
    });
    
    return JSON.stringify(metadata);
  }
  
  // ë°°ì¹˜ ìƒì„± í—¬í¼
  private createBatches<T>(items: T[], batchSize: number): Array<Array<{ asset: T; index: number }>> {
    const batches = [];
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize).map((asset, idx) => ({
        asset,
        index: i + idx
      }));
      batches.push(batch);
    }
    return batches;
  }
  
  // í•€ ìƒíƒœ í™•ì¸
  async checkPinStatus(cid: string): Promise<boolean> {
    try {
      const pins = await this.ipfs.pin.ls();
      for await (const pin of pins) {
        if (pin.cid.toString() === cid) {
          return true;
        }
      }
      return false;
    } catch (error) {
      console.error('Failed to check pin status:', error);
      return false;
    }
  }
  
  // ì €ì¥ì†Œ ì‚¬ìš©ëŸ‰ í†µê³„
  async getStorageStats(): Promise<{
    totalSize: number;
    pinnedCount: number;
    provider: string;
  }> {
    try {
      const stats = await this.ipfs.stats.repo();
      const pins = await this.ipfs.pin.ls();
      let pinnedCount = 0;
      
      for await (const pin of pins) {
        pinnedCount++;
      }
      
      return {
        totalSize: stats.repoSize,
        pinnedCount,
        provider: 'ipfs'
      };
    } catch (error) {
      console.error('Failed to get storage stats:', error);
      return { totalSize: 0, pinnedCount: 0, provider: 'unknown' };
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
async function uploadNFTCollection() {
  const ipfsManager = new IPFSMetadataManager({
    web3StorageToken: 'your-web3-storage-token',
    pinataApiKey: 'your-pinata-api-key',
    pinataSecretKey: 'your-pinata-secret-key'
  });
  
  // ë‹¨ì¼ NFT ì—…ë¡œë“œ
  const imageFile = new File([/* image buffer */], 'dragon.png');
  const metadata = new NFTMetadataBuilder()
    .setBasicInfo("Cosmic Dragon #1", "A legendary dragon", "")
    .addAttribute("Rarity", "Legendary")
    .build();
  
  const { imageUri, metadataUri } = await ipfsManager.uploadCompleteNFTAsset(
    imageFile,
    metadata,
    {
      imageFileName: 'cosmic_dragon_1.png',
      pin: true,
      provider: 'web3storage',
      compress: true
    }
  );
  
  console.log('Image URI:', imageUri);
  console.log('Metadata URI:', metadataUri);
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

Token Standardì™€ Metadataë¥¼ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[Resource Account í™œìš© â†’](/dapp-development/nft-development/resource-account-integration)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement Token Standard](https://docs.movementnetwork.xyz/token-standard)
- [IPFS ë¬¸ì„œ](https://docs.ipfs.io/)
- [OpenSea ë©”íƒ€ë°ì´í„° í‘œì¤€](https://docs.opensea.io/docs/metadata-standards)

---

*Movement Networkì—ì„œ í‘œì¤€ í˜¸í™˜ NFTì™€ ìµœì í™”ëœ ë©”íƒ€ë°ì´í„° ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ“‹âš¡*