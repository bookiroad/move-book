# ğŸ›ï¸ ê±°ë²„ë„ŒìŠ¤ ë° DAO ì‹œìŠ¤í…œ

Movement Networkì—ì„œ íƒˆì¤‘ì•™í™” ììœ¨ ì¡°ì§ê³¼ ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ëŠ” ì™„ì „í•œ ê°€ì´ë“œì…ë‹ˆë‹¤. í† í° ê¸°ë°˜ íˆ¬í‘œë¶€í„° ë³µì¡í•œ ì œì•ˆ ì‹¤í–‰ê¹Œì§€, íˆ¬ëª…í•˜ê³  íš¨ìœ¨ì ì¸ DAOë¥¼ ë§Œë“¤ì–´ë´…ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- ì¢…í•©ì ì¸ DAO ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ìœ„ì„ íˆ¬í‘œì™€ ì¿¼ë“œë¼í‹± íˆ¬í‘œë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- íƒ€ì„ë½ê³¼ ë©€í‹°ì‹œê·¸ ë³´ì•ˆì„ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í† í° ê²½ì œí•™ê³¼ ì¸ì„¼í‹°ë¸Œë¥¼ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì œì•ˆ ì‹¤í–‰ê³¼ ì—…ê·¸ë ˆì´ë“œ ë©”ì»¤ë‹ˆì¦˜ì„ ê°œë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ›ï¸ ì¢…í•© DAO ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œ

### ê³ ê¸‰ DAO ì•„í‚¤í…ì²˜
```move
module governance::comprehensive_dao {
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    use std::option::{Self, Option};
    use aptos_framework::fungible_asset::{Self, FungibleAsset, Metadata};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::timestamp;
    use aptos_framework::event::{Self, EventHandle};
    use aptos_std::smart_table::{Self, SmartTable};
    use aptos_std::math64;
    use aptos_std::hash;
    
    /// DAO ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œ
    struct DAOGovernance has key {
        // DAO ê¸°ë³¸ ì •ë³´
        name: String,
        description: String,
        governance_token: Object<Metadata>,
        
        // íˆ¬í‘œ ì„¤ì •
        voting_config: VotingConfiguration,
        
        // ì œì•ˆ ê´€ë¦¬
        proposals: SmartTable<u64, Proposal>,
        proposal_count: u64,
        
        // ìœ„ì„ ì‹œìŠ¤í…œ
        delegations: SmartTable<address, Delegation>,
        delegates: SmartTable<address, DelegateProfile>,
        
        // ì¿¼ëŸ¼ ë° ì„ê³„ê°’
        quorum_threshold: u64,           // basis points (ìµœì†Œ ì°¸ì—¬ìœ¨)
        approval_threshold: u64,         // basis points (ì°¬ì„± ë¹„ìœ¨)
        
        // íƒ€ì„ë½ ë° ì‹¤í–‰
        timelock_delay: u64,             // ì‹¤í–‰ ì§€ì—° ì‹œê°„ (ì´ˆ)
        execution_window: u64,           // ì‹¤í–‰ ê°€ëŠ¥ ê¸°ê°„ (ì´ˆ)
        
        // ë©€í‹°ì‹œê·¸ ë³´ì•ˆ
        multisig_threshold: u8,          // ìµœì†Œ ì„œëª… ìˆ˜
        multisig_signers: vector<address>,
        
        // í† í° ìŠ¤í…Œì´í‚¹
        staking_requirement: u64,        // ì œì•ˆ ìƒì„± ì‹œ í•„ìš”í•œ ìµœì†Œ ìŠ¤í…Œì´í‚¹
        total_staked: u64,
        user_stakes: SmartTable<address, UserStake>,
        
        // ë³´ìƒ ì‹œìŠ¤í…œ
        participation_rewards_enabled: bool,
        reward_pool: u64,
        rewards_per_vote: u64,
        
        // ê³ ê¸‰ íˆ¬í‘œ ë©”ì»¤ë‹ˆì¦˜
        quadratic_voting_enabled: bool,
        conviction_voting_enabled: bool,
        
        // ìœ„ì›íšŒ ì‹œìŠ¤í…œ
        committees: SmartTable<String, Committee>,
        
        // ê±°ë²„ë„ŒìŠ¤ í†µê³„
        total_proposals: u64,
        total_votes_cast: u64,
        average_participation_rate: u64,
        
        // ì´ë²¤íŠ¸
        governance_events: EventHandle<GovernanceEvent>,
        
        // DAO ì„¤ì •
        is_active: bool,
        emergency_pause: bool,
        guardian_council: Option<address>,
        
        created_at: u64,
        last_updated: u64
    }
    
    /// íˆ¬í‘œ ì„¤ì •
    struct VotingConfiguration has store, drop, copy {
        // íˆ¬í‘œ ê¸°ê°„
        voting_period: u64,              // íˆ¬í‘œ ê¸°ê°„ (ì´ˆ)
        voting_delay: u64,               // ì œì•ˆ í›„ íˆ¬í‘œ ì‹œì‘ê¹Œì§€ ì§€ì—° (ì´ˆ)
        
        // ìŠ¤ëƒ…ìƒ· ì„¤ì •
        snapshot_strategy: u8,           // 0: current, 1: fixed_block, 2: time_weighted
        snapshot_block_delay: u64,       // ìŠ¤ëƒ…ìƒ· ë¸”ë¡ ì§€ì—°
        
        // íˆ¬í‘œ ê°€ì¤‘ì¹˜
        vote_weight_strategy: u8,        // 0: token_balance, 1: staked_balance, 2: time_weighted
        minimum_vote_weight: u64,        // ìµœì†Œ íˆ¬í‘œ ê°€ì¤‘ì¹˜
        
        // ì¡°ê¸° ì¢…ë£Œ
        early_execution_enabled: bool,
        early_execution_threshold: u64,  // basis points
        
        // ìµëª… íˆ¬í‘œ
        secret_voting_enabled: bool
    }
    
    /// ì œì•ˆ
    struct Proposal has store, drop, copy {
        id: u64,
        proposer: address,
        
        // ì œì•ˆ ë‚´ìš©
        title: String,
        description: String,
        proposal_type: u8,               // 0: parameter, 1: upgrade, 2: spending, 3: general
        
        // ì‹¤í–‰ ë°ì´í„°
        execution_data: vector<ExecutionAction>,
        
        // íˆ¬í‘œ ì •ë³´
        votes_for: u64,
        votes_against: u64,
        votes_abstain: u64,
        total_votes: u64,
        
        // íˆ¬í‘œì ì¶”ì 
        voters: SmartTable<address, Vote>,
        
        // ì¿¼ë“œë¼í‹± íˆ¬í‘œ (ì„ íƒì )
        quadratic_votes_for: u64,
        quadratic_votes_against: u64,
        
        // ì‹œê°„ ì •ë³´
        created_at: u64,
        voting_starts_at: u64,
        voting_ends_at: u64,
        execution_eta: u64,              // ì‹¤í–‰ ì˜ˆì • ì‹œê°„
        
        // ìƒíƒœ
        status: u8,                      // 0: pending, 1: active, 2: succeeded, 3: defeated, 4: executed, 5: expired
        
        // ìŠ¤í…Œì´í‚¹
        proposer_stake: u64,
        total_stake_for: u64,
        total_stake_against: u64,
        
        // ìœ„ì›íšŒ ì •ë³´ (í•´ë‹¹í•˜ëŠ” ê²½ìš°)
        committee: Option<String>,
        
        // ë©”íƒ€ë°ì´í„°
        ipfs_hash: Option<String>,       // ìƒì„¸ ì •ë³´ IPFS í•´ì‹œ
        tags: vector<String>
    }
    
    /// ì‹¤í–‰ ì•¡ì…˜
    struct ExecutionAction has store, drop, copy {
        target: address,                 // ëŒ€ìƒ ì»¨íŠ¸ë™íŠ¸
        function_name: String,           // í˜¸ì¶œí•  í•¨ìˆ˜
        args: vector<u8>,               // í•¨ìˆ˜ ì¸ìë“¤
        value: u64                      // ì „ì†¡í•  í† í° ì–‘ (í•´ë‹¹í•˜ëŠ” ê²½ìš°)
    }
    
    /// íˆ¬í‘œ
    struct Vote has store, drop, copy {
        voter: address,
        support: u8,                     // 0: against, 1: for, 2: abstain
        weight: u64,                     // íˆ¬í‘œ ê°€ì¤‘ì¹˜
        quadratic_weight: u64,           // ì¿¼ë“œë¼í‹± ê°€ì¤‘ì¹˜
        reason: String,                  // íˆ¬í‘œ ì´ìœ 
        voted_at: u64
    }
    
    /// ìœ„ì„
    struct Delegation has store, drop, copy {
        delegator: address,
        delegate: address,
        delegation_amount: u64,          // ìœ„ì„ëœ í† í° ì–‘
        delegation_type: u8,             // 0: full, 1: specific_proposals, 2: committee_only
        expiry: u64,                     // ìœ„ì„ ë§Œë£Œ ì‹œê°„
        created_at: u64
    }
    
    /// ëŒ€ë¦¬ì¸ í”„ë¡œí•„
    struct DelegateProfile has store, drop, copy {
        delegate: address,
        name: String,
        description: String,
        platform_url: Option<String>,
        
        // í†µê³„
        total_delegated: u64,
        delegator_count: u64,
        proposals_voted: u64,
        participation_rate: u64,         // basis points
        
        // ì „ë¬¸ ë¶„ì•¼
        expertise_areas: vector<String>,
        
        // ê²€ì¦
        verified: bool,
        verification_date: u64,
        
        created_at: u64,
        last_activity: u64
    }
    
    /// ì‚¬ìš©ì ìŠ¤í…Œì´í‚¹
    struct UserStake has store, drop, copy {
        user: address,
        staked_amount: u64,
        locked_until: u64,
        
        // íˆ¬í‘œ ê¸°ë¡
        proposals_voted: vector<u64>,
        participation_score: u64,
        
        // ë³´ìƒ
        unclaimed_rewards: u64,
        last_reward_claim: u64,
        
        // ìŠ¬ë˜ì‹± ì •ë³´
        slashed_amount: u64,
        last_slash_reason: String,
        
        created_at: u64
    }
    
    /// ìœ„ì›íšŒ
    struct Committee has store, drop, copy {
        name: String,
        description: String,
        
        // ë©¤ë²„ì‹­
        members: vector<address>,
        member_limit: u8,
        
        // ê¶Œí•œ
        proposal_threshold: u64,         // ìœ„ì›íšŒ ì œì•ˆ ìƒì„± ì„ê³„ê°’
        voting_period: u64,              // ìœ„ì›íšŒ íˆ¬í‘œ ê¸°ê°„
        
        // ì „ë¬¸ ë¶„ì•¼
        focus_areas: vector<String>,
        
        // í™œë™ í†µê³„
        proposals_reviewed: u64,
        decisions_made: u64,
        
        is_active: bool,
        created_at: u64
    }
    
    /// ê±°ë²„ë„ŒìŠ¤ ì´ë²¤íŠ¸
    struct GovernanceEvent has drop, store {
        event_type: String,
        user: address,
        proposal_id: Option<u64>,
        additional_data: String,
        timestamp: u64
    }
    
    /// DAO ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    public fun initialize_dao_governance(
        admin: &signer,
        name: String,
        description: String,
        governance_token: Object<Metadata>,
        voting_period: u64,
        quorum_threshold: u64,
        approval_threshold: u64
    ) {
        let admin_addr = signer::address_of(admin);
        
        // ì…ë ¥ ê²€ì¦
        assert!(quorum_threshold > 0 && quorum_threshold <= 10000, E_INVALID_QUORUM);
        assert!(approval_threshold > 5000 && approval_threshold <= 10000, E_INVALID_THRESHOLD);
        assert!(voting_period >= 86400, E_INVALID_VOTING_PERIOD); // ìµœì†Œ 1ì¼
        
        let voting_config = VotingConfiguration {
            voting_period,
            voting_delay: 86400,         // 1ì¼ ì§€ì—°
            snapshot_strategy: 0,        // í˜„ì¬ ì”ì•¡
            snapshot_block_delay: 1,
            vote_weight_strategy: 0,     // í† í° ì”ì•¡ ê¸°ë°˜
            minimum_vote_weight: 1,
            early_execution_enabled: true,
            early_execution_threshold: 8000, // 80%
            secret_voting_enabled: false
        };
        
        let dao = DAOGovernance {
            name,
            description,
            governance_token,
            voting_config,
            proposals: smart_table::new(),
            proposal_count: 0,
            delegations: smart_table::new(),
            delegates: smart_table::new(),
            quorum_threshold,
            approval_threshold,
            timelock_delay: 172800,      // 2ì¼
            execution_window: 259200,    // 3ì¼
            multisig_threshold: 3,
            multisig_signers: vector::empty(),
            staking_requirement: 10000,  // ìµœì†Œ ìŠ¤í…Œì´í‚¹ ìš”êµ¬ëŸ‰
            total_staked: 0,
            user_stakes: smart_table::new(),
            participation_rewards_enabled: true,
            reward_pool: 0,
            rewards_per_vote: 10,
            quadratic_voting_enabled: false,
            conviction_voting_enabled: false,
            committees: smart_table::new(),
            total_proposals: 0,
            total_votes_cast: 0,
            average_participation_rate: 0,
            governance_events: account::new_event_handle<GovernanceEvent>(admin),
            is_active: true,
            emergency_pause: false,
            guardian_council: option::some(admin_addr),
            created_at: timestamp::now_seconds(),
            last_updated: timestamp::now_seconds()
        };
        
        // ì´ˆê¸° ë©€í‹°ì‹œê·¸ ì„œëª…ì ì„¤ì •
        vector::push_back(&mut dao.multisig_signers, admin_addr);
        
        move_to(admin, dao);
    }
    
    /// ê±°ë²„ë„ŒìŠ¤ í† í° ìŠ¤í…Œì´í‚¹
    public fun stake_governance_tokens(
        user: &signer,
        dao_addr: address,
        amount: u64,
        lock_period: u64
    ) acquires DAOGovernance {
        let user_addr = signer::address_of(user);
        let dao = borrow_global_mut<DAOGovernance>(dao_addr);
        
        assert!(dao.is_active && !dao.emergency_pause, E_DAO_PAUSED);
        assert!(amount > 0, E_INVALID_AMOUNT);
        
        // í† í° ì „ì†¡
        let gov_fa = primary_fungible_store::withdraw(user, dao.governance_token, amount);
        primary_fungible_store::deposit(dao_addr, gov_fa);
        
        let current_time = timestamp::now_seconds();
        let lock_until = current_time + lock_period;
        
        // ì‚¬ìš©ì ìŠ¤í…Œì´í¬ ì •ë³´ ì—…ë°ì´íŠ¸
        if (smart_table::contains(&dao.user_stakes, user_addr)) {
            let user_stake = smart_table::borrow_mut(&mut dao.user_stakes, user_addr);
            user_stake.staked_amount = user_stake.staked_amount + amount;
            if (lock_until > user_stake.locked_until) {
                user_stake.locked_until = lock_until;
            }
        } else {
            let new_stake = UserStake {
                user: user_addr,
                staked_amount: amount,
                locked_until: lock_until,
                proposals_voted: vector::empty(),
                participation_score: 0,
                unclaimed_rewards: 0,
                last_reward_claim: current_time,
                slashed_amount: 0,
                last_slash_reason: string::utf8(b""),
                created_at: current_time
            };
            smart_table::add(&mut dao.user_stakes, user_addr, new_stake);
        };
        
        dao.total_staked = dao.total_staked + amount;
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut dao.governance_events, GovernanceEvent {
            event_type: string::utf8(b"stake"),
            user: user_addr,
            proposal_id: option::none(),
            additional_data: amount.to_string(),
            timestamp: current_time
        });
    }
    
    /// ì œì•ˆ ìƒì„±
    public fun create_proposal(
        proposer: &signer,
        dao_addr: address,
        title: String,
        description: String,
        proposal_type: u8,
        execution_data: vector<ExecutionAction>,
        ipfs_hash: Option<String>,
        committee: Option<String>
    ): u64 acquires DAOGovernance {
        let proposer_addr = signer::address_of(proposer);
        let dao = borrow_global_mut<DAOGovernance>(dao_addr);
        
        assert!(dao.is_active && !dao.emergency_pause, E_DAO_PAUSED);
        
        // ì œì•ˆì ìê²© í™•ì¸
        let proposer_voting_power = get_voting_power(dao, proposer_addr);
        assert!(proposer_voting_power >= dao.staking_requirement, E_INSUFFICIENT_VOTING_POWER);
        
        // ìŠ¤í…Œì´í‚¹ ìš”êµ¬ì‚¬í•­ í™•ì¸
        if (smart_table::contains(&dao.user_stakes, proposer_addr)) {
            let user_stake = smart_table::borrow(&dao.user_stakes, proposer_addr);
            assert!(user_stake.staked_amount >= dao.staking_requirement, E_INSUFFICIENT_STAKE);
        } else {
            assert!(false, E_NO_STAKE_FOUND);
        };
        
        let current_time = timestamp::now_seconds();
        let proposal_id = dao.proposal_count + 1;
        
        // íˆ¬í‘œ ì‹œì‘ ë° ì¢…ë£Œ ì‹œê°„ ê³„ì‚°
        let voting_starts_at = current_time + dao.voting_config.voting_delay;
        let voting_ends_at = voting_starts_at + dao.voting_config.voting_period;
        let execution_eta = voting_ends_at + dao.timelock_delay;
        
        let proposal = Proposal {
            id: proposal_id,
            proposer: proposer_addr,
            title,
            description,
            proposal_type,
            execution_data,
            votes_for: 0,
            votes_against: 0,
            votes_abstain: 0,
            total_votes: 0,
            voters: smart_table::new(),
            quadratic_votes_for: 0,
            quadratic_votes_against: 0,
            created_at: current_time,
            voting_starts_at,
            voting_ends_at,
            execution_eta,
            status: 0, // pending
            proposer_stake: dao.staking_requirement,
            total_stake_for: 0,
            total_stake_against: 0,
            committee,
            ipfs_hash,
            tags: vector::empty()
        };
        
        smart_table::add(&mut dao.proposals, proposal_id, proposal);
        dao.proposal_count = proposal_id;
        dao.total_proposals = dao.total_proposals + 1;
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut dao.governance_events, GovernanceEvent {
            event_type: string::utf8(b"proposal_created"),
            user: proposer_addr,
            proposal_id: option::some(proposal_id),
            additional_data: title,
            timestamp: current_time
        });
        
        proposal_id
    }
    
    /// íˆ¬í‘œ ì‹¤í–‰
    public fun cast_vote(
        voter: &signer,
        dao_addr: address,
        proposal_id: u64,
        support: u8,
        reason: String,
        quadratic_credits: Option<u64>
    ) acquires DAOGovernance {
        let voter_addr = signer::address_of(voter);
        let dao = borrow_global_mut<DAOGovernance>(dao_addr);
        
        assert!(dao.is_active && !dao.emergency_pause, E_DAO_PAUSED);
        assert!(smart_table::contains(&dao.proposals, proposal_id), E_PROPOSAL_NOT_FOUND);
        assert!(support <= 2, E_INVALID_VOTE_OPTION); // 0: against, 1: for, 2: abstain
        
        let proposal = smart_table::borrow_mut(&mut dao.proposals, proposal_id);
        let current_time = timestamp::now_seconds();
        
        // íˆ¬í‘œ ê¸°ê°„ í™•ì¸
        assert!(current_time >= proposal.voting_starts_at, E_VOTING_NOT_STARTED);
        assert!(current_time <= proposal.voting_ends_at, E_VOTING_ENDED);
        assert!(proposal.status == 1, E_PROPOSAL_NOT_ACTIVE); // active
        
        // ì¤‘ë³µ íˆ¬í‘œ ë°©ì§€
        assert!(!smart_table::contains(&proposal.voters, voter_addr), E_ALREADY_VOTED);
        
        // íˆ¬í‘œ ê°€ì¤‘ì¹˜ ê³„ì‚°
        let vote_weight = calculate_vote_weight(dao, voter_addr, proposal_id);
        assert!(vote_weight >= dao.voting_config.minimum_vote_weight, E_INSUFFICIENT_VOTING_POWER);
        
        // ì¿¼ë“œë¼í‹± íˆ¬í‘œ ê°€ì¤‘ì¹˜ ê³„ì‚°
        let quadratic_weight = if (dao.quadratic_voting_enabled && option::is_some(&quadratic_credits)) {
            let credits = *option::borrow(&quadratic_credits);
            math64::sqrt(credits)
        } else {
            0
        };
        
        // íˆ¬í‘œ ê¸°ë¡
        let vote = Vote {
            voter: voter_addr,
            support,
            weight: vote_weight,
            quadratic_weight,
            reason,
            voted_at: current_time
        };
        
        smart_table::add(&mut proposal.voters, voter_addr, vote);
        
        // íˆ¬í‘œ ì§‘ê³„
        match (support) {
            0 => {
                proposal.votes_against = proposal.votes_against + vote_weight;
                proposal.quadratic_votes_against = proposal.quadratic_votes_against + quadratic_weight;
            },
            1 => {
                proposal.votes_for = proposal.votes_for + vote_weight;
                proposal.quadratic_votes_for = proposal.quadratic_votes_for + quadratic_weight;
            },
            2 => {
                proposal.votes_abstain = proposal.votes_abstain + vote_weight;
            },
            _ => {}
        };
        
        proposal.total_votes = proposal.votes_for + proposal.votes_against + proposal.votes_abstain;
        dao.total_votes_cast = dao.total_votes_cast + 1;
        
        // ì°¸ì—¬ ë³´ìƒ ì§€ê¸‰
        if (dao.participation_rewards_enabled) {
            distribute_participation_reward(dao, voter_addr);
        };
        
        // ì‚¬ìš©ì ì°¸ì—¬ ê¸°ë¡ ì—…ë°ì´íŠ¸
        if (smart_table::contains(&dao.user_stakes, voter_addr)) {
            let user_stake = smart_table::borrow_mut(&mut dao.user_stakes, voter_addr);
            vector::push_back(&mut user_stake.proposals_voted, proposal_id);
            user_stake.participation_score = user_stake.participation_score + 1;
        };
        
        // ì¡°ê¸° ì‹¤í–‰ í™•ì¸
        if (dao.voting_config.early_execution_enabled) {
            check_early_execution(dao, proposal);
        };
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut dao.governance_events, GovernanceEvent {
            event_type: string::utf8(b"vote_cast"),
            user: voter_addr,
            proposal_id: option::some(proposal_id),
            additional_data: support.to_string(),
            timestamp: current_time
        });
    }
    
    /// ìœ„ì„ ì„¤ì •
    public fun delegate_votes(
        delegator: &signer,
        dao_addr: address,
        delegate: address,
        amount: u64,
        delegation_type: u8,
        expiry: u64
    ) acquires DAOGovernance {
        let delegator_addr = signer::address_of(delegator);
        let dao = borrow_global_mut<DAOGovernance>(dao_addr);
        
        assert!(delegator_addr != delegate, E_SELF_DELEGATION);
        assert!(amount > 0, E_INVALID_AMOUNT);
        assert!(expiry > timestamp::now_seconds(), E_INVALID_EXPIRY);
        
        // ìœ„ì„ìì˜ íˆ¬í‘œê¶Œ í™•ì¸
        let available_power = get_available_voting_power(dao, delegator_addr);
        assert!(available_power >= amount, E_INSUFFICIENT_VOTING_POWER);
        
        let current_time = timestamp::now_seconds();
        
        // ê¸°ì¡´ ìœ„ì„ í•´ì œ
        if (smart_table::contains(&dao.delegations, delegator_addr)) {
            let old_delegation = smart_table::remove(&mut dao.delegations, delegator_addr);
            
            // ê¸°ì¡´ ëŒ€ë¦¬ì¸ì˜ í†µê³„ ì—…ë°ì´íŠ¸
            if (smart_table::contains(&dao.delegates, old_delegation.delegate)) {
                let old_delegate_profile = smart_table::borrow_mut(&mut dao.delegates, old_delegation.delegate);
                old_delegate_profile.total_delegated = old_delegate_profile.total_delegated - old_delegation.delegation_amount;
                old_delegate_profile.delegator_count = old_delegate_profile.delegator_count - 1;
            }
        };
        
        // ìƒˆë¡œìš´ ìœ„ì„ ì„¤ì •
        let delegation = Delegation {
            delegator: delegator_addr,
            delegate,
            delegation_amount: amount,
            delegation_type,
            expiry,
            created_at: current_time
        };
        
        smart_table::add(&mut dao.delegations, delegator_addr, delegation);
        
        // ëŒ€ë¦¬ì¸ í”„ë¡œí•„ ì—…ë°ì´íŠ¸
        if (smart_table::contains(&dao.delegates, delegate)) {
            let delegate_profile = smart_table::borrow_mut(&mut dao.delegates, delegate);
            delegate_profile.total_delegated = delegate_profile.total_delegated + amount;
            delegate_profile.delegator_count = delegate_profile.delegator_count + 1;
            delegate_profile.last_activity = current_time;
        } else {
            // ìƒˆë¡œìš´ ëŒ€ë¦¬ì¸ í”„ë¡œí•„ ìƒì„±
            let new_delegate_profile = DelegateProfile {
                delegate,
                name: string::utf8(b""),
                description: string::utf8(b""),
                platform_url: option::none(),
                total_delegated: amount,
                delegator_count: 1,
                proposals_voted: 0,
                participation_rate: 0,
                expertise_areas: vector::empty(),
                verified: false,
                verification_date: 0,
                created_at: current_time,
                last_activity: current_time
            };
            smart_table::add(&mut dao.delegates, delegate, new_delegate_profile);
        };
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut dao.governance_events, GovernanceEvent {
            event_type: string::utf8(b"delegation_created"),
            user: delegator_addr,
            proposal_id: option::none(),
            additional_data: delegate.to_string(),
            timestamp: current_time
        });
    }
    
    /// ì œì•ˆ ì‹¤í–‰
    public fun execute_proposal(
        executor: &signer,
        dao_addr: address,
        proposal_id: u64
    ) acquires DAOGovernance {
        let executor_addr = signer::address_of(executor);
        let dao = borrow_global_mut<DAOGovernance>(dao_addr);
        
        assert!(smart_table::contains(&dao.proposals, proposal_id), E_PROPOSAL_NOT_FOUND);
        
        let proposal = smart_table::borrow_mut(&mut dao.proposals, proposal_id);
        let current_time = timestamp::now_seconds();
        
        // ì‹¤í–‰ ì¡°ê±´ í™•ì¸
        assert!(proposal.status == 2, E_PROPOSAL_NOT_SUCCEEDED); // succeeded
        assert!(current_time >= proposal.execution_eta, E_EXECUTION_NOT_READY);
        assert!(current_time <= proposal.execution_eta + dao.execution_window, E_EXECUTION_EXPIRED);
        
        // ë©€í‹°ì‹œê·¸ í™•ì¸ (ì¤‘ìš”í•œ ì œì•ˆì˜ ê²½ìš°)
        if (is_critical_proposal(proposal)) {
            assert!(
                vector::contains(&dao.multisig_signers, &executor_addr) || 
                executor_addr == *option::borrow(&dao.guardian_council),
                E_UNAUTHORIZED_EXECUTION
            );
        };
        
        // ì‹¤í–‰ ì•¡ì…˜ë“¤ ìˆ˜í–‰
        let i = 0;
        while (i < vector::length(&proposal.execution_data)) {
            let action = vector::borrow(&proposal.execution_data, i);
            execute_action(dao_addr, action);
            i = i + 1;
        };
        
        proposal.status = 4; // executed
        
        // ì œì•ˆì ìŠ¤í…Œì´í¬ ë°˜í™˜
        if (smart_table::contains(&dao.user_stakes, proposal.proposer)) {
            let proposer_stake = smart_table::borrow_mut(&mut dao.user_stakes, proposal.proposer);
            proposer_stake.staked_amount = proposer_stake.staked_amount + proposal.proposer_stake;
        };
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut dao.governance_events, GovernanceEvent {
            event_type: string::utf8(b"proposal_executed"),
            user: executor_addr,
            proposal_id: option::some(proposal_id),
            additional_data: string::utf8(b""),
            timestamp: current_time
        });
    }
    
    /// ìœ„ì›íšŒ ìƒì„±
    public fun create_committee(
        creator: &signer,
        dao_addr: address,
        name: String,
        description: String,
        members: vector<address>,
        member_limit: u8,
        focus_areas: vector<String>
    ) acquires DAOGovernance {
        let creator_addr = signer::address_of(creator);
        let dao = borrow_global_mut<DAOGovernance>(dao_addr);
        
        // ê¶Œí•œ í™•ì¸
        assert!(
            creator_addr == *option::borrow(&dao.guardian_council) ||
            get_voting_power(dao, creator_addr) >= dao.staking_requirement * 10,
            E_INSUFFICIENT_PERMISSIONS
        );
        
        assert!(!smart_table::contains(&dao.committees, name), E_COMMITTEE_EXISTS);
        assert!(vector::length(&members) <= (member_limit as u64), E_TOO_MANY_MEMBERS);
        
        let committee = Committee {
            name,
            description,
            members,
            member_limit,
            proposal_threshold: dao.staking_requirement / 2, // ìœ„ì›íšŒëŠ” ë‚®ì€ ì„ê³„ê°’
            voting_period: dao.voting_config.voting_period / 2, // ì§§ì€ íˆ¬í‘œ ê¸°ê°„
            focus_areas,
            proposals_reviewed: 0,
            decisions_made: 0,
            is_active: true,
            created_at: timestamp::now_seconds()
        };
        
        smart_table::add(&mut dao.committees, name, committee);
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut dao.governance_events, GovernanceEvent {
            event_type: string::utf8(b"committee_created"),
            user: creator_addr,
            proposal_id: option::none(),
            additional_data: name,
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ì¿¼ë“œë¼í‹± íˆ¬í‘œ í™œì„±í™”/ë¹„í™œì„±í™”
    public fun toggle_quadratic_voting(
        admin: &signer,
        dao_addr: address,
        enabled: bool
    ) acquires DAOGovernance {
        let admin_addr = signer::address_of(admin);
        let dao = borrow_global_mut<DAOGovernance>(dao_addr);
        
        assert!(
            admin_addr == *option::borrow(&dao.guardian_council),
            E_UNAUTHORIZED
        );
        
        dao.quadratic_voting_enabled = enabled;
        dao.last_updated = timestamp::now_seconds();
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut dao.governance_events, GovernanceEvent {
            event_type: string::utf8(b"quadratic_voting_toggled"),
            user: admin_addr,
            proposal_id: option::none(),
            additional_data: enabled.to_string(),
            timestamp: timestamp::now_seconds()
        });
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    
    /// íˆ¬í‘œ ê°€ì¤‘ì¹˜ ê³„ì‚°
    fun calculate_vote_weight(dao: &DAOGovernance, voter: address, proposal_id: u64): u64 {
        match (dao.voting_config.vote_weight_strategy) {
            0 => {
                // í† í° ì”ì•¡ ê¸°ë°˜
                primary_fungible_store::balance(voter, dao.governance_token)
            },
            1 => {
                // ìŠ¤í…Œì´í‚¹ ì”ì•¡ ê¸°ë°˜
                if (smart_table::contains(&dao.user_stakes, voter)) {
                    let user_stake = smart_table::borrow(&dao.user_stakes, voter);
                    user_stake.staked_amount
                } else {
                    0
                }
            },
            2 => {
                // ì‹œê°„ ê°€ì¤‘ ì”ì•¡ (ìŠ¤í…Œì´í‚¹ ê¸°ê°„ ê³ ë ¤)
                calculate_time_weighted_balance(dao, voter)
            },
            _ => 0
        }
    }
    
    /// ì‹œê°„ ê°€ì¤‘ ì”ì•¡ ê³„ì‚°
    fun calculate_time_weighted_balance(dao: &DAOGovernance, voter: address): u64 {
        if (!smart_table::contains(&dao.user_stakes, voter)) {
            return 0
        };
        
        let user_stake = smart_table::borrow(&dao.user_stakes, voter);
        let current_time = timestamp::now_seconds();
        let stake_duration = current_time - user_stake.created_at;
        
        // ìŠ¤í…Œì´í‚¹ ê¸°ê°„ì— ë”°ë¼ ê°€ì¤‘ì¹˜ ì ìš© (ìµœëŒ€ 2ë°°)
        let time_multiplier = math64::min(
            10000 + (stake_duration * 10000) / (365 * 24 * 3600), // 1ë…„ ê¸°ì¤€
            20000 // ìµœëŒ€ 2ë°°
        );
        
        (user_stake.staked_amount * time_multiplier) / 10000
    }
    
    /// ì‚¬ìš©ê°€ëŠ¥í•œ íˆ¬í‘œê¶Œ ê³„ì‚°
    fun get_available_voting_power(dao: &DAOGovernance, user: address): u64 {
        let total_power = get_voting_power(dao, user);
        
        // ê¸°ì¡´ ìœ„ì„ëŸ‰ ì°¨ê°
        if (smart_table::contains(&dao.delegations, user)) {
            let delegation = smart_table::borrow(&dao.delegations, user);
            if (delegation.expiry > timestamp::now_seconds()) {
                total_power - delegation.delegation_amount
            } else {
                total_power
            }
        } else {
            total_power
        }
    }
    
    /// ì´ íˆ¬í‘œê¶Œ ê³„ì‚°
    fun get_voting_power(dao: &DAOGovernance, user: address): u64 {
        let mut total_power = calculate_vote_weight(dao, user, 0);
        
        // ìœ„ì„ë°›ì€ íˆ¬í‘œê¶Œ ì¶”ê°€
        smart_table::for_each_ref(&dao.delegations, |delegator, delegation| {
            if (delegation.delegate == user && delegation.expiry > timestamp::now_seconds()) {
                total_power = total_power + delegation.delegation_amount;
            }
        });
        
        total_power
    }
    
    /// ì°¸ì—¬ ë³´ìƒ ì§€ê¸‰
    fun distribute_participation_reward(dao: &mut DAOGovernance, voter: address) {
        if (dao.reward_pool >= dao.rewards_per_vote) {
            if (smart_table::contains(&dao.user_stakes, voter)) {
                let user_stake = smart_table::borrow_mut(&mut dao.user_stakes, voter);
                user_stake.unclaimed_rewards = user_stake.unclaimed_rewards + dao.rewards_per_vote;
                dao.reward_pool = dao.reward_pool - dao.rewards_per_vote;
            }
        }
    }
    
    /// ì¡°ê¸° ì‹¤í–‰ í™•ì¸
    fun check_early_execution(dao: &DAOGovernance, proposal: &mut Proposal) {
        let total_supply = get_total_voting_supply(dao);
        let participation_rate = (proposal.total_votes * 10000) / total_supply;
        
        if (participation_rate >= dao.quorum_threshold) {
            let approval_rate = (proposal.votes_for * 10000) / proposal.total_votes;
            
            if (approval_rate >= dao.voting_config.early_execution_threshold) {
                // ì¡°ê¸° ì‹¤í–‰ ê°€ëŠ¥
                proposal.status = 2; // succeeded
                proposal.voting_ends_at = timestamp::now_seconds();
            }
        }
    }
    
    /// ì¤‘ìš”í•œ ì œì•ˆ ì—¬ë¶€ í™•ì¸
    fun is_critical_proposal(proposal: &Proposal): bool {
        proposal.proposal_type == 1 || // ì—…ê·¸ë ˆì´ë“œ ì œì•ˆ
        proposal.proposal_type == 2    // ì§€ì¶œ ì œì•ˆ
    }
    
    /// ì•¡ì…˜ ì‹¤í–‰
    fun execute_action(dao_addr: address, action: &ExecutionAction) {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” íƒ€ê²Ÿ ì»¨íŠ¸ë™íŠ¸ì˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
        // ì—¬ê¸°ì„œëŠ” ì˜ˆì‹œë¡œ ê°„ë‹¨í•œ ë¡œê·¸ë§Œ ë‚¨ê¹€
        // call_function(action.target, action.function_name, action.args, action.value);
    }
    
    /// ì´ íˆ¬í‘œ ê³µê¸‰ëŸ‰ ì¡°íšŒ
    fun get_total_voting_supply(dao: &DAOGovernance): u64 {
        // ì‹¤ì œë¡œëŠ” í† í°ì˜ ì´ ê³µê¸‰ëŸ‰ì—ì„œ ë½ì—…ëœ í† í° ë“±ì„ ì œì™¸
        dao.total_staked + 1000000 // ê°„ë‹¨í•œ ì¶”ì •
    }
    
    // ì¡°íšŒ í•¨ìˆ˜ë“¤
    
    /// ì œì•ˆ ì •ë³´ ì¡°íšŒ
    public fun get_proposal(
        dao_addr: address,
        proposal_id: u64
    ): Option<ProposalInfo> acquires DAOGovernance {
        let dao = borrow_global<DAOGovernance>(dao_addr);
        
        if (smart_table::contains(&dao.proposals, proposal_id)) {
            let proposal = smart_table::borrow(&dao.proposals, proposal_id);
            
            option::some(ProposalInfo {
                id: proposal.id,
                proposer: proposal.proposer,
                title: proposal.title,
                description: proposal.description,
                proposal_type: proposal.proposal_type,
                votes_for: proposal.votes_for,
                votes_against: proposal.votes_against,
                votes_abstain: proposal.votes_abstain,
                total_votes: proposal.total_votes,
                created_at: proposal.created_at,
                voting_starts_at: proposal.voting_starts_at,
                voting_ends_at: proposal.voting_ends_at,
                execution_eta: proposal.execution_eta,
                status: proposal.status,
                ipfs_hash: proposal.ipfs_hash
            })
        } else {
            option::none()
        }
    }
    
    struct ProposalInfo has drop {
        id: u64,
        proposer: address,
        title: String,
        description: String,
        proposal_type: u8,
        votes_for: u64,
        votes_against: u64,
        votes_abstain: u64,
        total_votes: u64,
        created_at: u64,
        voting_starts_at: u64,
        voting_ends_at: u64,
        execution_eta: u64,
        status: u8,
        ipfs_hash: Option<String>
    }
    
    /// ì‚¬ìš©ì íˆ¬í‘œê¶Œ ì¡°íšŒ
    public fun get_user_voting_power(
        dao_addr: address,
        user: address
    ): u64 acquires DAOGovernance {
        let dao = borrow_global<DAOGovernance>(dao_addr);
        get_voting_power(dao, user)
    }
    
    /// ëŒ€ë¦¬ì¸ ì •ë³´ ì¡°íšŒ
    public fun get_delegate_info(
        dao_addr: address,
        delegate: address
    ): Option<DelegateProfile> acquires DAOGovernance {
        let dao = borrow_global<DAOGovernance>(dao_addr);
        
        if (smart_table::contains(&dao.delegates, delegate)) {
            option::some(*smart_table::borrow(&dao.delegates, delegate))
        } else {
            option::none()
        }
    }
    
    /// DAO í†µê³„ ì¡°íšŒ
    public fun get_dao_stats(dao_addr: address): DAOStats acquires DAOGovernance {
        let dao = borrow_global<DAOGovernance>(dao_addr);
        
        DAOStats {
            total_proposals: dao.total_proposals,
            total_votes_cast: dao.total_votes_cast,
            total_staked: dao.total_staked,
            active_delegates: smart_table::length(&dao.delegates),
            participation_rate: calculate_average_participation_rate(dao),
            treasury_balance: get_treasury_balance(dao_addr)
        }
    }
    
    struct DAOStats has drop {
        total_proposals: u64,
        total_votes_cast: u64,
        total_staked: u64,
        active_delegates: u64,
        participation_rate: u64,
        treasury_balance: u64
    }
    
    fun calculate_average_participation_rate(dao: &DAOGovernance): u64 {
        if (dao.total_proposals == 0) {
            return 0
        };
        
        // ê°„ë‹¨í•œ ì°¸ì—¬ìœ¨ ê³„ì‚°
        (dao.total_votes_cast * 10000) / (dao.total_proposals * get_total_voting_supply(dao))
    }
    
    fun get_treasury_balance(dao_addr: address): u64 {
        // DAO ê¸ˆê³  ì”ì•¡ ì¡°íšŒ
        1000000 // placeholder
    }
    
    // ì—ëŸ¬ ì½”ë“œ
    const E_INVALID_QUORUM: u64 = 1;
    const E_INVALID_THRESHOLD: u64 = 2;
    const E_INVALID_VOTING_PERIOD: u64 = 3;
    const E_DAO_PAUSED: u64 = 4;
    const E_INVALID_AMOUNT: u64 = 5;
    const E_INSUFFICIENT_VOTING_POWER: u64 = 6;
    const E_INSUFFICIENT_STAKE: u64 = 7;
    const E_NO_STAKE_FOUND: u64 = 8;
    const E_PROPOSAL_NOT_FOUND: u64 = 9;
    const E_INVALID_VOTE_OPTION: u64 = 10;
    const E_VOTING_NOT_STARTED: u64 = 11;
    const E_VOTING_ENDED: u64 = 12;
    const E_PROPOSAL_NOT_ACTIVE: u64 = 13;
    const E_ALREADY_VOTED: u64 = 14;
    const E_SELF_DELEGATION: u64 = 15;
    const E_INVALID_EXPIRY: u64 = 16;
    const E_PROPOSAL_NOT_SUCCEEDED: u64 = 17;
    const E_EXECUTION_NOT_READY: u64 = 18;
    const E_EXECUTION_EXPIRED: u64 = 19;
    const E_UNAUTHORIZED_EXECUTION: u64 = 20;
    const E_INSUFFICIENT_PERMISSIONS: u64 = 21;
    const E_COMMITTEE_EXISTS: u64 = 22;
    const E_TOO_MANY_MEMBERS: u64 = 23;
    const E_UNAUTHORIZED: u64 = 24;
}
```

## ğŸ—³ï¸ TypeScript SDK í†µí•©

### ì¢…í•© ê±°ë²„ë„ŒìŠ¤ ê´€ë¦¬ í´ë˜ìŠ¤
```typescript
import {
  MovementClient,
  MovementAccount,
  Network
} from "@movementnetwork/ts-sdk";

interface ProposalData {
  title: string;
  description: string;
  proposalType: number;
  executionActions: ExecutionAction[];
  ipfsHash?: string;
  committee?: string;
}

interface ExecutionAction {
  target: string;
  functionName: string;
  args: Uint8Array;
  value: number;
}

interface VoteOption {
  support: number; // 0: against, 1: for, 2: abstain
  reason: string;
  quadraticCredits?: number;
}

interface DelegationConfig {
  delegate: string;
  amount: number;
  delegationType: number;
  expiry: number;
}

class DAOGovernanceManager {
  private client: MovementClient;
  private moduleAddress: string;
  
  constructor(client: MovementClient, moduleAddress: string) {
    this.client = client;
    this.moduleAddress = moduleAddress;
  }
  
  // DAO ê±°ë²„ë„ŒìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
  async initializeDAO(
    admin: MovementAccount,
    name: string,
    description: string,
    governanceToken: string,
    votingPeriod: number,
    quorumThreshold: number,
    approvalThreshold: number
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::comprehensive_dao::initialize_dao_governance`,
      type_arguments: [],
      arguments: [
        name,
        description,
        governanceToken,
        votingPeriod,
        quorumThreshold,
        approvalThreshold
      ]
    };
    
    const txn = await this.client.generateTransaction(admin.address(), payload);
    const signedTxn = await this.client.signTransaction(admin, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ê±°ë²„ë„ŒìŠ¤ í† í° ìŠ¤í…Œì´í‚¹
  async stakeGovernanceTokens(
    user: MovementAccount,
    daoAddress: string,
    amount: number,
    lockPeriod: number
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::comprehensive_dao::stake_governance_tokens`,
      type_arguments: [],
      arguments: [
        daoAddress,
        amount.toString(),
        lockPeriod.toString()
      ]
    };
    
    const txn = await this.client.generateTransaction(user.address(), payload);
    const signedTxn = await this.client.signTransaction(user, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ì œì•ˆ ìƒì„±
  async createProposal(
    proposer: MovementAccount,
    daoAddress: string,
    proposalData: ProposalData
  ): Promise<{
    success: boolean;
    proposalId?: number;
    transactionHash: string;
  }> {
    try {
      const payload = {
        type: "entry_function_payload",
        function: `${this.moduleAddress}::comprehensive_dao::create_proposal`,
        type_arguments: [],
        arguments: [
          daoAddress,
          proposalData.title,
          proposalData.description,
          proposalData.proposalType,
          proposalData.executionActions,
          proposalData.ipfsHash ? [proposalData.ipfsHash] : [],
          proposalData.committee ? [proposalData.committee] : []
        ]
      };
      
      const txn = await this.client.generateTransaction(proposer.address(), payload);
      const signedTxn = await this.client.signTransaction(proposer, txn);
      const response = await this.client.submitTransaction(signedTxn);
      
      await this.client.waitForTransaction(response.hash);
      
      // ì´ë²¤íŠ¸ì—ì„œ ì œì•ˆ ID ì¶”ì¶œ
      const proposalId = await this.extractProposalIdFromTransaction(response.hash);
      
      return {
        success: true,
        proposalId,
        transactionHash: response.hash
      };
    } catch (error: any) {
      return {
        success: false,
        transactionHash: error.hash || ""
      };
    }
  }
  
  // íˆ¬í‘œ ì‹¤í–‰
  async castVote(
    voter: MovementAccount,
    daoAddress: string,
    proposalId: number,
    voteOption: VoteOption
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::comprehensive_dao::cast_vote`,
      type_arguments: [],
      arguments: [
        daoAddress,
        proposalId.toString(),
        voteOption.support.toString(),
        voteOption.reason,
        voteOption.quadraticCredits ? [voteOption.quadraticCredits.toString()] : []
      ]
    };
    
    const txn = await this.client.generateTransaction(voter.address(), payload);
    const signedTxn = await this.client.signTransaction(voter, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ìœ„ì„ ì„¤ì •
  async delegateVotes(
    delegator: MovementAccount,
    daoAddress: string,
    delegationConfig: DelegationConfig
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::comprehensive_dao::delegate_votes`,
      type_arguments: [],
      arguments: [
        daoAddress,
        delegationConfig.delegate,
        delegationConfig.amount.toString(),
        delegationConfig.delegationType.toString(),
        delegationConfig.expiry.toString()
      ]
    };
    
    const txn = await this.client.generateTransaction(delegator.address(), payload);
    const signedTxn = await this.client.signTransaction(delegator, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ì œì•ˆ ì‹¤í–‰
  async executeProposal(
    executor: MovementAccount,
    daoAddress: string,
    proposalId: number
  ): Promise<{
    success: boolean;
    transactionHash: string;
    error?: string;
  }> {
    try {
      const payload = {
        type: "entry_function_payload",
        function: `${this.moduleAddress}::comprehensive_dao::execute_proposal`,
        type_arguments: [],
        arguments: [
          daoAddress,
          proposalId.toString()
        ]
      };
      
      const txn = await this.client.generateTransaction(executor.address(), payload);
      const signedTxn = await this.client.signTransaction(executor, txn);
      const response = await this.client.submitTransaction(signedTxn);
      
      await this.client.waitForTransaction(response.hash);
      
      return {
        success: true,
        transactionHash: response.hash
      };
    } catch (error: any) {
      return {
        success: false,
        transactionHash: error.hash || "",
        error: error.message
      };
    }
  }
  
  // ìœ„ì›íšŒ ìƒì„±
  async createCommittee(
    creator: MovementAccount,
    daoAddress: string,
    name: string,
    description: string,
    members: string[],
    memberLimit: number,
    focusAreas: string[]
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::comprehensive_dao::create_committee`,
      type_arguments: [],
      arguments: [
        daoAddress,
        name,
        description,
        members,
        memberLimit.toString(),
        focusAreas
      ]
    };
    
    const txn = await this.client.generateTransaction(creator.address(), payload);
    const signedTxn = await this.client.signTransaction(creator, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ì¿¼ë“œë¼í‹± íˆ¬í‘œ í† ê¸€
  async toggleQuadraticVoting(
    admin: MovementAccount,
    daoAddress: string,
    enabled: boolean
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::comprehensive_dao::toggle_quadratic_voting`,
      type_arguments: [],
      arguments: [
        daoAddress,
        enabled
      ]
    };
    
    const txn = await this.client.generateTransaction(admin.address(), payload);
    const signedTxn = await this.client.signTransaction(admin, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ì œì•ˆ ì •ë³´ ì¡°íšŒ
  async getProposal(
    daoAddress: string,
    proposalId: number
  ): Promise<any> {
    const payload = {
      function: `${this.moduleAddress}::comprehensive_dao::get_proposal`,
      type_arguments: [],
      arguments: [daoAddress, proposalId.toString()]
    };
    
    try {
      const result = await this.client.view(payload);
      if (result && result[0]) {
        return this.parseProposalInfo(result[0]);
      }
      return null;
    } catch (error) {
      console.error("Failed to get proposal:", error);
      return null;
    }
  }
  
  // ì‚¬ìš©ì íˆ¬í‘œê¶Œ ì¡°íšŒ
  async getUserVotingPower(
    daoAddress: string,
    userAddress: string
  ): Promise<number> {
    const payload = {
      function: `${this.moduleAddress}::comprehensive_dao::get_user_voting_power`,
      type_arguments: [],
      arguments: [daoAddress, userAddress]
    };
    
    try {
      const result = await this.client.view(payload);
      return parseInt(result[0] as string);
    } catch (error) {
      console.error("Failed to get voting power:", error);
      return 0;
    }
  }
  
  // ëŒ€ë¦¬ì¸ ì •ë³´ ì¡°íšŒ
  async getDelegateInfo(
    daoAddress: string,
    delegateAddress: string
  ): Promise<any> {
    const payload = {
      function: `${this.moduleAddress}::comprehensive_dao::get_delegate_info`,
      type_arguments: [],
      arguments: [daoAddress, delegateAddress]
    };
    
    try {
      const result = await this.client.view(payload);
      if (result && result[0]) {
        return this.parseDelegateInfo(result[0]);
      }
      return null;
    } catch (error) {
      console.error("Failed to get delegate info:", error);
      return null;
    }
  }
  
  // DAO í†µê³„ ì¡°íšŒ
  async getDAOStats(daoAddress: string): Promise<any> {
    const payload = {
      function: `${this.moduleAddress}::comprehensive_dao::get_dao_stats`,
      type_arguments: [],
      arguments: [daoAddress]
    };
    
    try {
      const result = await this.client.view(payload);
      return this.parseDAOStats(result[0]);
    } catch (error) {
      console.error("Failed to get DAO stats:", error);
      return null;
    }
  }
  
  // í™œì„± ì œì•ˆ ëª©ë¡ ì¡°íšŒ
  async getActiveProposals(daoAddress: string): Promise<any[]> {
    // ì‹¤ì œë¡œëŠ” ì¸ë±ì‹± ì„œë¹„ìŠ¤ë‚˜ ì´ë²¤íŠ¸ ë¡œê·¸ë¥¼ í†µí•´ ì¡°íšŒ
    const allProposals = await this.getAllProposals(daoAddress);
    const currentTime = Math.floor(Date.now() / 1000);
    
    return allProposals.filter(proposal => 
      proposal.status === 1 && // active
      proposal.votingStartsAt <= currentTime &&
      proposal.votingEndsAt > currentTime
    );
  }
  
  // ì œì•ˆ ì‹œë®¬ë ˆì´ì…˜
  async simulateProposal(
    daoAddress: string,
    proposalData: ProposalData
  ): Promise<{
    estimatedGas: number;
    requiredStake: number;
    executionDelay: number;
    potentialOutcome: string;
  }> {
    // ì œì•ˆ ì‹¤í–‰ ë¹„ìš© ì¶”ì •
    const estimatedGas = await this.estimateExecutionGas(proposalData.executionActions);
    
    // í•„ìš”í•œ ìŠ¤í…Œì´í‚¹ ìš”êµ¬ì‚¬í•­ ì¡°íšŒ
    const requiredStake = await this.getStakingRequirement(daoAddress);
    
    // ì‹¤í–‰ ì§€ì—°ì‹œê°„ ì¡°íšŒ
    const executionDelay = await this.getTimelockDelay(daoAddress);
    
    // ê²°ê³¼ ì˜ˆì¸¡ (ê°„ë‹¨í•œ íœ´ë¦¬ìŠ¤í‹±)
    const potentialOutcome = await this.predictProposalOutcome(daoAddress, proposalData);
    
    return {
      estimatedGas,
      requiredStake,
      executionDelay,
      potentialOutcome
    };
  }
  
  // ê±°ë²„ë„ŒìŠ¤ ì°¸ì—¬ ë¶„ì„
  async analyzeParticipation(
    daoAddress: string,
    userAddress: string,
    period: number = 30 // ì¼ìˆ˜
  ): Promise<{
    proposalsVoted: number;
    participationRate: number;
    votingPowerUsed: number;
    rewardsEarned: number;
    delegationsReceived: number;
  }> {
    // ì‹¤ì œë¡œëŠ” ì´ë²¤íŠ¸ ë¡œê·¸ë‚˜ ì¸ë±ì‹± ì„œë¹„ìŠ¤ì—ì„œ ë°ì´í„° ìˆ˜ì§‘
    const userStats = await this.getUserStats(daoAddress, userAddress, period);
    
    return {
      proposalsVoted: userStats.proposalsVoted,
      participationRate: userStats.participationRate,
      votingPowerUsed: userStats.votingPowerUsed,
      rewardsEarned: userStats.rewardsEarned,
      delegationsReceived: userStats.delegationsReceived
    };
  }
  
  // ê±°ë²„ë„ŒìŠ¤ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§
  async monitorGovernanceEvents(
    daoAddress: string,
    callback: (event: any) => void,
    eventTypes?: string[]
  ): Promise<void> {
    const pollInterval = 5000; // 5ì´ˆë§ˆë‹¤
    
    const poll = async () => {
      try {
        const events = await this.getRecentGovernanceEvents(daoAddress, eventTypes);
        events.forEach(callback);
      } catch (error) {
        console.error("Failed to poll governance events:", error);
      }
      
      setTimeout(poll, pollInterval);
    };
    
    poll();
  }
  
  // í—¬í¼ í•¨ìˆ˜ë“¤
  
  private async extractProposalIdFromTransaction(txHash: string): Promise<number> {
    // íŠ¸ëœì­ì…˜ ì´ë²¤íŠ¸ì—ì„œ ì œì•ˆ ID ì¶”ì¶œ
    const txResult = await this.client.getTransactionByHash(txHash);
    // ì‹¤ì œë¡œëŠ” ì´ë²¤íŠ¸ íŒŒì‹±
    return 1; // placeholder
  }
  
  private parseProposalInfo(data: any): any {
    return {
      id: parseInt(data.id),
      proposer: data.proposer,
      title: data.title,
      description: data.description,
      proposalType: parseInt(data.proposal_type),
      votesFor: parseInt(data.votes_for),
      votesAgainst: parseInt(data.votes_against),
      votesAbstain: parseInt(data.votes_abstain),
      totalVotes: parseInt(data.total_votes),
      createdAt: parseInt(data.created_at),
      votingStartsAt: parseInt(data.voting_starts_at),
      votingEndsAt: parseInt(data.voting_ends_at),
      executionEta: parseInt(data.execution_eta),
      status: parseInt(data.status),
      ipfsHash: data.ipfs_hash
    };
  }
  
  private parseDelegateInfo(data: any): any {
    return {
      delegate: data.delegate,
      name: data.name,
      description: data.description,
      platformUrl: data.platform_url,
      totalDelegated: parseInt(data.total_delegated),
      delegatorCount: parseInt(data.delegator_count),
      proposalsVoted: parseInt(data.proposals_voted),
      participationRate: parseInt(data.participation_rate),
      expertiseAreas: data.expertise_areas,
      verified: data.verified,
      verificationDate: parseInt(data.verification_date),
      createdAt: parseInt(data.created_at),
      lastActivity: parseInt(data.last_activity)
    };
  }
  
  private parseDAOStats(data: any): any {
    return {
      totalProposals: parseInt(data.total_proposals),
      totalVotesCast: parseInt(data.total_votes_cast),
      totalStaked: parseInt(data.total_staked),
      activeDelegates: parseInt(data.active_delegates),
      participationRate: parseInt(data.participation_rate),
      treasuryBalance: parseInt(data.treasury_balance)
    };
  }
  
  private async getAllProposals(daoAddress: string): Promise<any[]> {
    // ì‹¤ì œë¡œëŠ” ì¸ë±ì‹± ì„œë¹„ìŠ¤ì—ì„œ ì¡°íšŒ
    return []; // placeholder
  }
  
  private async estimateExecutionGas(actions: ExecutionAction[]): Promise<number> {
    // ê° ì•¡ì…˜ì˜ ê°€ìŠ¤ ë¹„ìš© ì¶”ì •
    return actions.length * 100000; // ê°„ë‹¨í•œ ì¶”ì •
  }
  
  private async getStakingRequirement(daoAddress: string): Promise<number> {
    // DAO ì„¤ì •ì—ì„œ ìŠ¤í…Œì´í‚¹ ìš”êµ¬ì‚¬í•­ ì¡°íšŒ
    return 10000; // placeholder
  }
  
  private async getTimelockDelay(daoAddress: string): Promise<number> {
    // DAOì˜ íƒ€ì„ë½ ì§€ì—°ì‹œê°„ ì¡°íšŒ
    return 172800; // 2ì¼
  }
  
  private async predictProposalOutcome(
    daoAddress: string,
    proposalData: ProposalData
  ): Promise<string> {
    // ê°„ë‹¨í•œ ê²°ê³¼ ì˜ˆì¸¡ ë¡œì§
    return "likely_to_pass"; // placeholder
  }
  
  private async getUserStats(
    daoAddress: string,
    userAddress: string,
    period: number
  ): Promise<any> {
    // ì‚¬ìš©ì í†µê³„ ì¡°íšŒ
    return {
      proposalsVoted: 5,
      participationRate: 80,
      votingPowerUsed: 1000,
      rewardsEarned: 100,
      delegationsReceived: 2
    }; // placeholder
  }
  
  private async getRecentGovernanceEvents(
    daoAddress: string,
    eventTypes?: string[]
  ): Promise<any[]> {
    // ìµœê·¼ ê±°ë²„ë„ŒìŠ¤ ì´ë²¤íŠ¸ ì¡°íšŒ
    return []; // placeholder
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
async function setupDAOGovernance() {
  const client = new MovementClient({ network: Network.DEVNET });
  const admin = new MovementAccount();
  const daoManager = new DAOGovernanceManager(client, "0x1");
  
  // 1. DAO ì´ˆê¸°í™”
  const initTxHash = await daoManager.initializeDAO(
    admin,
    "DeFi Protocol DAO",
    "Decentralized governance for our DeFi protocol",
    "0x123...::governance_token", // ê±°ë²„ë„ŒìŠ¤ í† í° ì£¼ì†Œ
    604800, // 7ì¼ íˆ¬í‘œ ê¸°ê°„
    2500,   // 25% ì¿¼ëŸ¼
    5000    // 50% ìŠ¹ì¸ ì„ê³„ê°’
  );
  
  console.log("DAO initialized:", initTxHash);
  
  // 2. ê±°ë²„ë„ŒìŠ¤ í† í° ìŠ¤í…Œì´í‚¹
  const user = new MovementAccount();
  const stakeTxHash = await daoManager.stakeGovernanceTokens(
    user,
    "0x456...", // DAO ì£¼ì†Œ
    100000,     // ìŠ¤í…Œì´í‚¹ ì–‘
    2592000     // 30ì¼ ë½ì—…
  );
  
  console.log("Tokens staked:", stakeTxHash);
  
  // 3. ì œì•ˆ ìƒì„±
  const proposalData: ProposalData = {
    title: "Increase Trading Fee to 0.5%",
    description: "Proposal to increase the protocol trading fee from 0.3% to 0.5% to improve protocol revenue",
    proposalType: 0, // parameter change
    executionActions: [
      {
        target: "0x789...", // DEX ì»¨íŠ¸ë™íŠ¸ ì£¼ì†Œ
        functionName: "update_fee_rate",
        args: new Uint8Array([0, 50]), // 0.5% ì¸ì½”ë”©
        value: 0
      }
    ],
    ipfsHash: "QmYx7r8VQ9k3kNqV5oRjfNxWzqMp3XzKwCbPt7S4vFhGjX"
  };
  
  const proposalResult = await daoManager.createProposal(
    user,
    "0x456...",
    proposalData
  );
  
  if (proposalResult.success) {
    console.log("Proposal created:", proposalResult.proposalId);
    
    // 4. íˆ¬í‘œ ì‹¤í–‰
    const voteOption: VoteOption = {
      support: 1, // ì°¬ì„±
      reason: "This will improve protocol sustainability",
      quadraticCredits: 10000
    };
    
    const voteTxHash = await daoManager.castVote(
      user,
      "0x456...",
      proposalResult.proposalId!,
      voteOption
    );
    
    console.log("Vote cast:", voteTxHash);
    
    // 5. ì œì•ˆ ìƒíƒœ í™•ì¸
    const proposal = await daoManager.getProposal("0x456...", proposalResult.proposalId!);
    console.log("Proposal status:", proposal);
    
    // 6. DAO í†µê³„ ì¡°íšŒ
    const stats = await daoManager.getDAOStats("0x456...");
    console.log("DAO stats:", stats);
  }
  
  // 7. ê±°ë²„ë„ŒìŠ¤ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§
  await daoManager.monitorGovernanceEvents(
    "0x456...",
    (event) => {
      console.log("Governance event:", event);
    },
    ["proposal_created", "vote_cast", "proposal_executed"]
  );
}

// setupDAOGovernance().catch(console.error);
```

## ğŸ¯ ë§ˆë¬´ë¦¬

ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰ Movement Networkì˜ **ì™„ì „í•œ DeFi ê°œë°œ ê°€ì´ë“œ**ë¥¼ ì™„ì„±í–ˆìŠµë‹ˆë‹¤!

### ğŸ† **ì™„ì„±ëœ ì‹œìŠ¤í…œë“¤:**

1. **ğŸª™ Fungible Asset í”„ë ˆì„ì›Œí¬** - ê³ ê¸‰ í† í° ì‹œìŠ¤í…œ
2. **ğŸ¦ Lending & Borrowing** - ë‹´ë³´ ê¸°ë°˜ ëŒ€ì¶œ í”Œë«í¼  
3. **ğŸ”„ DEX & AMM** - íƒˆì¤‘ì•™í™” ê±°ë˜ì†Œ
4. **ğŸ›ï¸ ê±°ë²„ë„ŒìŠ¤ & DAO** - íˆ¬ëª…í•œ ì˜ì‚¬ê²°ì • ì‹œìŠ¤í…œ

### ğŸš€ **ë‹¤ìŒ ë‹¨ê³„:**

- **ì‹¤ì „ ë°°í¬**: í…ŒìŠ¤íŠ¸ë„·ì—ì„œ ì‹œìŠ¤í…œ ë°°í¬ ë° í…ŒìŠ¤íŠ¸
- **ë³´ì•ˆ ê°ì‚¬**: ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ë³´ì•ˆ ê²€í† 
- **ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤**: React/Vue.js í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ
- **ëª¨ë‹ˆí„°ë§**: ì˜¨ì²´ì¸ ë¶„ì„ ë° ëŒ€ì‹œë³´ë“œ êµ¬ì¶•

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Movement GitHub](https://github.com/movementnetwork)
- [Movement ë””ìŠ¤ì½”ë“œ](https://discord.gg/movementnetwork)
- [Move ì–¸ì–´ ê°€ì´ë“œ](https://move-language.github.io/move/)

---

*Movement Networkì—ì„œ ì°¨ì„¸ëŒ€ DeFi ìƒíƒœê³„ë¥¼ êµ¬ì¶•í•˜ì„¸ìš”! ğŸŒŸğŸš€*