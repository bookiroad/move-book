# ğŸª™ Fungible Asset í”„ë ˆì„ì›Œí¬

Movement Networkì˜ ë„¤ì´í‹°ë¸Œ Fungible Asset ì‹œìŠ¤í…œì„ ì™„ì „íˆ ë§ˆìŠ¤í„°í•˜ëŠ” ê°€ì´ë“œì…ë‹ˆë‹¤. í† í° ìƒì„±ë¶€í„° ê³ ê¸‰ DeFi í†µí•©ê¹Œì§€, ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ ê¸ˆìœµ ìì‚°ì„ êµ¬ì¶•í•©ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- Movement Fungible Asset í‘œì¤€ì„ ì™„ì „íˆ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì»¤ìŠ¤í…€ í† í°ì„ ìƒì„±í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë©€í‹°í† í° ì‹œìŠ¤í…œì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í† í° ë©”íƒ€ë°ì´í„°ë¥¼ ìµœì í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í¬ë¡œìŠ¤ì²´ì¸ í† í° ë¸Œë¦¬ì§€ë¥¼ í†µí•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ’ Movement Fungible Asset ê°œë…

### Fungible Asset vs Coin ì°¨ì´ì 
```
ğŸª™ Movement Fungible Assetì˜ ì¥ì :

ğŸ“ˆ ê¸°ëŠ¥ì„± (Functionality)
â”œâ”€â”€ ë” í’ë¶€í•œ ë©”íƒ€ë°ì´í„° ì§€ì›
â”œâ”€â”€ ë™ì  ê¶Œí•œ ê´€ë¦¬ ì‹œìŠ¤í…œ
â”œâ”€â”€ í™•ì¥ ê°€ëŠ¥í•œ í† í° í‘œì¤€
â””â”€â”€ ë„¤ì´í‹°ë¸Œ DeFi í†µí•©

ğŸ”’ ì•ˆì „ì„± (Safety)
â”œâ”€â”€ Object ê¸°ë°˜ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬
â”œâ”€â”€ íƒ€ì… ì•ˆì „í•œ í† í° ì¡°ì‘
â”œâ”€â”€ ìë™í™”ëœ ê¶Œí•œ ê²€ì¦
â””â”€â”€ ë©”ëª¨ë¦¬ ì•ˆì „ì„± ë³´ì¥

âš¡ ì„±ëŠ¥ (Performance)
â”œâ”€â”€ ìµœì í™”ëœ ìŠ¤í† ë¦¬ì§€ êµ¬ì¡°
â”œâ”€â”€ íš¨ìœ¨ì ì¸ ë°°ì¹˜ ì²˜ë¦¬
â”œâ”€â”€ ë‚®ì€ ê°€ìŠ¤ ë¹„ìš©
â””â”€â”€ ë¹ ë¥¸ íŠ¸ëœì­ì…˜ ì²˜ë¦¬

ğŸ”— ìƒí˜¸ìš´ìš©ì„± (Interoperability)  
â”œâ”€â”€ EVM í† í°ê³¼ì˜ í˜¸í™˜ì„±
â”œâ”€â”€ í¬ë¡œìŠ¤ì²´ì¸ ë¸Œë¦¬ì§€ ì§€ì›
â”œâ”€â”€ DeFi í”„ë¡œí† ì½œ ë„¤ì´í‹°ë¸Œ í†µí•©
â””â”€â”€ í‘œì¤€í™”ëœ ì¸í„°í˜ì´ìŠ¤
```

### í•µì‹¬ ì•„í‚¤í…ì²˜
```move
// Movement Fungible Asset í•µì‹¬ êµ¬ì¡°
module fungible_asset_framework::advanced_fa {
    use aptos_framework::fungible_asset::{
        Self, 
        FungibleAsset, 
        Metadata, 
        MintRef, 
        TransferRef, 
        BurnRef
    };
    use aptos_framework::object::{Self, Object, ConstructorRef};
    use aptos_framework::primary_fungible_store;
    use std::string::{Self, String};
    use std::option::{Self, Option};
    use std::vector;
    use aptos_framework::timestamp;
    use aptos_framework::event::{Self, EventHandle};
    
    /// ê³ ê¸‰ í† í° ê´€ë¦¬ì
    struct AdvancedTokenManager has key {
        // ê¶Œí•œ ê´€ë¦¬
        mint_ref: MintRef,
        transfer_ref: TransferRef, 
        burn_ref: BurnRef,
        
        // í† í° ì •ë³´
        metadata: Object<Metadata>,
        creator: address,
        
        // ê³ ê¸‰ ê¸°ëŠ¥
        is_paused: bool,
        max_supply: Option<u64>,
        current_supply: u64,
        
        // ê¶Œí•œ ì œì–´
        minters: vector<address>,
        burners: vector<address>,
        transfer_controllers: vector<address>,
        
        // í† í°ê²½ì œí•™
        inflation_rate: u64,      // basis points per year
        deflation_rate: u64,      // basis points per transaction
        fee_on_transfer: u64,     // basis points
        fee_recipient: Option<address>,
        
        // ê±°ë²„ë„ŒìŠ¤
        governance_token: Option<Object<Metadata>>,
        voting_power_multiplier: u64,
        
        // ë©”íƒ€ë°ì´í„° í™•ì¥
        extended_metadata: ExtendedMetadata,
        
        // ì´ë²¤íŠ¸
        token_events: EventHandle<TokenEvent>,
        
        // í†µê³„
        total_minted: u64,
        total_burned: u64,
        unique_holders: u64,
        
        created_at: u64,
        last_updated: u64
    }
    
    /// í™•ì¥ ë©”íƒ€ë°ì´í„°
    struct ExtendedMetadata has store, drop, copy {
        // ê¸°ë³¸ ì •ë³´ í™•ì¥
        description: String,
        external_url: String,
        logo_url: String,
        banner_url: String,
        
        // ì¹´í…Œê³ ë¦¬ ë° íƒœê·¸
        category: String,  // "defi", "gaming", "utility", etc.
        tags: vector<String>,
        
        // ì†Œì…œ ë§í¬
        website: Option<String>,
        twitter: Option<String>,
        discord: Option<String>,
        telegram: Option<String>,
        
        // ê¸°ìˆ ì  ë©”íƒ€ë°ì´í„°
        contract_version: String,
        audit_reports: vector<String>,
        
        // í† í°ê²½ì œí•™ ì •ë³´
        initial_supply: u64,
        circulating_supply: u64,
        vesting_schedule: Option<VestingSchedule>,
        
        // ê±°ë˜ ì œí•œ
        transfer_restrictions: TransferRestrictions
    }
    
    /// ë² ìŠ¤íŒ… ìŠ¤ì¼€ì¤„
    struct VestingSchedule has store, drop, copy {
        cliff_duration: u64,        // í´ë¦¬í”„ ê¸°ê°„ (ì´ˆ)
        vesting_duration: u64,      // ì´ ë² ìŠ¤íŒ… ê¸°ê°„ (ì´ˆ)
        unlock_percentage: u64,     // ì¦‰ì‹œ ì–¸ë½ ë¹„ìœ¨ (basis points)
        linear_vesting: bool        // ì„ í˜• vs ë‹¨ê³„ì  ë² ìŠ¤íŒ…
    }
    
    /// ì „ì†¡ ì œí•œ
    struct TransferRestrictions has store, drop, copy {
        whitelist_enabled: bool,
        blacklist_enabled: bool,
        max_transfer_amount: Option<u64>,
        daily_transfer_limit: Option<u64>,
        require_kyc: bool,
        trading_start_time: Option<u64>
    }
    
    /// í† í° ì´ë²¤íŠ¸
    struct TokenEvent has drop, store {
        event_type: String,
        from: Option<address>,
        to: Option<address>,
        amount: u64,
        additional_data: String,
        timestamp: u64
    }
    
    /// ì‚¬ìš©ì í† í° ì •ë³´
    struct UserTokenInfo has key {
        // ë³´ìœ  ì •ë³´
        balance: u64,
        locked_balance: u64,
        
        // ë² ìŠ¤íŒ… ì •ë³´
        vested_amount: u64,
        vesting_start_time: u64,
        last_claim_time: u64,
        
        // ê±°ë˜ ì œí•œ
        daily_transferred: u64,
        last_transfer_date: u64,
        
        // KYC ìƒíƒœ
        kyc_verified: bool,
        whitelist_status: bool,
        
        // ìŠ¤í…Œì´í‚¹ ì •ë³´
        staked_amount: u64,
        staking_rewards: u64,
        last_reward_claim: u64
    }
    
    /// ê³ ê¸‰ í† í° ìƒì„±
    public fun create_advanced_token(
        creator: &signer,
        name: String,
        symbol: String,
        decimals: u8,
        icon_uri: String,
        project_uri: String,
        initial_supply: u64,
        max_supply: Option<u64>,    
        extended_metadata: ExtendedMetadata
    ): Object<Metadata> {
        let creator_addr = signer::address_of(creator);
        
        // ì…ë ¥ ê²€ì¦
        assert!(string::length(&name) > 0, E_INVALID_NAME);
        assert!(string::length(&symbol) > 0, E_INVALID_SYMBOL);
        assert!(decimals <= 18, E_INVALID_DECIMALS);
        
        if (option::is_some(&max_supply)) {
            let max_supply_val = *option::borrow(&max_supply);
            assert!(initial_supply <= max_supply_val, E_EXCEEDS_MAX_SUPPLY);
        };
        
        // í† í° ë©”íƒ€ë°ì´í„° ê°ì²´ ìƒì„±
        let constructor_ref = object::create_named_object(
            creator, 
            *string::bytes(&name)
        );
        
        // Fungible Asset ìƒì„±
        primary_fungible_store::create_primary_store_enabled_fungible_asset(
            &constructor_ref,
            option::some(initial_supply),
            name,
            symbol,
            decimals,
            icon_uri,
            project_uri
        );
        
        let metadata_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
        
        // ê¶Œí•œ ì°¸ì¡° ìƒì„±
        let mint_ref = fungible_asset::generate_mint_ref(&constructor_ref);
        let transfer_ref = fungible_asset::generate_transfer_ref(&constructor_ref);
        let burn_ref = fungible_asset::generate_burn_ref(&constructor_ref);
        
        // í† í° ê´€ë¦¬ì ìƒì„±
        let token_signer = object::generate_signer(&constructor_ref);
        let manager = AdvancedTokenManager {
            mint_ref,
            transfer_ref,
            burn_ref,
            metadata: metadata_obj,
            creator: creator_addr,
            is_paused: false,
            max_supply,
            current_supply: initial_supply,
            minters: vector::singleton(creator_addr),
            burners: vector::singleton(creator_addr),
            transfer_controllers: vector::singleton(creator_addr),
            inflation_rate: 0,
            deflation_rate: 0,
            fee_on_transfer: 0,
            fee_recipient: option::none(),
            governance_token: option::none(),
            voting_power_multiplier: 10000, // 1:1 ê¸°ë³¸ê°’
            extended_metadata,
            token_events: account::new_event_handle<TokenEvent>(&token_signer),
            total_minted: initial_supply,
            total_burned: 0,
            unique_holders: if (initial_supply > 0) 1 else 0,
            created_at: timestamp::now_seconds(),
            last_updated: timestamp::now_seconds()
        };
        
        move_to(&token_signer, manager);
        
        // ì´ˆê¸° ê³µê¸‰ëŸ‰ì„ ì°½ì‘ìì—ê²Œ ë°œí–‰
        if (initial_supply > 0) {
            let initial_fa = fungible_asset::mint(&mint_ref, initial_supply);
            primary_fungible_store::deposit(creator_addr, initial_fa);
            
            // ì‚¬ìš©ì ì •ë³´ ì´ˆê¸°í™”
            initialize_user_info(creator, metadata_obj, initial_supply);
        };
        
        metadata_obj
    }
    
    /// ì‚¬ìš©ì ì •ë³´ ì´ˆê¸°í™”
    fun initialize_user_info(
        user: &signer,
        token_metadata: Object<Metadata>,
        initial_amount: u64
    ) {
        let user_addr = signer::address_of(user);
        
        if (!exists<UserTokenInfo>(user_addr)) {
            let user_info = UserTokenInfo {
                balance: initial_amount,
                locked_balance: 0,
                vested_amount: 0,
                vesting_start_time: 0,
                last_claim_time: 0,
                daily_transferred: 0,
                last_transfer_date: 0,
                kyc_verified: false,
                whitelist_status: false,
                staked_amount: 0,
                staking_rewards: 0,
                last_reward_claim: 0
            };
            
            move_to(user, user_info);
        }
    }
    
    /// ê³ ê¸‰ í† í° ë¯¼íŒ… (ì¸í”Œë ˆì´ì…˜ ì œì–´ í¬í•¨)
    public fun advanced_mint(
        minter: &signer,
        token_metadata: Object<Metadata>,
        to: address,
        amount: u64,
        reason: String
    ) acquires AdvancedTokenManager, UserTokenInfo {
        let minter_addr = signer::address_of(minter);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global_mut<AdvancedTokenManager>(token_addr);
        
        // ê¶Œí•œ í™•ì¸
        assert!(
            vector::contains(&manager.minters, &minter_addr) || 
            minter_addr == manager.creator,
            E_NOT_AUTHORIZED_MINTER
        );
        
        // ì¼ì‹œì •ì§€ í™•ì¸
        assert!(!manager.is_paused, E_TOKEN_PAUSED);
        
        // ìµœëŒ€ ê³µê¸‰ëŸ‰ í™•ì¸
        if (option::is_some(&manager.max_supply)) {
            let max_supply = *option::borrow(&manager.max_supply);
            assert!(manager.current_supply + amount <= max_supply, E_EXCEEDS_MAX_SUPPLY);
        };
        
        // ì¸í”Œë ˆì´ì…˜ ì œì–´ í™•ì¸
        if (manager.inflation_rate > 0) {
            let time_since_creation = timestamp::now_seconds() - manager.created_at;
            let max_inflated_supply = calculate_max_inflated_supply(
                manager.total_minted,
                manager.inflation_rate,
                time_since_creation
            );
            assert!(manager.current_supply + amount <= max_inflated_supply, E_INFLATION_LIMIT_EXCEEDED);
        };
        
        // í† í° ë¯¼íŒ…
        let fa = fungible_asset::mint(&manager.mint_ref, amount);
        primary_fungible_store::deposit(to, fa);
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        manager.current_supply = manager.current_supply + amount;
        manager.total_minted = manager.total_minted + amount;
        manager.last_updated = timestamp::now_seconds();
        
        // ìƒˆë¡œìš´ í™€ë”ì¸ì§€ í™•ì¸
        let balance = primary_fungible_store::balance(to, token_metadata);
        if (balance == amount) { // ìƒˆë¡œìš´ í™€ë”
            manager.unique_holders = manager.unique_holders + 1;
        };
        
        // ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸
        if (!exists<UserTokenInfo>(to)) {
            let user_info = UserTokenInfo {
                balance: amount,
                locked_balance: 0,
                vested_amount: 0,
                vesting_start_time: 0,
                last_claim_time: 0,
                daily_transferred: 0,
                last_transfer_date: 0,
                kyc_verified: false,
                whitelist_status: false,
                staked_amount: 0,
                staking_rewards: 0,
                last_reward_claim: 0
            };
            move_to(&account::create_signer(to), user_info);
        } else {
            let user_info = borrow_global_mut<UserTokenInfo>(to);
            user_info.balance = user_info.balance + amount;
        };
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut manager.token_events, TokenEvent {
            event_type: string::utf8(b"mint"),
            from: option::none(),
            to: option::some(to),
            amount,
            additional_data: reason,
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ì¡°ê±´ë¶€ ì „ì†¡ (KYC, í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸, í•œë„ í™•ì¸)
    public fun conditional_transfer(
        from: &signer,
        token_metadata: Object<Metadata>,
        to: address,
        amount: u64
    ) acquires AdvancedTokenManager, UserTokenInfo {
        let from_addr = signer::address_of(from);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global_mut<AdvancedTokenManager>(token_addr);
        
        // ì¼ì‹œì •ì§€ í™•ì¸
        assert!(!manager.is_paused, E_TOKEN_PAUSED);
        
        // ì „ì†¡ ì œí•œ í™•ì¸
        let restrictions = &manager.extended_metadata.transfer_restrictions;
        
        // ê±°ë˜ ì‹œì‘ ì‹œê°„ í™•ì¸
        if (option::is_some(&restrictions.trading_start_time)) {
            let start_time = *option::borrow(&restrictions.trading_start_time);
            assert!(timestamp::now_seconds() >= start_time, E_TRADING_NOT_STARTED);
        };
        
        // ì‚¬ìš©ì ì •ë³´ í™•ì¸
        let from_info = if (exists<UserTokenInfo>(from_addr)) {
            borrow_global_mut<UserTokenInfo>(from_addr)
        } else {
            initialize_user_info(from, token_metadata, 0);
            borrow_global_mut<UserTokenInfo>(from_addr)
        };
        
        // KYC í™•ì¸
        if (restrictions.require_kyc) {
            assert!(from_info.kyc_verified, E_KYC_REQUIRED);
        };
        
        // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ í™•ì¸
        if (restrictions.whitelist_enabled) {
            assert!(from_info.whitelist_status, E_NOT_WHITELISTED);
        };
        
        // ìµœëŒ€ ì „ì†¡ ê¸ˆì•¡ í™•ì¸
        if (option::is_some(&restrictions.max_transfer_amount)) {
            let max_amount = *option::borrow(&restrictions.max_transfer_amount);
            assert!(amount <= max_amount, E_EXCEEDS_MAX_TRANSFER);
        };
        
        // ì¼ì¼ ì „ì†¡ í•œë„ í™•ì¸
        if (option::is_some(&restrictions.daily_transfer_limit)) {
            let current_date = timestamp::now_seconds() / (24 * 3600);
            if (from_info.last_transfer_date != current_date) {
                from_info.daily_transferred = 0;
                from_info.last_transfer_date = current_date;
            };
            
            let daily_limit = *option::borrow(&restrictions.daily_transfer_limit);
            assert!(from_info.daily_transferred + amount <= daily_limit, E_DAILY_LIMIT_EXCEEDED);
            from_info.daily_transferred = from_info.daily_transferred + amount;
        };
        
        // ì „ì†¡ ìˆ˜ìˆ˜ë£Œ ê³„ì‚°
        let fee_amount = (amount * manager.fee_on_transfer) / 10000;
        let transfer_amount = amount - fee_amount;
        
        // ì‹¤ì œ ì „ì†¡ ì‹¤í–‰
        let fa = primary_fungible_store::withdraw(from, token_metadata, amount);
        
        if (fee_amount > 0 && option::is_some(&manager.fee_recipient)) {
            let fee_recipient = *option::borrow(&manager.fee_recipient);
            let fee_fa = fungible_asset::extract(&mut fa, fee_amount);
            primary_fungible_store::deposit(fee_recipient, fee_fa);
        };
        
        primary_fungible_store::deposit(to, fa);
        
        // ë””í”Œë ˆì´ì…˜ ì²˜ë¦¬
        if (manager.deflation_rate > 0) {
            let burn_amount = (amount * manager.deflation_rate) / 10000;
            if (burn_amount > 0 && primary_fungible_store::balance(from_addr, token_metadata) >= burn_amount) {
                let burn_fa = primary_fungible_store::withdraw(from, token_metadata, burn_amount);
                fungible_asset::burn(&manager.burn_ref, burn_fa);
                
                manager.current_supply = manager.current_supply - burn_amount;
                manager.total_burned = manager.total_burned + burn_amount;
            }
        };
        
        // ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸
        from_info.balance = primary_fungible_store::balance(from_addr, token_metadata);
        
        // ë°›ëŠ” ì‚¬ëŒ ì •ë³´ ì—…ë°ì´íŠ¸
        if (!exists<UserTokenInfo>(to)) {
            initialize_user_info(&account::create_signer(to), token_metadata, transfer_amount);
        } else {
            let to_info = borrow_global_mut<UserTokenInfo>(to);
            to_info.balance = to_info.balance + transfer_amount;
        };
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut manager.token_events, TokenEvent {
            event_type: string::utf8(b"transfer"),
            from: option::some(from_addr),
            to: option::some(to),
            amount: transfer_amount,
            additional_data: string::utf8(b""),
            timestamp: timestamp::now_seconds()
        });
        
        if (fee_amount > 0) {
            event::emit_event(&mut manager.token_events, TokenEvent {
                event_type: string::utf8(b"fee"),
                from: option::some(from_addr),
                to: manager.fee_recipient,
                amount: fee_amount,
                additional_data: string::utf8(b"transfer_fee"),
                timestamp: timestamp::now_seconds()
            });
        }
    }
    
    /// ë² ìŠ¤íŒ… í† í° í´ë ˆì„
    public fun claim_vested_tokens(
        user: &signer,
        token_metadata: Object<Metadata>
    ) acquires AdvancedTokenManager, UserTokenInfo {
        let user_addr = signer::address_of(user);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global_mut<AdvancedTokenManager>(token_addr);
        
        assert!(exists<UserTokenInfo>(user_addr), E_USER_INFO_NOT_FOUND);
        let user_info = borrow_global_mut<UserTokenInfo>(user_addr);
        
        assert!(user_info.vested_amount > 0, E_NO_VESTED_TOKENS);
        
        let vesting_schedule = &manager.extended_metadata.vesting_schedule;
        assert!(option::is_some(vesting_schedule), E_NO_VESTING_SCHEDULE);
        
        let schedule = option::borrow(vesting_schedule);
        let current_time = timestamp::now_seconds();
        
        // í´ë¦¬í”„ ê¸°ê°„ í™•ì¸
        assert!(current_time >= user_info.vesting_start_time + schedule.cliff_duration, E_CLIFF_NOT_REACHED);
        
        // í´ë ˆì„ ê°€ëŠ¥í•œ ê¸ˆì•¡ ê³„ì‚°
        let claimable_amount = calculate_claimable_amount(user_info, schedule, current_time);
        assert!(claimable_amount > 0, E_NO_CLAIMABLE_TOKENS);
        
        // í† í° ë¯¼íŒ… ë° ì§€ê¸‰
        let fa = fungible_asset::mint(&manager.mint_ref, claimable_amount);
        primary_fungible_store::deposit(user_addr, fa);
        
        // ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸
        user_info.vested_amount = user_info.vested_amount - claimable_amount;
        user_info.last_claim_time = current_time;
        user_info.balance = user_info.balance + claimable_amount;
        
        // ê´€ë¦¬ì í†µê³„ ì—…ë°ì´íŠ¸
        manager.current_supply = manager.current_supply + claimable_amount;
        manager.total_minted = manager.total_minted + claimable_amount;
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut manager.token_events, TokenEvent {
            event_type: string::utf8(b"vesting_claim"),
            from: option::none(),
            to: option::some(user_addr),
            amount: claimable_amount,
            additional_data: string::utf8(b""),
            timestamp: current_time
        });
    }
    
    /// ìŠ¤í…Œì´í‚¹ ì‹œìŠ¤í…œ
    public fun stake_tokens(
        user: &signer,
        token_metadata: Object<Metadata>,
        amount: u64
    ) acquires AdvancedTokenManager, UserTokenInfo {
        let user_addr = signer::address_of(user);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global_mut<AdvancedTokenManager>(token_addr);
        
        assert!(exists<UserTokenInfo>(user_addr), E_USER_INFO_NOT_FOUND);
        let user_info = borrow_global_mut<UserTokenInfo>(user_addr);
        
        assert!(amount > 0, E_INVALID_AMOUNT);
        assert!(primary_fungible_store::balance(user_addr, token_metadata) >= amount, E_INSUFFICIENT_BALANCE);
        
        // í† í°ì„ ìŠ¤í…Œì´í‚¹ í’€ë¡œ ì´ë™ (ì‹¤ì œë¡œëŠ” ë½ì—…)
        let fa = primary_fungible_store::withdraw(user, token_metadata, amount);
        // ìŠ¤í…Œì´í‚¹ í’€ì— ì˜ˆì¹˜ (ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœíˆ ì†Œê°í•˜ê³  ê¸°ë¡ë§Œ ìœ ì§€)
        fungible_asset::burn(&manager.burn_ref, fa);
        
        // ê¸°ì¡´ ë³´ìƒ ì •ì‚°
        let pending_rewards = calculate_staking_rewards(user_info, timestamp::now_seconds());
        user_info.staking_rewards = user_info.staking_rewards + pending_rewards;
        
        // ìŠ¤í…Œì´í‚¹ ì •ë³´ ì—…ë°ì´íŠ¸
        user_info.staked_amount = user_info.staked_amount + amount;
        user_info.last_reward_claim = timestamp::now_seconds();
        user_info.locked_balance = user_info.locked_balance + amount;
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut manager.token_events, TokenEvent {
            event_type: string::utf8(b"stake"),
            from: option::some(user_addr),
            to: option::none(),
            amount,
            additional_data: string::utf8(b""),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ìŠ¤í…Œì´í‚¹ í•´ì œ
    public fun unstake_tokens(
        user: &signer,
        token_metadata: Object<Metadata>,
        amount: u64
    ) acquires AdvancedTokenManager, UserTokenInfo {
        let user_addr = signer::address_of(user);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global_mut<AdvancedTokenManager>(token_addr);
        
        assert!(exists<UserTokenInfo>(user_addr), E_USER_INFO_NOT_FOUND);
        let user_info = borrow_global_mut<UserTokenInfo>(user_addr);
        
        assert!(amount > 0, E_INVALID_AMOUNT);
        assert!(user_info.staked_amount >= amount, E_INSUFFICIENT_STAKED);
        
        // ë³´ìƒ ì •ì‚°
        let pending_rewards = calculate_staking_rewards(user_info, timestamp::now_seconds());
        user_info.staking_rewards = user_info.staking_rewards + pending_rewards;
        
        // ìŠ¤í…Œì´í‚¹ í•´ì œ (í† í° ì¬ë°œí–‰)
        let fa = fungible_asset::mint(&manager.mint_ref, amount);
        primary_fungible_store::deposit(user_addr, fa);
        
        // ìŠ¤í…Œì´í‚¹ ì •ë³´ ì—…ë°ì´íŠ¸
        user_info.staked_amount = user_info.staked_amount - amount;
        user_info.locked_balance = user_info.locked_balance - amount;
        user_info.last_reward_claim = timestamp::now_seconds();
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut manager.token_events, TokenEvent {
            event_type: string::utf8(b"unstake"),
            from: option::none(),
            to: option::some(user_addr),
            amount,
            additional_data: string::utf8(b""),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ìŠ¤í…Œì´í‚¹ ë³´ìƒ í´ë ˆì„
    public fun claim_staking_rewards(
        user: &signer,
        token_metadata: Object<Metadata>
    ) acquires AdvancedTokenManager, UserTokenInfo {
        let user_addr = signer::address_of(user);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global_mut<AdvancedTokenManager>(token_addr);
        
        assert!(exists<UserTokenInfo>(user_addr), E_USER_INFO_NOT_FOUND);
        let user_info = borrow_global_mut<UserTokenInfo>(user_addr);
        
        // ë³´ìƒ ê³„ì‚°
        let pending_rewards = calculate_staking_rewards(user_info, timestamp::now_seconds());
        let total_rewards = user_info.staking_rewards + pending_rewards;
        
        assert!(total_rewards > 0, E_NO_REWARDS);
        
        // ë³´ìƒ ì§€ê¸‰
        let reward_fa = fungible_asset::mint(&manager.mint_ref, total_rewards);
        primary_fungible_store::deposit(user_addr, reward_fa);
        
        // ë³´ìƒ ì •ë³´ ì´ˆê¸°í™”
        user_info.staking_rewards = 0;
        user_info.last_reward_claim = timestamp::now_seconds();
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        manager.current_supply = manager.current_supply + total_rewards;
        manager.total_minted = manager.total_minted + total_rewards;
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut manager.token_events, TokenEvent {
            event_type: string::utf8(b"reward_claim"),
            from: option::none(),
            to: option::some(user_addr),
            amount: total_rewards,
            additional_data: string::utf8(b"staking_reward"),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ê±°ë²„ë„ŒìŠ¤ íˆ¬í‘œë ¥ ê³„ì‚°
    public fun get_voting_power(
        user_addr: address,
        token_metadata: Object<Metadata>
    ): u64 acquires AdvancedTokenManager, UserTokenInfo {
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global<AdvancedTokenManager>(token_addr);
        
        if (!exists<UserTokenInfo>(user_addr)) {
            return 0
        };
        
        let user_info = borrow_global<UserTokenInfo>(user_addr);
        let base_balance = primary_fungible_store::balance(user_addr, token_metadata);
        
        // ê¸°ë³¸ íˆ¬í‘œë ¥ + ìŠ¤í…Œì´í‚¹ ë³´ë„ˆìŠ¤
        let voting_power = (base_balance * manager.voting_power_multiplier) / 10000 +
                          (user_info.staked_amount * manager.voting_power_multiplier * 2) / 10000; // ìŠ¤í…Œì´í‚¹ 2ë°° ë³´ë„ˆìŠ¤
        
        voting_power
    }
    
    /// í† í° ì¼ì‹œì •ì§€/ì¬ê°œ
    public fun set_pause_status(
        admin: &signer,
        token_metadata: Object<Metadata>,
        paused: bool
    ) acquires AdvancedTokenManager {
        let admin_addr = signer::address_of(admin);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global_mut<AdvancedTokenManager>(token_addr);
        
        assert!(admin_addr == manager.creator, E_NOT_AUTHORIZED);
        
        manager.is_paused = paused;
        manager.last_updated = timestamp::now_seconds();
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut manager.token_events, TokenEvent {
            event_type: if (paused) string::utf8(b"paused") else string::utf8(b"unpaused"),
            from: option::some(admin_addr),
            to: option::none(),
            amount: 0,
            additional_data: string::utf8(b""),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// KYC ìƒíƒœ ì—…ë°ì´íŠ¸
    public fun update_kyc_status(
        admin: &signer,
        token_metadata: Object<Metadata>,
        user_addr: address,
        kyc_verified: bool
    ) acquires AdvancedTokenManager, UserTokenInfo {
        let admin_addr = signer::address_of(admin);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global<AdvancedTokenManager>(token_addr);
        
        assert!(
            admin_addr == manager.creator || 
            vector::contains(&manager.transfer_controllers, &admin_addr),
            E_NOT_AUTHORIZED
        );
        
        if (!exists<UserTokenInfo>(user_addr)) {
            let user_info = UserTokenInfo {
                balance: 0,
                locked_balance: 0,
                vested_amount: 0,
                vesting_start_time: 0,
                last_claim_time: 0,
                daily_transferred: 0,
                last_transfer_date: 0,
                kyc_verified,
                whitelist_status: false,
                staked_amount: 0,
                staking_rewards: 0,
                last_reward_claim: 0
            };
            move_to(&account::create_signer(user_addr), user_info);
        } else {
            let user_info = borrow_global_mut<UserTokenInfo>(user_addr);
            user_info.kyc_verified = kyc_verified;
        }
    }
    
    /// í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê´€ë¦¬
    public fun update_whitelist_status(
        admin: &signer,
        token_metadata: Object<Metadata>,
        users: vector<address>,
        whitelisted: bool
    ) acquires AdvancedTokenManager, UserTokenInfo {
        let admin_addr = signer::address_of(admin);
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global<AdvancedTokenManager>(token_addr);
        
        assert!(
            admin_addr == manager.creator || 
            vector::contains(&manager.transfer_controllers, &admin_addr),
            E_NOT_AUTHORIZED
        );
        
        let i = 0;
        while (i < vector::length(&users)) {
            let user_addr = *vector::borrow(&users, i);
            
            if (!exists<UserTokenInfo>(user_addr)) {
                let user_info = UserTokenInfo {
                    balance: 0,
                    locked_balance: 0,
                    vested_amount: 0,
                    vesting_start_time: 0,
                    last_claim_time: 0,
                    daily_transferred: 0,
                    last_transfer_date: 0,
                    kyc_verified: false,
                    whitelist_status: whitelisted,
                    staked_amount: 0,
                    staking_rewards: 0,
                    last_reward_claim: 0
                };
                move_to(&account::create_signer(user_addr), user_info);
            } else {
                let user_info = borrow_global_mut<UserTokenInfo>(user_addr);
                user_info.whitelist_status = whitelisted;
            };
            
            i = i + 1;
        }
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤
    
    /// ìµœëŒ€ ì¸í”Œë ˆì´ì…˜ ê³µê¸‰ëŸ‰ ê³„ì‚°
    fun calculate_max_inflated_supply(
        initial_supply: u64,
        inflation_rate: u64,  // basis points per year
        time_elapsed: u64     // seconds
    ): u64 {
        let years_elapsed = time_elapsed / (365 * 24 * 3600);
        let inflation_factor = 10000 + (inflation_rate * years_elapsed);
        (initial_supply * inflation_factor) / 10000
    }
    
    /// ë² ìŠ¤íŒ… í´ë ˆì„ ê°€ëŠ¥ ê¸ˆì•¡ ê³„ì‚°
    fun calculate_claimable_amount(
        user_info: &UserTokenInfo,
        schedule: &VestingSchedule,
        current_time: u64
    ): u64 {
        let time_since_start = current_time - user_info.vesting_start_time;
        let time_since_cliff = time_since_start - schedule.cliff_duration;
        
        if (time_since_cliff < 0) {
            return 0
        };
        
        let total_vested = user_info.vested_amount;
        
        // ì¦‰ì‹œ ì–¸ë½ ë¶€ë¶„
        let immediate_unlock = (total_vested * schedule.unlock_percentage) / 10000;
        
        // ë² ìŠ¤íŒ… ë¶€ë¶„
        let vesting_amount = total_vested - immediate_unlock;
        
        let vested_portion = if (time_since_cliff >= schedule.vesting_duration) {
            vesting_amount
        } else if (schedule.linear_vesting) {
            (vesting_amount * time_since_cliff) / schedule.vesting_duration
        } else {
            // ë‹¨ê³„ì  ë² ìŠ¤íŒ… (ì›”ë³„)
            let months_passed = time_since_cliff / (30 * 24 * 3600);
            let total_months = schedule.vesting_duration / (30 * 24 * 3600);
            (vesting_amount * months_passed) / total_months
        };
        
        let total_claimable = immediate_unlock + vested_portion;
        
        // ì´ë¯¸ í´ë ˆì„í•œ ê¸ˆì•¡ ì œì™¸ ê³„ì‚° (ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ ìƒëµ)
        total_claimable
    }
    
    /// ìŠ¤í…Œì´í‚¹ ë³´ìƒ ê³„ì‚°
    fun calculate_staking_rewards(
        user_info: &UserTokenInfo,
        current_time: u64
    ): u64 {
        if (user_info.staked_amount == 0 || user_info.last_reward_claim >= current_time) {
            return 0
        };
        
        let time_elapsed = current_time - user_info.last_reward_claim;
        let annual_reward_rate = 1000; // 10% APY in basis points
        
        // ì—°ê°„ ë³´ìƒë¥ ì„ ì´ˆ ë‹¨ìœ„ë¡œ ë³€í™˜í•˜ì—¬ ê³„ì‚°
        let reward = (user_info.staked_amount * annual_reward_rate * time_elapsed) / 
                    (10000 * 365 * 24 * 3600);
        
        reward
    }
    
    // ì¡°íšŒ í•¨ìˆ˜ë“¤
    
    /// í† í° ê´€ë¦¬ì ì •ë³´ ì¡°íšŒ
    public fun get_token_manager_info(
        token_metadata: Object<Metadata>
    ): TokenManagerInfo acquires AdvancedTokenManager {
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global<AdvancedTokenManager>(token_addr);
        
        TokenManagerInfo {
            creator: manager.creator,
            is_paused: manager.is_paused,
            max_supply: manager.max_supply,
            current_supply: manager.current_supply,
            total_minted: manager.total_minted,
            total_burned: manager.total_burned,
            unique_holders: manager.unique_holders,
            inflation_rate: manager.inflation_rate,
            deflation_rate: manager.deflation_rate,
            fee_on_transfer: manager.fee_on_transfer,
            created_at: manager.created_at,
            last_updated: manager.last_updated
        }
    }
    
    /// ì‚¬ìš©ì í† í° ì •ë³´ ì¡°íšŒ
    public fun get_user_token_info(
        user_addr: address,
        token_metadata: Object<Metadata>
    ): Option<UserTokenInfo> acquires UserTokenInfo {
        if (exists<UserTokenInfo>(user_addr)) {
            let user_info = borrow_global<UserTokenInfo>(user_addr);
            option::some(*user_info)
        } else {
            option::none()
        }
    }
    
    /// í™•ì¥ ë©”íƒ€ë°ì´í„° ì¡°íšŒ
    public fun get_extended_metadata(
        token_metadata: Object<Metadata>
    ): ExtendedMetadata acquires AdvancedTokenManager {
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global<AdvancedTokenManager>(token_addr);
        manager.extended_metadata
    }
    
    /// í† í° í†µê³„ ì¡°íšŒ
    public fun get_token_statistics(
        token_metadata: Object<Metadata>
    ): TokenStatistics acquires AdvancedTokenManager {
        let token_addr = object::object_address(&token_metadata);
        let manager = borrow_global<AdvancedTokenManager>(token_addr);
        
        let total_supply = fungible_asset::supply(token_metadata);
        let circulating_supply = if (option::is_some(&total_supply)) {
            *option::borrow(&total_supply)
        } else {
            0
        };
        
        TokenStatistics {
            total_supply: circulating_supply,
            circulating_supply: manager.current_supply,
            max_supply: manager.max_supply,
            total_minted: manager.total_minted,
            total_burned: manager.total_burned,
            unique_holders: manager.unique_holders,
            market_cap: 0, // ì‹¤ì œë¡œëŠ” ì˜¤ë¼í´ì—ì„œ ê°€ê²© ì¡°íšŒ
            volume_24h: 0, // ì‹¤ì œë¡œëŠ” ë³„ë„ í†µê³„ ì‹œìŠ¤í…œì—ì„œ ì¡°íšŒ
            price_change_24h: 0
        }
    }
    
    // êµ¬ì¡°ì²´ ì •ì˜ë“¤
    
    struct TokenManagerInfo has drop {
        creator: address,
        is_paused: bool,
        max_supply: Option<u64>,
        current_supply: u64,
        total_minted: u64,
        total_burned: u64,
        unique_holders: u64,
        inflation_rate: u64,
        deflation_rate: u64,
        fee_on_transfer: u64,
        created_at: u64,
        last_updated: u64
    }
    
    struct TokenStatistics has drop {
        total_supply: u64,
        circulating_supply: u64,
        max_supply: Option<u64>,
        total_minted: u64,
        total_burned: u64,
        unique_holders: u64,
        market_cap: u64,
        volume_24h: u64,
        price_change_24h: i64
    }
    
    // ì—ëŸ¬ ì½”ë“œ
    const E_INVALID_NAME: u64 = 1;
    const E_INVALID_SYMBOL: u64 = 2;
    const E_INVALID_DECIMALS: u64 = 3;
    const E_EXCEEDS_MAX_SUPPLY: u64 = 4;
    const E_NOT_AUTHORIZED_MINTER: u64 = 5;
    const E_TOKEN_PAUSED: u64 = 6;
    const E_INFLATION_LIMIT_EXCEEDED: u64 = 7;
    const E_TRADING_NOT_STARTED: u64 = 8;
    const E_KYC_REQUIRED: u64 = 9;
    const E_NOT_WHITELISTED: u64 = 10;
    const E_EXCEEDS_MAX_TRANSFER: u64 = 11;
    const E_DAILY_LIMIT_EXCEEDED: u64 = 12;
    const E_USER_INFO_NOT_FOUND: u64 = 13;
    const E_NO_VESTED_TOKENS: u64 = 14;
    const E_NO_VESTING_SCHEDULE: u64 = 15;
    const E_CLIFF_NOT_REACHED: u64 = 16;
    const E_NO_CLAIMABLE_TOKENS: u64 = 17;
    const E_INVALID_AMOUNT: u64 = 18;
    const E_INSUFFICIENT_BALANCE: u64 = 19;
    const E_INSUFFICIENT_STAKED: u64 = 20;
    const E_NO_REWARDS: u64 = 21;
    const E_NOT_AUTHORIZED: u64 = 22;
}
```

## ğŸš€ TypeScript SDK í†µí•©

> *Complete SDK integration and automation features - Designed by bookiroad*

### Fungible Asset ê´€ë¦¬ í´ë˜ìŠ¤
```typescript
import {
  MovementAccount,
  MovementClient,
  Network,
  HexString
} from "@movementnetwork/ts-sdk";

interface TokenConfig {
  name: string;
  symbol: string;
  decimals: number;
  iconUri: string;
  projectUri: string;
  initialSupply: number;
  maxSupply?: number;
  extendedMetadata: ExtendedMetadata;
}

interface ExtendedMetadata {
  description: string;
  externalUrl: string;
  logoUrl: string;
  category: string;
  tags: string[];
  website?: string;
  twitter?: string;
  discord?: string;
  initialSupply: number;
  vestingSchedule?: VestingSchedule;
  transferRestrictions: TransferRestrictions;
}

interface VestingSchedule {
  cliffDuration: number;      // seconds
  vestingDuration: number;    // seconds
  unlockPercentage: number;   // basis points
  linearVesting: boolean;
}

interface TransferRestrictions {
  whitelistEnabled: boolean;
  blacklistEnabled: boolean;
  maxTransferAmount?: number;
  dailyTransferLimit?: number;
  requireKyc: boolean;
  tradingStartTime?: number;
}

class MovementTokenManager {
  private client: MovementClient;
  private moduleAddress: string;
  
  constructor(client: MovementClient, moduleAddress: string) {
    this.client = client;
    this.moduleAddress = moduleAddress;
  }
  
  // ê³ ê¸‰ í† í° ìƒì„±
  async createAdvancedToken(
    creator: MovementAccount,
    config: TokenConfig
  ): Promise<{
    tokenAddress: string;
    transactionHash: string;
    metadata: any;
  }> {
    const extendedMetadataBytes = this.serializeExtendedMetadata(config.extendedMetadata);
    
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::advanced_fa::create_advanced_token`,
      type_arguments: [],
      arguments: [
        config.name,
        config.symbol,
        config.decimals,
        config.iconUri,
        config.projectUri,
        config.initialSupply.toString(),
        config.maxSupply ? [config.maxSupply.toString()] : [],
        extendedMetadataBytes
      ]
    };
    
    const txn = await this.client.generateTransaction(creator.address(), payload);
    const signedTxn = await this.client.signTransaction(creator, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    
    // í† í° ì£¼ì†Œ ì¶”ì¶œ
    const tokenAddress = await this.extractTokenAddress(response.hash);
    
    return {
      tokenAddress,
      transactionHash: response.hash,
      metadata: config.extendedMetadata
    };
  }
  
  // ì¡°ê±´ë¶€ ë¯¼íŒ…
  async advancedMint(
    minter: MovementAccount,
    tokenAddress: string,
    to: string,
    amount: number,
    reason: string
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::advanced_fa::advanced_mint`,
      type_arguments: [],
      arguments: [
        tokenAddress,
        to,
        amount.toString(),
        reason
      ]
    };
    
    const txn = await this.client.generateTransaction(minter.address(), payload);
    const signedTxn = await this.client.signTransaction(minter, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ì¡°ê±´ë¶€ ì „ì†¡
  async conditionalTransfer(
    from: MovementAccount,
    tokenAddress: string,
    to: string,
    amount: number
  ): Promise<{
    success: boolean;
    transactionHash?: string;
    error?: string;
  }> {
    try {
      const payload = {
        type: "entry_function_payload",
        function: `${this.moduleAddress}::advanced_fa::conditional_transfer`,
        type_arguments: [],
        arguments: [
          tokenAddress,
          to,
          amount.toString()
        ]
      };
      
      const txn = await this.client.generateTransaction(from.address(), payload);
      const signedTxn = await this.client.signTransaction(from, txn);
      const response = await this.client.submitTransaction(signedTxn);
      
      await this.client.waitForTransaction(response.hash);
      
      return {
        success: true,
        transactionHash: response.hash
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  // ìŠ¤í…Œì´í‚¹
  async stakeTokens(
    user: MovementAccount,
    tokenAddress: string,
    amount: number
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::advanced_fa::stake_tokens`,
      type_arguments: [],
      arguments: [
        tokenAddress,
        amount.toString()
      ]
    };
    
    const txn = await this.client.generateTransaction(user.address(), payload);
    const signedTxn = await this.client.signTransaction(user, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ìŠ¤í…Œì´í‚¹ í•´ì œ
  async unstakeTokens(
    user: MovementAccount,
    tokenAddress: string,
    amount: number
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::advanced_fa::unstake_tokens`,
      type_arguments: [],
      arguments: [
        tokenAddress,
        amount.toString()
      ]
    };
    
    const txn = await this.client.generateTransaction(user.address(), payload);
    const signedTxn = await this.client.signTransaction(user, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // ë² ìŠ¤íŒ… í† í° í´ë ˆì„
  async claimVestedTokens(
    user: MovementAccount,
    tokenAddress: string
  ): Promise<{
    success: boolean;
    claimedAmount: number;
    transactionHash?: string;
  }> {
    try {
      const payload = {
        type: "entry_function_payload",
        function: `${this.moduleAddress}::advanced_fa::claim_vested_tokens`,
        type_arguments: [],
        arguments: [tokenAddress]
      };
      
      const txn = await this.client.generateTransaction(user.address(), payload);
      const signedTxn = await this.client.signTransaction(user, txn);
      const response = await this.client.submitTransaction(signedTxn);
      
      await this.client.waitForTransaction(response.hash);
      
      // ì´ë²¤íŠ¸ì—ì„œ í´ë ˆì„ëœ ê¸ˆì•¡ ì¶”ì¶œ
      const claimedAmount = await this.extractClaimedAmount(response.hash);
      
      return {
        success: true,
        claimedAmount,
        transactionHash: response.hash
      };
    } catch (error) {
      return {
        success: false,
        claimedAmount: 0
      };
    }
  }
  
  // ìŠ¤í…Œì´í‚¹ ë³´ìƒ í´ë ˆì„
  async claimStakingRewards(
    user: MovementAccount,
    tokenAddress: string
  ): Promise<{
    success: boolean;
    rewardAmount: number;
    transactionHash?: string;
  }> {
    try {
      const payload = {
        type: "entry_function_payload",
        function: `${this.moduleAddress}::advanced_fa::claim_staking_rewards`,
        type_arguments: [],
        arguments: [tokenAddress]
      };
      
      const txn = await this.client.generateTransaction(user.address(), payload);
      const signedTxn = await this.client.signTransaction(user, txn);
      const response = await this.client.submitTransaction(signedTxn);
      
      await this.client.waitForTransaction(response.hash);
      
      const rewardAmount = await this.extractRewardAmount(response.hash);
      
      return {
        success: true,
        rewardAmount,
        transactionHash: response.hash
      };
    } catch (error) {
      return {
        success: false,
        rewardAmount: 0
      };
    }
  }
  
  // ê±°ë²„ë„ŒìŠ¤ íˆ¬í‘œë ¥ ì¡°íšŒ
  async getVotingPower(
    userAddress: string,
    tokenAddress: string
  ): Promise<number> {
    const payload = {
      function: `${this.moduleAddress}::advanced_fa::get_voting_power`,
      type_arguments: [],
      arguments: [userAddress, tokenAddress]
    };
    
    try {
      const result = await this.client.view(payload);
      return parseInt(result[0] as string);
    } catch (error) {
      console.error("Failed to get voting power:", error);
      return 0;
    }
  }
  
  // KYC ìƒíƒœ ì—…ë°ì´íŠ¸ (ê´€ë¦¬ì ì „ìš©)
  async updateKycStatus(
    admin: MovementAccount,
    tokenAddress: string,
    userAddress: string,
    kycVerified: boolean
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::advanced_fa::update_kyc_status`,
      type_arguments: [],
      arguments: [
        tokenAddress,
        userAddress,
        kycVerified
      ]
    };
    
    const txn = await this.client.generateTransaction(admin.address(), payload);
    const signedTxn = await this.client.signTransaction(admin, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë°°ì¹˜ ì—…ë°ì´íŠ¸
  async batchUpdateWhitelist(
    admin: MovementAccount,
    tokenAddress: string,
    users: string[],
    whitelisted: boolean
  ): Promise<string> {
    const payload = {
      type: "entry_function_payload",
      function: `${this.moduleAddress}::advanced_fa::update_whitelist_status`,
      type_arguments: [],
      arguments: [
        tokenAddress,
        users,
        whitelisted
      ]
    };
    
    const txn = await this.client.generateTransaction(admin.address(), payload);
    const signedTxn = await this.client.signTransaction(admin, txn);
    const response = await this.client.submitTransaction(signedTxn);
    
    await this.client.waitForTransaction(response.hash);
    return response.hash;
  }
  
  // í† í° ì •ë³´ ì¡°íšŒ
  async getTokenInfo(tokenAddress: string): Promise<any> {
    const payload = {
      function: `${this.moduleAddress}::advanced_fa::get_token_manager_info`,
      type_arguments: [],
      arguments: [tokenAddress]
    };
    
    try {
      const result = await this.client.view(payload);
      return this.parseTokenManagerInfo(result[0]);
    } catch (error) {
      console.error("Failed to get token info:", error);
      return null;
    }
  }
  
  // ì‚¬ìš©ì í† í° ì •ë³´ ì¡°íšŒ
  async getUserTokenInfo(
    userAddress: string,
    tokenAddress: string
  ): Promise<any> {
    const payload = {
      function: `${this.moduleAddress}::advanced_fa::get_user_token_info`,
      type_arguments: [],
      arguments: [userAddress, tokenAddress]
    };
    
    try {
      const result = await this.client.view(payload);
      if (result && result[0]) {
        return this.parseUserTokenInfo(result[0]);
      }
      return null;
    } catch (error) {
      console.error("Failed to get user token info:", error);
      return null;
    }
  }
  
  // í† í° í†µê³„ ì¡°íšŒ
  async getTokenStatistics(tokenAddress: string): Promise<any> {
    const payload = {
      function: `${this.moduleAddress}::advanced_fa::get_token_statistics`,
      type_arguments: [],
      arguments: [tokenAddress]
    };
    
    try {
      const result = await this.client.view(payload);
      return this.parseTokenStatistics(result[0]);
    } catch (error) {
      console.error("Failed to get token statistics:", error);
      return null;
    }
  }
  
  // í† í° ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§
  async monitorTokenEvents(
    tokenAddress: string,
    callback: (event: any) => void,
    eventTypes?: string[]
  ): Promise<void> {
    // ì‹¤ì œë¡œëŠ” WebSocket ë˜ëŠ” pollingì„ í†µí•œ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§
    const pollInterval = 5000; // 5ì´ˆë§ˆë‹¤
    
    const poll = async () => {
      try {
        // ìµœê·¼ ì´ë²¤íŠ¸ ì¡°íšŒ
        const events = await this.getRecentEvents(tokenAddress, eventTypes);
        events.forEach(callback);
      } catch (error) {
        console.error("Failed to poll events:", error);
      }
      
      setTimeout(poll, pollInterval);
    };
    
    poll();
  }
  
  // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
  
  private serializeExtendedMetadata(metadata: ExtendedMetadata): any {
    return {
      description: metadata.description,
      external_url: metadata.externalUrl,
      logo_url: metadata.logoUrl,
      banner_url: "",
      category: metadata.category,
      tags: metadata.tags,
      website: metadata.website || "",
      twitter: metadata.twitter || "",
      discord: metadata.discord || "",
      telegram: "",
      contract_version: "1.0.0",
      audit_reports: [],
      initial_supply: metadata.initialSupply,
      circulating_supply: metadata.initialSupply,
      vesting_schedule: metadata.vestingSchedule ? {
        cliff_duration: metadata.vestingSchedule.cliffDuration,
        vesting_duration: metadata.vestingSchedule.vestingDuration,
        unlock_percentage: metadata.vestingSchedule.unlockPercentage,
        linear_vesting: metadata.vestingSchedule.linearVesting
      } : null,
      transfer_restrictions: {
        whitelist_enabled: metadata.transferRestrictions.whitelistEnabled,
        blacklist_enabled: metadata.transferRestrictions.blacklistEnabled,
        max_transfer_amount: metadata.transferRestrictions.maxTransferAmount || null,
        daily_transfer_limit: metadata.transferRestrictions.dailyTransferLimit || null,
        require_kyc: metadata.transferRestrictions.requireKyc,
        trading_start_time: metadata.transferRestrictions.tradingStartTime || null
      }
    };
  }
  
  private async extractTokenAddress(txHash: string): Promise<string> {
    // íŠ¸ëœì­ì…˜ ê²°ê³¼ì—ì„œ í† í° ì£¼ì†Œ ì¶”ì¶œ
    const txResult = await this.client.getTransactionByHash(txHash);
    // ì‹¤ì œë¡œëŠ” ì´ë²¤íŠ¸ë‚˜ ë³€ê²½ì‚¬í•­ì—ì„œ ì£¼ì†Œ ì¶”ì¶œ
    return "0x123..."; // placeholder
  }
  
  private async extractClaimedAmount(txHash: string): Promise<number> {
    // íŠ¸ëœì­ì…˜ ì´ë²¤íŠ¸ì—ì„œ í´ë ˆì„ëœ ê¸ˆì•¡ ì¶”ì¶œ
    return 1000; // placeholder
  }
  
  private async extractRewardAmount(txHash: string): Promise<number> {
    // íŠ¸ëœì­ì…˜ ì´ë²¤íŠ¸ì—ì„œ ë³´ìƒ ê¸ˆì•¡ ì¶”ì¶œ
    return 500; // placeholder
  }
  
  private parseTokenManagerInfo(data: any): any {
    return {
      creator: data.creator,
      isPaused: data.is_paused,
      maxSupply: data.max_supply,
      currentSupply: parseInt(data.current_supply),
      totalMinted: parseInt(data.total_minted),
      totalBurned: parseInt(data.total_burned),
      uniqueHolders: parseInt(data.unique_holders),
      inflationRate: parseInt(data.inflation_rate),
      deflationRate: parseInt(data.deflation_rate),
      feeOnTransfer: parseInt(data.fee_on_transfer),
      createdAt: parseInt(data.created_at),
      lastUpdated: parseInt(data.last_updated)
    };
  }
  
  private parseUserTokenInfo(data: any): any {
    return {
      balance: parseInt(data.balance),
      lockedBalance: parseInt(data.locked_balance),
      vestedAmount: parseInt(data.vested_amount),
      stakingRewards: parseInt(data.staking_rewards),
      stakedAmount: parseInt(data.staked_amount),
      kycVerified: data.kyc_verified,
      whitelistStatus: data.whitelist_status
    };
  }
  
  private parseTokenStatistics(data: any): any {
    return {
      totalSupply: parseInt(data.total_supply),
      circulatingSupply: parseInt(data.circulating_supply),
      maxSupply: data.max_supply,
      totalMinted: parseInt(data.total_minted),
      totalBurned: parseInt(data.total_burned),
      uniqueHolders: parseInt(data.unique_holders),
      marketCap: parseInt(data.market_cap),
      volume24h: parseInt(data.volume_24h),
      priceChange24h: parseInt(data.price_change_24h)
    };
  }
  
  private async getRecentEvents(
    tokenAddress: string,
    eventTypes?: string[]
  ): Promise<any[]> {
    // ì‹¤ì œë¡œëŠ” ì¸ë±ì„œë‚˜ ì´ë²¤íŠ¸ APIì—ì„œ ì¡°íšŒ
    return []; // placeholder
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
async function setupAdvancedToken() {
  const client = new MovementClient({ network: Network.DEVNET });
  const creator = new MovementAccount();
  const tokenManager = new MovementTokenManager(client, "0x1");
  
  // 1. ê³ ê¸‰ í† í° ìƒì„±
  const tokenConfig: TokenConfig = {
    name: "Advanced Governance Token",
    symbol: "AGT",
    decimals: 8,
    iconUri: "https://example.com/agt-icon.png",
    projectUri: "https://example.com/agt-project",
    initialSupply: 1000000 * 10**8, // 1M tokens
    maxSupply: 10000000 * 10**8,    // 10M max supply
    extendedMetadata: {
      description: "A governance token with advanced features",
      externalUrl: "https://example.com",
      logoUrl: "https://example.com/logo.png",
      category: "governance",
      tags: ["defi", "governance", "dao"],
      website: "https://example.com",
      twitter: "https://twitter.com/example",
      initialSupply: 1000000 * 10**8,
      vestingSchedule: {
        cliffDuration: 365 * 24 * 3600, // 1 year cliff
        vestingDuration: 4 * 365 * 24 * 3600, // 4 years vesting
        unlockPercentage: 1000, // 10% immediate unlock
        linearVesting: true
      },
      transferRestrictions: {
        whitelistEnabled: true,
        blacklistEnabled: false,
        maxTransferAmount: 100000 * 10**8, // 100K max per transfer
        dailyTransferLimit: 1000000 * 10**8, // 1M daily limit
        requireKyc: true,
        tradingStartTime: Date.now() / 1000 + 30 * 24 * 3600 // 30 days from now
      }
    }
  };
  
  const { tokenAddress } = await tokenManager.createAdvancedToken(creator, tokenConfig);
  console.log("Advanced token created:", tokenAddress);
  
  // 2. í† í° ì •ë³´ ì¡°íšŒ
  const tokenInfo = await tokenManager.getTokenInfo(tokenAddress);
  console.log("Token info:", tokenInfo);
  
  // 3. ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§ ì‹œì‘
  await tokenManager.monitorTokenEvents(
    tokenAddress,
    (event) => {
      console.log("Token event:", event);
    },
    ["mint", "transfer", "stake", "reward_claim"]
  );
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

Fungible Asset í”„ë ˆì„ì›Œí¬ë¥¼ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[Lending & Borrowing ì‹œìŠ¤í…œ â†’](/dapp-development/defi-development/lending-borrowing-system)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [Fungible Asset í‘œì¤€](https://docs.movementnetwork.xyz/fungible-assets)
- [í† í° ê²½ì œí•™ ê°€ì´ë“œ](https://docs.movementnetwork.xyz/tokenomics)

---

*Movement Networkì—ì„œ ì°¨ì„¸ëŒ€ í† í° ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸª™âœ¨*