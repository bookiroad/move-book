# ğŸ¦ Lending & Borrowing ì‹œìŠ¤í…œ

Movement Networkì—ì„œ ë‹´ë³´ ê¸°ë°˜ ëŒ€ì¶œ ë° ì°¨ìš© í”„ë¡œí† ì½œì„ êµ¬ì¶•í•˜ëŠ” ì™„ì „í•œ ê°€ì´ë“œì…ë‹ˆë‹¤. ë™ì  ì´ììœ¨ ëª¨ë¸ë¶€í„° ì²­ì‚° ë©”ì»¤ë‹ˆì¦˜ê¹Œì§€, ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ ê¸ˆìœµ ì„œë¹„ìŠ¤ë¥¼ ë§Œë“¤ì–´ë´…ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

ì´ ì„¹ì…˜ì„ ì™„ë£Œí•˜ë©´:
- ë‹´ë³´ ê¸°ë°˜ ëŒ€ì¶œ í”„ë¡œí† ì½œì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë™ì  ì´ììœ¨ ëª¨ë¸ì„ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ì²­ì‚° ë©”ì»¤ë‹ˆì¦˜ê³¼ ì¸ì„¼í‹°ë¸Œë¥¼ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œì„ ê°œë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- í”Œë˜ì‹œ ë¡ ê³¼ ê³ ê¸‰ ëŒ€ì¶œ ê¸°ëŠ¥ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ğŸ’° ë‹´ë³´ ê¸°ë°˜ ëŒ€ì¶œ í”„ë¡œí† ì½œ

### ì¢…í•© ëŒ€ì¶œ í”Œë«í¼ ì•„í‚¤í…ì²˜
```move
module lending_protocol::comprehensive_lending {
    use std::signer;
    use std::string::{Self, String};
    use std::vector;
    use std::option::{Self, Option};
    use aptos_framework::fungible_asset::{Self, FungibleAsset, Metadata};
    use aptos_framework::primary_fungible_store;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::timestamp;
    use aptos_framework::event::{Self, EventHandle};
    use aptos_std::smart_table::{Self, SmartTable};
    use aptos_std::math64;
    
    /// ì¢…í•© ëŒ€ì¶œ í”Œë«í¼
    struct LendingPlatform has key {
        // í”Œë«í¼ ì •ë³´
        admin: address,
        platform_name: String,
        
        // ì§€ì› ìì‚° ë° í’€
        supported_assets: SmartTable<Object<Metadata>, AssetConfig>,
        lending_pools: SmartTable<Object<Metadata>, LendingPool>,
        
        // ì‚¬ìš©ì í¬ì§€ì…˜
        user_positions: SmartTable<address, UserPosition>,
        
        // ì˜¤ë¼í´ ë° ê°€ê²© í”¼ë“œ
        price_oracles: SmartTable<Object<Metadata>, PriceOracle>,
        
        // ë¦¬ìŠ¤í¬ ê´€ë¦¬
        global_risk_params: GlobalRiskParameters,
        
        // í”„ë¡œí† ì½œ ì„¤ì •
        protocol_fee_rate: u64,        // basis points
        liquidation_incentive: u64,    // basis points
        close_factor: u64,            // í•œ ë²ˆì— ì²­ì‚° ê°€ëŠ¥í•œ ë¹„ìœ¨ (basis points)
        
        // í†µê³„
        total_supplied: u64,
        total_borrowed: u64,
        total_reserves: u64,
        
        // ì´ë²¤íŠ¸
        lending_events: EventHandle<LendingEvent>,
        
        // ê³ ê¸‰ ê¸°ëŠ¥
        flash_loan_enabled: bool,
        flash_loan_fee: u64,          // basis points
        
        // ê±°ë²„ë„ŒìŠ¤
        governance_token: Option<Object<Metadata>>,
        
        created_at: u64,
        last_updated: u64
    }
    
    /// ìì‚° ì„¤ì •
    struct AssetConfig has store, drop, copy {
        asset: Object<Metadata>,
        is_supported: bool,
        
        // ë‹´ë³´ ê´€ë ¨
        collateral_factor: u64,       // LTV (basis points)
        liquidation_threshold: u64,   // ì²­ì‚° ì„ê³„ê°’ (basis points)
        liquidation_bonus: u64,       // ì²­ì‚°ì ë³´ë„ˆìŠ¤ (basis points)
        
        // ê³µê¸‰ ì œí•œ
        supply_cap: Option<u64>,      // ìµœëŒ€ ê³µê¸‰ëŸ‰
        borrow_cap: Option<u64>,      // ìµœëŒ€ ì°¨ìš©ëŸ‰
        
        // ì´ììœ¨ ëª¨ë¸
        interest_rate_model: InterestRateModel,
        
        // ìˆ˜ìˆ˜ë£Œ ë° ì¤€ë¹„ê¸ˆ
        reserve_factor: u64,          // ì¤€ë¹„ê¸ˆ ë¹„ìœ¨ (basis points)
        
        // ìì‚°ë³„ ë¦¬ìŠ¤í¬ ê°€ì¤‘ì¹˜
        risk_weight: u64,
        
        created_at: u64,
        updated_at: u64
    }
    
    /// ì´ììœ¨ ëª¨ë¸
    struct InterestRateModel has store, drop, copy {
        model_type: u8,               // 0: linear, 1: kinked, 2: jump
        
        // ê¸°ë³¸ ë§¤ê°œë³€ìˆ˜
        base_rate: u64,               // ê¸°ë³¸ ì´ììœ¨ (basis points per year)
        multiplier: u64,              // ê¸°ìš¸ê¸° (basis points per year per utilization)
        
        // Jump ëª¨ë¸ìš© (ê³ í™œìš©ë¥ )
        jump_multiplier: Option<u64>, // ê³ í™œìš©ë¥  ê¸°ìš¸ê¸°
        kink: Option<u64>,            // ì „í™˜ì  í™œìš©ë¥  (basis points)
        
        // ë™ì  ì¡°ì •
        adaptive_enabled: bool,
        adjustment_factor: u64,       // ì¡°ì • ê³„ìˆ˜
        
        last_updated: u64
    }
    
    /// ëŒ€ì¶œ í’€
    struct LendingPool has store, drop, copy {
        asset: Object<Metadata>,
        
        // ìì‚° ë³´ìœ ëŸ‰
        total_cash: u64,              // ì‚¬ìš© ê°€ëŠ¥í•œ í˜„ê¸ˆ
        total_borrows: u64,           // ì´ ì°¨ìš©ëŸ‰
        total_reserves: u64,          // í”„ë¡œí† ì½œ ì¤€ë¹„ê¸ˆ
        
        // ì´ì ëˆ„ì 
        borrow_index: u128,           // ì°¨ìš© ì´ì ëˆ„ì  ì¸ë±ìŠ¤
        supply_index: u128,           // ê³µê¸‰ ì´ì ëˆ„ì  ì¸ë±ìŠ¤
        
        // í˜„ì¬ ì´ììœ¨
        current_borrow_rate: u64,     // ì—°ê°„ ì°¨ìš© ì´ììœ¨ (basis points)
        current_supply_rate: u64,     // ì—°ê°„ ê³µê¸‰ ì´ììœ¨ (basis points)
        
        // ì‹œê°„ ì¶”ì 
        last_update_timestamp: u64,
        
        // í’€ í†µê³„
        total_suppliers: u64,
        total_borrowers: u64,
        
        // ìœ ë™ì„± ë§ˆì´ë‹
        supply_rewards_per_second: u64,
        borrow_rewards_per_second: u64,
        reward_token: Option<Object<Metadata>>
    }
    
    /// ì‚¬ìš©ì í¬ì§€ì…˜
    struct UserPosition has store, drop, copy {
        user: address,
        
        // ê³µê¸‰ í¬ì§€ì…˜ (ìì‚°ë³„)
        supplied_assets: SmartTable<Object<Metadata>, SupplyPosition>,
        
        // ì°¨ìš© í¬ì§€ì…˜ (ìì‚°ë³„)
        borrowed_assets: SmartTable<Object<Metadata>, BorrowPosition>,
        
        // í—¬ìŠ¤ íŒ©í„°
        health_factor: u64,           // 10000 = 1.0 (ì•ˆì „)
        total_collateral_value: u64,  // USD ê¸°ì¤€
        total_borrow_value: u64,      // USD ê¸°ì¤€
        
        // ì‹ ìš© ì ìˆ˜
        credit_score: u64,            // 0-1000
        liquidation_history: vector<LiquidationRecord>,
        
        // ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸
        last_updated: u64
    }
    
    /// ê³µê¸‰ í¬ì§€ì…˜
    struct SupplyPosition has store, drop, copy {
        asset: Object<Metadata>,
        principal_amount: u64,        // ì›ê¸ˆ
        accrued_interest: u64,        // ëˆ„ì  ì´ì
        last_supply_index: u128,      // ë§ˆì§€ë§‰ ê³µê¸‰ ì¸ë±ìŠ¤
        
        // ë‹´ë³´ ì‚¬ìš© ì—¬ë¶€
        used_as_collateral: bool,
        
        // ë³´ìƒ
        unclaimed_rewards: u64,
        last_reward_index: u128,
        
        created_at: u64,
        last_updated: u64
    }
    
    /// ì°¨ìš© í¬ì§€ì…˜
    struct BorrowPosition has store, drop, copy {
        asset: Object<Metadata>,
        principal_amount: u64,        // ì›ê¸ˆ
        accrued_interest: u64,        // ëˆ„ì  ì´ì
        last_borrow_index: u128,      // ë§ˆì§€ë§‰ ì°¨ìš© ì¸ë±ìŠ¤
        
        // ì°¨ìš© ì¡°ê±´
        interest_rate_mode: u8,       // 0: variable, 1: stable
        stable_rate: Option<u64>,     // ê³ ì • ì´ììœ¨ (í•´ë‹¹í•˜ëŠ” ê²½ìš°)
        
        // ë³´ìƒ (ì°¨ìš© ì¸ì„¼í‹°ë¸Œ)
        unclaimed_rewards: u64,
        last_reward_index: u128,
        
        created_at: u64,
        last_updated: u64
    }
    
    /// ê°€ê²© ì˜¤ë¼í´
    struct PriceOracle has store, drop, copy {
        asset: Object<Metadata>,
        price_source: String,         // "chainlink", "pyth", "internal"
        price_feed_address: Option<address>,
        
        // ê°€ê²© ì •ë³´
        current_price: u64,           // USD price with 8 decimals
        last_update_time: u64,
        price_deviation_threshold: u64, // basis points
        
        // ê°€ê²© ê²€ì¦
        min_price: u64,
        max_price: u64,
        staleness_threshold: u64,     // seconds
        
        // ë°±ì—… ì˜¤ë¼í´
        backup_oracle: Option<address>
    }
    
    /// ê¸€ë¡œë²Œ ë¦¬ìŠ¤í¬ ë§¤ê°œë³€ìˆ˜
    struct GlobalRiskParameters has store, drop, copy {
        // ì‹œìŠ¤í…œ ì „ì²´ ì œí•œ
        max_ltv: u64,                 // ìµœëŒ€ LTV (basis points)
        liquidation_threshold: u64,   // ê¸€ë¡œë²Œ ì²­ì‚° ì„ê³„ê°’
        
        // ë¦¬ìŠ¤í¬ ê°€ì¤‘ ìì‚°
        total_risk_weighted_assets: u64,
        max_concentration_ratio: u64, // ë‹¨ì¼ ìì‚° ìµœëŒ€ ë¹„ì¤‘
        
        // ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ë§¤ê°œë³€ìˆ˜
        stress_test_scenarios: vector<StressTestScenario>,
        
        // ë¹„ìƒ ìƒí™© ëŒ€ì‘
        emergency_pause: bool,
        guardian_multisig: Option<address>
    }
    
    /// ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
    struct StressTestScenario has store, drop, copy {
        scenario_name: String,
        price_shock_percentage: u64,  // ê°€ê²© í•˜ë½ ì‹œë‚˜ë¦¬ì˜¤ (basis points)
        assets_affected: vector<Object<Metadata>>,
        expected_liquidation_ratio: u64
    }
    
    /// ì²­ì‚° ê¸°ë¡
    struct LiquidationRecord has store, drop, copy {
        liquidated_asset: Object<Metadata>,
        collateral_asset: Object<Metadata>,
        liquidated_amount: u64,
        collateral_seized: u64,
        liquidator: address,
        timestamp: u64,
        health_factor_before: u64,
        liquidation_bonus_received: u64
    }
    
    /// ëŒ€ì¶œ ì´ë²¤íŠ¸
    struct LendingEvent has drop, store {
        event_type: String,
        user: address,
        asset: Object<Metadata>,
        amount: u64,
        additional_data: String,
        timestamp: u64
    }
    
    /// ëŒ€ì¶œ í”Œë«í¼ ì´ˆê¸°í™”
    public fun initialize_lending_platform(
        admin: &signer,
        platform_name: String,
        protocol_fee_rate: u64,
        liquidation_incentive: u64
    ) {
        let admin_addr = signer::address_of(admin);
        
        // ì…ë ¥ ê²€ì¦
        assert!(protocol_fee_rate <= 1000, E_INVALID_FEE_RATE); // ìµœëŒ€ 10%
        assert!(liquidation_incentive <= 2000, E_INVALID_LIQUIDATION_INCENTIVE); // ìµœëŒ€ 20%
        
        let platform = LendingPlatform {
            admin: admin_addr,
            platform_name,
            supported_assets: smart_table::new(),
            lending_pools: smart_table::new(),
            user_positions: smart_table::new(),
            price_oracles: smart_table::new(),
            global_risk_params: GlobalRiskParameters {
                max_ltv: 8000, // 80%
                liquidation_threshold: 8500, // 85%
                total_risk_weighted_assets: 0,
                max_concentration_ratio: 3000, // 30%
                stress_test_scenarios: vector::empty(),
                emergency_pause: false,
                guardian_multisig: option::none()
            },
            protocol_fee_rate,
            liquidation_incentive,
            close_factor: 5000, // 50%
            total_supplied: 0,
            total_borrowed: 0,
            total_reserves: 0,
            lending_events: account::new_event_handle<LendingEvent>(admin),
            flash_loan_enabled: true,
            flash_loan_fee: 9, // 0.09%
            governance_token: option::none(),
            created_at: timestamp::now_seconds(),
            last_updated: timestamp::now_seconds()
        };
        
        move_to(admin, platform);
    }
    
    /// ìƒˆë¡œìš´ ìì‚° ì§€ì› ì¶”ê°€
    public fun add_supported_asset(
        admin: &signer,
        platform_addr: address,
        asset: Object<Metadata>,
        collateral_factor: u64,
        liquidation_threshold: u64,
        liquidation_bonus: u64,
        supply_cap: Option<u64>,
        borrow_cap: Option<u64>,
        interest_rate_model: InterestRateModel,
        initial_price: u64
    ) acquires LendingPlatform {
        let admin_addr = signer::address_of(admin);
        let platform = borrow_global_mut<LendingPlatform>(platform_addr);
        
        // ê¶Œí•œ í™•ì¸
        assert!(admin_addr == platform.admin, E_NOT_AUTHORIZED);
        
        // ë§¤ê°œë³€ìˆ˜ ê²€ì¦
        assert!(collateral_factor <= liquidation_threshold, E_INVALID_COLLATERAL_FACTOR);
        assert!(liquidation_threshold <= 9500, E_INVALID_LIQUIDATION_THRESHOLD); // ìµœëŒ€ 95%
        assert!(liquidation_bonus <= 2000, E_INVALID_LIQUIDATION_BONUS); // ìµœëŒ€ 20%
        
        let current_time = timestamp::now_seconds();
        
        // ìì‚° ì„¤ì • ìƒì„±
        let asset_config = AssetConfig {
            asset,
            is_supported: true,
            collateral_factor,
            liquidation_threshold,
            liquidation_bonus,
            supply_cap,
            borrow_cap,
            interest_rate_model,
            reserve_factor: 1000, // 10% ê¸°ë³¸ ì¤€ë¹„ê¸ˆ ë¹„ìœ¨
            risk_weight: 10000, // 100% ê¸°ë³¸ ë¦¬ìŠ¤í¬ ê°€ì¤‘ì¹˜
            created_at: current_time,
            updated_at: current_time
        };
        
        // ëŒ€ì¶œ í’€ ìƒì„±
        let lending_pool = LendingPool {
            asset,
            total_cash: 0,
            total_borrows: 0,
            total_reserves: 0,
            borrow_index: 1000000000000000000, // 1.0 with 18 decimals
            supply_index: 1000000000000000000, // 1.0 with 18 decimals
            current_borrow_rate: interest_rate_model.base_rate,
            current_supply_rate: 0,
            last_update_timestamp: current_time,
            total_suppliers: 0,
            total_borrowers: 0,
            supply_rewards_per_second: 0,
            borrow_rewards_per_second: 0,
            reward_token: option::none()
        };
        
        // ê°€ê²© ì˜¤ë¼í´ ì„¤ì •
        let price_oracle = PriceOracle {
            asset,
            price_source: string::utf8(b"internal"),
            price_feed_address: option::none(),
            current_price: initial_price,
            last_update_time: current_time,
            price_deviation_threshold: 500, // 5%
            min_price: initial_price / 10,   // ìµœì†Œ 10% of initial
            max_price: initial_price * 10,   // ìµœëŒ€ 10x of initial
            staleness_threshold: 3600, // 1 hour
            backup_oracle: option::none()
        };
        
        // í”Œë«í¼ì— ì¶”ê°€
        smart_table::add(&mut platform.supported_assets, asset, asset_config);
        smart_table::add(&mut platform.lending_pools, asset, lending_pool);
        smart_table::add(&mut platform.price_oracles, asset, price_oracle);
        
        platform.last_updated = current_time;
    }
    
    /// ìì‚° ê³µê¸‰ (ì˜ˆì¹˜)
    public fun supply_asset(
        supplier: &signer,
        platform_addr: address,
        asset: Object<Metadata>,
        amount: u64
    ) acquires LendingPlatform {
        let supplier_addr = signer::address_of(supplier);
        let platform = borrow_global_mut<LendingPlatform>(platform_addr);
        
        // ë¹„ìƒ ìƒí™© í™•ì¸
        assert!(!platform.global_risk_params.emergency_pause, E_EMERGENCY_PAUSE);
        
        // ì§€ì› ìì‚° í™•ì¸
        assert!(smart_table::contains(&platform.supported_assets, asset), E_ASSET_NOT_SUPPORTED);
        let asset_config = smart_table::borrow(&platform.supported_assets, asset);
        assert!(asset_config.is_supported, E_ASSET_NOT_SUPPORTED);
        
        // ê³µê¸‰ í•œë„ í™•ì¸
        if (option::is_some(&asset_config.supply_cap)) {
            let supply_cap = *option::borrow(&asset_config.supply_cap);
            let pool = smart_table::borrow(&platform.lending_pools, asset);
            assert!(pool.total_cash + amount <= supply_cap, E_SUPPLY_CAP_EXCEEDED);
        };
        
        // ì´ì ëˆ„ì 
        accrue_interest(platform, asset);
        
        // ìì‚° ì „ì†¡
        let fa = primary_fungible_store::withdraw(supplier, asset, amount);
        // í”Œë«í¼ìœ¼ë¡œ ì´ì „ (ì‹¤ì œë¡œëŠ” í”Œë«í¼ ì£¼ì†Œë¡œ)
        primary_fungible_store::deposit(platform_addr, fa);
        
        // í’€ ìƒíƒœ ì—…ë°ì´íŠ¸
        let pool = smart_table::borrow_mut(&mut platform.lending_pools, asset);
        pool.total_cash = pool.total_cash + amount;
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
        update_user_supply_position(platform, supplier_addr, asset, amount, true);
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        platform.total_supplied = platform.total_supplied + amount;
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut platform.lending_events, LendingEvent {
            event_type: string::utf8(b"supply"),
            user: supplier_addr,
            asset,
            amount,
            additional_data: string::utf8(b""),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ìì‚° ì°¨ìš©
    public fun borrow_asset(
        borrower: &signer,
        platform_addr: address,
        asset: Object<Metadata>,
        amount: u64,
        interest_rate_mode: u8
    ) acquires LendingPlatform {
        let borrower_addr = signer::address_of(borrower);
        let platform = borrow_global_mut<LendingPlatform>(platform_addr);
        
        // ë¹„ìƒ ìƒí™© í™•ì¸
        assert!(!platform.global_risk_params.emergency_pause, E_EMERGENCY_PAUSE);
        
        // ì§€ì› ìì‚° í™•ì¸
        assert!(smart_table::contains(&platform.supported_assets, asset), E_ASSET_NOT_SUPPORTED);
        let asset_config = smart_table::borrow(&platform.supported_assets, asset);
        
        // ì°¨ìš© í•œë„ í™•ì¸
        if (option::is_some(&asset_config.borrow_cap)) {
            let borrow_cap = *option::borrow(&asset_config.borrow_cap);
            let pool = smart_table::borrow(&platform.lending_pools, asset);
            assert!(pool.total_borrows + amount <= borrow_cap, E_BORROW_CAP_EXCEEDED);
        };
        
        // ì´ì ëˆ„ì 
        accrue_interest(platform, asset);
        
        // ìœ ë™ì„± í™•ì¸
        let pool = smart_table::borrow(&platform.lending_pools, asset);
        assert!(pool.total_cash >= amount, E_INSUFFICIENT_LIQUIDITY);
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ ë° í—¬ìŠ¤ íŒ©í„° í™•ì¸
        let user_position = get_or_create_user_position(platform, borrower_addr);
        let health_factor_after = calculate_health_factor_after_borrow(
            platform, 
            user_position, 
            asset, 
            amount
        );
        assert!(health_factor_after >= 10000, E_INSUFFICIENT_COLLATERAL); // >= 1.0
        
        // ìì‚° ì „ì†¡
        let fa = primary_fungible_store::withdraw(&account::create_signer(platform_addr), asset, amount);
        primary_fungible_store::deposit(borrower_addr, fa);
        
        // í’€ ìƒíƒœ ì—…ë°ì´íŠ¸
        let pool = smart_table::borrow_mut(&mut platform.lending_pools, asset);
        pool.total_cash = pool.total_cash - amount;
        pool.total_borrows = pool.total_borrows + amount;
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
        update_user_borrow_position(platform, borrower_addr, asset, amount, interest_rate_mode, true);
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        platform.total_borrowed = platform.total_borrowed + amount;
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut platform.lending_events, LendingEvent {
            event_type: string::utf8(b"borrow"),
            user: borrower_addr,
            asset,
            amount,
            additional_data: string::utf8(b""),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ì°¨ìš© ìƒí™˜
    public fun repay_borrow(
        borrower: &signer,
        platform_addr: address,
        asset: Object<Metadata>,
        amount: u64
    ) acquires LendingPlatform {
        let borrower_addr = signer::address_of(borrower);
        let platform = borrow_global_mut<LendingPlatform>(platform_addr);
        
        // ì´ì ëˆ„ì 
        accrue_interest(platform, asset);
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ í™•ì¸
        assert!(smart_table::contains(&platform.user_positions, borrower_addr), E_NO_BORROW_POSITION);
        let user_position = smart_table::borrow(&platform.user_positions, borrower_addr);
        assert!(smart_table::contains(&user_position.borrowed_assets, asset), E_NO_BORROW_POSITION);
        
        let borrow_position = smart_table::borrow(&user_position.borrowed_assets, asset);
        let total_debt = borrow_position.principal_amount + borrow_position.accrued_interest;
        
        // ì‹¤ì œ ìƒí™˜ ê¸ˆì•¡ ê³„ì‚° (ì „ì²´ ìƒí™˜ ì‹œ ì´ˆê³¼ ê¸ˆì•¡ ë°©ì§€)
        let actual_repay_amount = math64::min(amount, total_debt);
        
        // ìì‚° ì „ì†¡
        let fa = primary_fungible_store::withdraw(borrower, asset, actual_repay_amount);
        primary_fungible_store::deposit(platform_addr, fa);
        
        // í’€ ìƒíƒœ ì—…ë°ì´íŠ¸
        let pool = smart_table::borrow_mut(&mut platform.lending_pools, asset);
        pool.total_cash = pool.total_cash + actual_repay_amount;
        pool.total_borrows = pool.total_borrows - actual_repay_amount;
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
        update_user_borrow_position(platform, borrower_addr, asset, actual_repay_amount, 0, false);
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        platform.total_borrowed = platform.total_borrowed - actual_repay_amount;
        
        // ì”ì•¡ ë°˜í™˜
        if (amount > actual_repay_amount) {
            let refund_amount = amount - actual_repay_amount;
            let refund_fa = primary_fungible_store::withdraw(&account::create_signer(platform_addr), asset, refund_amount);
            primary_fungible_store::deposit(borrower_addr, refund_fa);
        };
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut platform.lending_events, LendingEvent {
            event_type: string::utf8(b"repay"),
            user: borrower_addr,
            asset,
            amount: actual_repay_amount,
            additional_data: string::utf8(b""),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ì²­ì‚° ì‹¤í–‰
    public fun liquidate_borrow(
        liquidator: &signer,
        platform_addr: address,
        borrower: address,
        debt_asset: Object<Metadata>,
        collateral_asset: Object<Metadata>,
        repay_amount: u64
    ) acquires LendingPlatform {
        let liquidator_addr = signer::address_of(liquidator);
        let platform = borrow_global_mut<LendingPlatform>(platform_addr);
        
        // ì´ì ëˆ„ì 
        accrue_interest(platform, debt_asset);
        accrue_interest(platform, collateral_asset);
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ í™•ì¸
        assert!(smart_table::contains(&platform.user_positions, borrower), E_NO_BORROW_POSITION);
        let user_position = smart_table::borrow_mut(&mut platform.user_positions, borrower);
        
        // í—¬ìŠ¤ íŒ©í„° í™•ì¸ (ì²­ì‚° ê°€ëŠ¥ ì—¬ë¶€)
        let health_factor = calculate_current_health_factor(platform, user_position);
        assert!(health_factor < 10000, E_POSITION_HEALTHY); // < 1.0ì¼ ë•Œë§Œ ì²­ì‚° ê°€ëŠ¥
        
        // ì²­ì‚° ê°€ëŠ¥ ê¸ˆì•¡ í™•ì¸
        let debt_position = smart_table::borrow(&user_position.borrowed_assets, debt_asset);
        let total_debt = debt_position.principal_amount + debt_position.accrued_interest;
        let max_liquidation_amount = (total_debt * platform.close_factor) / 10000;
        
        assert!(repay_amount <= max_liquidation_amount, E_LIQUIDATION_AMOUNT_TOO_HIGH);
        
        // ë‹´ë³´ ìì‚° í™•ì¸
        assert!(smart_table::contains(&user_position.supplied_assets, collateral_asset), E_NO_COLLATERAL);
        let collateral_position = smart_table::borrow(&user_position.supplied_assets, collateral_asset);
        assert!(collateral_position.used_as_collateral, E_COLLATERAL_NOT_ENABLED);
        
        // ì²­ì‚° ë³´ë„ˆìŠ¤ ê³„ì‚°
        let debt_asset_config = smart_table::borrow(&platform.supported_assets, debt_asset);
        let collateral_asset_config = smart_table::borrow(&platform.supported_assets, collateral_asset);
        
        let debt_price = get_asset_price(&platform.price_oracles, debt_asset);
        let collateral_price = get_asset_price(&platform.price_oracles, collateral_asset);
        
        let liquidation_bonus = collateral_asset_config.liquidation_bonus;
        let collateral_amount = calculate_collateral_amount(
            repay_amount,
            debt_price,
            collateral_price,
            liquidation_bonus
        );
        
        // ë‹´ë³´ ë¶€ì¡± í™•ì¸
        let total_collateral = collateral_position.principal_amount + collateral_position.accrued_interest;
        assert!(total_collateral >= collateral_amount, E_INSUFFICIENT_COLLATERAL_TO_SEIZE);
        
        // ì²­ì‚°ìë¡œë¶€í„° ë¶€ì±„ ìì‚° ë°›ê¸°
        let repay_fa = primary_fungible_store::withdraw(liquidator, debt_asset, repay_amount);
        primary_fungible_store::deposit(platform_addr, repay_fa);
        
        // ì²­ì‚°ìì—ê²Œ ë‹´ë³´ ìì‚° ì§€ê¸‰
        let collateral_fa = primary_fungible_store::withdraw(&account::create_signer(platform_addr), collateral_asset, collateral_amount);
        primary_fungible_store::deposit(liquidator_addr, collateral_fa);
        
        // í’€ ìƒíƒœ ì—…ë°ì´íŠ¸
        let debt_pool = smart_table::borrow_mut(&mut platform.lending_pools, debt_asset);
        debt_pool.total_cash = debt_pool.total_cash + repay_amount;
        debt_pool.total_borrows = debt_pool.total_borrows - repay_amount;
        
        let collateral_pool = smart_table::borrow_mut(&mut platform.lending_pools, collateral_asset);
        collateral_pool.total_cash = collateral_pool.total_cash - collateral_amount;
        
        // ì‚¬ìš©ì í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
        update_user_borrow_position(platform, borrower, debt_asset, repay_amount, 0, false);
        update_user_supply_position(platform, borrower, collateral_asset, collateral_amount, false);
        
        // ì²­ì‚° ê¸°ë¡ ì €ì¥
        let liquidation_record = LiquidationRecord {
            liquidated_asset: debt_asset,
            collateral_asset,
            liquidated_amount: repay_amount,
            collateral_seized: collateral_amount,
            liquidator: liquidator_addr,
            timestamp: timestamp::now_seconds(),
            health_factor_before: health_factor,
            liquidation_bonus_received: (collateral_amount * liquidation_bonus) / 10000
        };
        
        vector::push_back(&mut user_position.liquidation_history, liquidation_record);
        
        // ì‹ ìš© ì ìˆ˜ í•˜ë½
        if (user_position.credit_score > 100) {
            user_position.credit_score = user_position.credit_score - 100;
        };
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut platform.lending_events, LendingEvent {
            event_type: string::utf8(b"liquidation"),
            user: borrower,
            asset: debt_asset,
            amount: repay_amount,
            additional_data: object::object_address(&collateral_asset).to_string(),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// í”Œë˜ì‹œ ë¡ 
    public fun flash_loan(
        borrower: &signer,
        platform_addr: address,
        asset: Object<Metadata>,
        amount: u64,
        callback_target: address,
        callback_data: vector<u8>
    ) acquires LendingPlatform {
        let borrower_addr = signer::address_of(borrower);
        let platform = borrow_global_mut<LendingPlatform>(platform_addr);
        
        // í”Œë˜ì‹œ ë¡  í™œì„±í™” í™•ì¸
        assert!(platform.flash_loan_enabled, E_FLASH_LOAN_DISABLED);
        
        // ìœ ë™ì„± í™•ì¸
        let pool = smart_table::borrow(&platform.lending_pools, asset);
        let initial_balance = pool.total_cash;
        assert!(initial_balance >= amount, E_INSUFFICIENT_LIQUIDITY);
        
        // ìˆ˜ìˆ˜ë£Œ ê³„ì‚°
        let flash_loan_fee = (amount * platform.flash_loan_fee) / 10000;
        let total_owed = amount + flash_loan_fee;
        
        // ìì‚° ëŒ€ì¶œ
        let fa = primary_fungible_store::withdraw(&account::create_signer(platform_addr), asset, amount);
        primary_fungible_store::deposit(borrower_addr, fa);
        
        // ì½œë°± ì‹¤í–‰ (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ì½œë°± ë©”ì»¤ë‹ˆì¦˜ í•„ìš”)
        execute_flash_loan_callback(borrower_addr, callback_target, callback_data, asset, amount, total_owed);
        
        // ìƒí™˜ í™•ì¸
        let repay_fa = primary_fungible_store::withdraw(borrower, asset, total_owed);
        primary_fungible_store::deposit(platform_addr, repay_fa);
        
        // í’€ ìƒíƒœ ì—…ë°ì´íŠ¸
        let pool = smart_table::borrow_mut(&mut platform.lending_pools, asset);
        pool.total_cash = initial_balance + flash_loan_fee;
        pool.total_reserves = pool.total_reserves + flash_loan_fee;
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        platform.total_reserves = platform.total_reserves + flash_loan_fee;
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        event::emit_event(&mut platform.lending_events, LendingEvent {
            event_type: string::utf8(b"flash_loan"),
            user: borrower_addr,
            asset,
            amount,
            additional_data: flash_loan_fee.to_string(),
            timestamp: timestamp::now_seconds()
        });
    }
    
    /// ì´ì ëˆ„ì  ê³„ì‚°
    fun accrue_interest(platform: &mut LendingPlatform, asset: Object<Metadata>) {
        let pool = smart_table::borrow_mut(&mut platform.lending_pools, asset);
        let current_time = timestamp::now_seconds();
        let time_elapsed = current_time - pool.last_update_timestamp;
        
        if (time_elapsed > 0 && pool.total_borrows > 0) {
            // í˜„ì¬ ì´ììœ¨ ê³„ì‚°
            let asset_config = smart_table::borrow(&platform.supported_assets, asset);
            let utilization_rate = calculate_utilization_rate(pool);
            let borrow_rate = calculate_borrow_rate(&asset_config.interest_rate_model, utilization_rate);
            let supply_rate = calculate_supply_rate(borrow_rate, utilization_rate, asset_config.reserve_factor);
            
            // ì´ì ëˆ„ì 
            let borrow_interest = (pool.total_borrows * borrow_rate * time_elapsed) / (365 * 24 * 3600 * 10000);
            let supply_interest = (pool.total_cash * supply_rate * time_elapsed) / (365 * 24 * 3600 * 10000);
            
            // ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
            pool.borrow_index = pool.borrow_index + (pool.borrow_index * borrow_rate * time_elapsed) / (365 * 24 * 3600 * 10000);
            pool.supply_index = pool.supply_index + (pool.supply_index * supply_rate * time_elapsed) / (365 * 24 * 3600 * 10000);
            
            // í’€ ìƒíƒœ ì—…ë°ì´íŠ¸
            pool.total_borrows = pool.total_borrows + borrow_interest;
            pool.current_borrow_rate = borrow_rate;
            pool.current_supply_rate = supply_rate;
            
            // ì¤€ë¹„ê¸ˆ ì¦ê°€
            let reserve_increase = (borrow_interest * asset_config.reserve_factor) / 10000;
            pool.total_reserves = pool.total_reserves + reserve_increase;
            
            pool.last_update_timestamp = current_time;
        }
    }
    
    /// í™œìš©ë¥  ê³„ì‚°
    fun calculate_utilization_rate(pool: &LendingPool): u64 {
        let total_supply = pool.total_cash + pool.total_borrows;
        if (total_supply == 0) {
            0
        } else {
            (pool.total_borrows * 10000) / total_supply
        }
    }
    
    /// ì°¨ìš© ì´ììœ¨ ê³„ì‚°
    fun calculate_borrow_rate(model: &InterestRateModel, utilization_rate: u64): u64 {
        match (model.model_type) {
            0 => {  // Linear model
                model.base_rate + (model.multiplier * utilization_rate) / 10000
            },
            1 => {  // Kinked model
                if (option::is_some(&model.kink)) {
                    let kink = *option::borrow(&model.kink);
                    if (utilization_rate <= kink) {
                        model.base_rate + (model.multiplier * utilization_rate) / 10000
                    } else {
                        let normal_rate = model.base_rate + (model.multiplier * kink) / 10000;
                        let excess_utilization = utilization_rate - kink;
                        let jump_multiplier = *option::borrow(&model.jump_multiplier);
                        normal_rate + (jump_multiplier * excess_utilization) / 10000
                    }
                } else {
                    model.base_rate + (model.multiplier * utilization_rate) / 10000
                }
            },
            _ => model.base_rate  // Default to base rate
        }
    }
    
    /// ê³µê¸‰ ì´ììœ¨ ê³„ì‚°
    fun calculate_supply_rate(borrow_rate: u64, utilization_rate: u64, reserve_factor: u64): u64 {
        let rate_to_suppliers = borrow_rate - (borrow_rate * reserve_factor) / 10000;
        (rate_to_suppliers * utilization_rate) / 10000
    }
    
    /// í—¬ìŠ¤ íŒ©í„° ê³„ì‚°
    fun calculate_current_health_factor(
        platform: &LendingPlatform,
        user_position: &UserPosition
    ): u64 {
        if (user_position.total_borrow_value == 0) {
            return 100000 // ë¬´í•œëŒ€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” í° ê°’
        };
        
        let weighted_collateral_value = calculate_weighted_collateral_value(platform, user_position);
        (weighted_collateral_value * 10000) / user_position.total_borrow_value
    }
    
    /// ê°€ì¤‘ ë‹´ë³´ ê°€ì¹˜ ê³„ì‚°
    fun calculate_weighted_collateral_value(
        platform: &LendingPlatform,
        user_position: &UserPosition
    ): u64 {
        let mut total_weighted_value = 0;
        
        smart_table::for_each_ref(&user_position.supplied_assets, |asset, supply_position| {
            if (supply_position.used_as_collateral) {
                let asset_config = smart_table::borrow(&platform.supported_assets, *asset);
                let asset_price = get_asset_price(&platform.price_oracles, *asset);
                let position_value = (supply_position.principal_amount + supply_position.accrued_interest) * asset_price;
                let weighted_value = (position_value * asset_config.liquidation_threshold) / 10000;
                total_weighted_value = total_weighted_value + weighted_value;
            }
        });
        
        total_weighted_value
    }
    
    // í—¬í¼ í•¨ìˆ˜ë“¤ ê³„ì†...
    
    // ì¡°íšŒ í•¨ìˆ˜ë“¤
    
    /// ì‚¬ìš©ì í¬ì§€ì…˜ ì¡°íšŒ
    public fun get_user_position(
        platform_addr: address,
        user_addr: address
    ): Option<UserPosition> acquires LendingPlatform {
        let platform = borrow_global<LendingPlatform>(platform_addr);
        
        if (smart_table::contains(&platform.user_positions, user_addr)) {
            option::some(*smart_table::borrow(&platform.user_positions, user_addr))
        } else {
            option::none()
        }
    }
    
    /// ëŒ€ì¶œ í’€ ì •ë³´ ì¡°íšŒ
    public fun get_lending_pool_info(
        platform_addr: address,
        asset: Object<Metadata>
    ): Option<LendingPoolInfo> acquires LendingPlatform {
        let platform = borrow_global<LendingPlatform>(platform_addr);
        
        if (smart_table::contains(&platform.lending_pools, asset)) {
            let pool = smart_table::borrow(&platform.lending_pools, asset);
            let asset_config = smart_table::borrow(&platform.supported_assets, asset);
            
            option::some(LendingPoolInfo {
                asset,
                total_cash: pool.total_cash,
                total_borrows: pool.total_borrows,
                total_reserves: pool.total_reserves,
                current_borrow_rate: pool.current_borrow_rate,
                current_supply_rate: pool.current_supply_rate,
                utilization_rate: calculate_utilization_rate(pool),
                collateral_factor: asset_config.collateral_factor,
                liquidation_threshold: asset_config.liquidation_threshold,
                liquidation_bonus: asset_config.liquidation_bonus
            })
        } else {
            option::none()
        }
    }
    
    struct LendingPoolInfo has drop {
        asset: Object<Metadata>,
        total_cash: u64,
        total_borrows: u64,
        total_reserves: u64,
        current_borrow_rate: u64,
        current_supply_rate: u64,
        utilization_rate: u64,
        collateral_factor: u64,
        liquidation_threshold: u64,
        liquidation_bonus: u64
    }
    
    // ë” ë§ì€ í—¬í¼ í•¨ìˆ˜ë“¤ê³¼ ì—ëŸ¬ ì½”ë“œë“¤...
    
    // ì—ëŸ¬ ì½”ë“œ
    const E_NOT_AUTHORIZED: u64 = 1;
    const E_INVALID_FEE_RATE: u64 = 2;
    const E_INVALID_LIQUIDATION_INCENTIVE: u64 = 3;
    const E_ASSET_NOT_SUPPORTED: u64 = 4;
    const E_SUPPLY_CAP_EXCEEDED: u64 = 5;
    const E_BORROW_CAP_EXCEEDED: u64 = 6;
    const E_INSUFFICIENT_LIQUIDITY: u64 = 7;
    const E_INSUFFICIENT_COLLATERAL: u64 = 8;
    const E_NO_BORROW_POSITION: u64 = 9;
    const E_POSITION_HEALTHY: u64 = 10;
    const E_LIQUIDATION_AMOUNT_TOO_HIGH: u64 = 11;
    const E_NO_COLLATERAL: u64 = 12;
    const E_COLLATERAL_NOT_ENABLED: u64 = 13;
    const E_INSUFFICIENT_COLLATERAL_TO_SEIZE: u64 = 14;
    const E_FLASH_LOAN_DISABLED: u64 = 15;
    const E_EMERGENCY_PAUSE: u64 = 16;
    const E_INVALID_COLLATERAL_FACTOR: u64 = 17;
    const E_INVALID_LIQUIDATION_THRESHOLD: u64 = 18;
    const E_INVALID_LIQUIDATION_BONUS: u64 = 19;
}
```

## ğŸ§® ë™ì  ì´ììœ¨ ëª¨ë¸ êµ¬í˜„

> *Adaptive interest rate algorithms - Created by bookiroad*

### ê³ ê¸‰ ì´ììœ¨ ê³„ì‚° ì‹œìŠ¤í…œ
```move
module interest_rate_models::advanced_models {
    use std::math64;
    use aptos_framework::timestamp;
    
    /// ì ì‘í˜• ì´ììœ¨ ëª¨ë¸
    struct AdaptiveInterestRateModel has store, drop, copy {
        // ê¸°ë³¸ ë§¤ê°œë³€ìˆ˜
        base_rate: u64,
        slope1: u64,
        slope2: u64,
        optimal_utilization: u64,
        
        // ì ì‘í˜• ë§¤ê°œë³€ìˆ˜
        adaptive_enabled: bool,
        target_utilization: u64,     // ëª©í‘œ í™œìš©ë¥ 
        adjustment_factor: u64,      // ì¡°ì • ê³„ìˆ˜ (basis points)
        max_adjustment: u64,         // ìµœëŒ€ ì¡°ì • í­
        
        // ì‹œê°„ ê°€ì¤‘ í‰ê· 
        utilization_history: vector<UtilizationPoint>,
        history_window: u64,         // íˆìŠ¤í† ë¦¬ ìœˆë„ìš° (ì´ˆ)
        
        // ë³€ë™ì„± ì¡°ì •
        volatility_multiplier: u64,
        stress_multiplier: u64,      // ìŠ¤íŠ¸ë ˆìŠ¤ ìƒí™© ì‹œ ë°°ìˆ˜
        
        last_updated: u64
    }
    
    struct UtilizationPoint has store, drop, copy {
        utilization_rate: u64,
        timestamp: u64,
        market_stress_indicator: u64  // 0-10000 (0% - 100%)
    }
    
    /// ë™ì  ì´ììœ¨ ê³„ì‚°
    public fun calculate_dynamic_rates(
        model: &mut AdaptiveInterestRateModel,
        current_utilization: u64,
        total_borrows: u64,
        total_liquidity: u64
    ): (u64, u64) {  // (borrow_rate, supply_rate)
        let current_time = timestamp::now_seconds();
        
        // íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
        update_utilization_history(model, current_utilization, current_time);
        
        // ê¸°ë³¸ ì´ììœ¨ ê³„ì‚°
        let base_borrow_rate = calculate_base_rate(model, current_utilization);
        
        // ì ì‘í˜• ì¡°ì • ì ìš©
        let adjusted_borrow_rate = if (model.adaptive_enabled) {
            apply_adaptive_adjustment(model, base_borrow_rate, current_time)
        } else {
            base_borrow_rate
        };
        
        // ë³€ë™ì„± ì¡°ì •
        let final_borrow_rate = apply_volatility_adjustment(model, adjusted_borrow_rate);
        
        // ê³µê¸‰ ì´ììœ¨ ê³„ì‚° (ëŒ€ì¶œ ì´ììœ¨ì—ì„œ ì¤€ë¹„ê¸ˆ ë¹„ìœ¨ ì°¨ê°)
        let supply_rate = calculate_supply_rate_from_borrow(
            final_borrow_rate,
            current_utilization,
            1000  // 10% ì¤€ë¹„ê¸ˆ ë¹„ìœ¨
        );
        
        model.last_updated = current_time;
        
        (final_borrow_rate, supply_rate)
    }
    
    /// ê¸°ë³¸ ì´ììœ¨ ê³„ì‚° (Kinked ëª¨ë¸)
    fun calculate_base_rate(model: &AdaptiveInterestRateModel, utilization: u64): u64 {
        if (utilization <= model.optimal_utilization) {
            // ìµœì  í™œìš©ë¥  ì´í•˜: ì„ í˜• ì¦ê°€
            model.base_rate + (utilization * model.slope1) / model.optimal_utilization
        } else {
            // ìµœì  í™œìš©ë¥  ì´ˆê³¼: ê¸‰ê²©í•œ ì¦ê°€
            let base_rate_at_optimal = model.base_rate + model.slope1;
            let excess_utilization = utilization - model.optimal_utilization;
            let max_excess = 10000 - model.optimal_utilization;
            
            base_rate_at_optimal + (excess_utilization * model.slope2) / max_excess
        }
    }
    
    /// ì ì‘í˜• ì¡°ì • ì ìš©
    fun apply_adaptive_adjustment(
        model: &AdaptiveInterestRateModel,
        base_rate: u64,
        current_time: u64
    ): u64 {
        // ì‹œê°„ ê°€ì¤‘ í‰ê·  í™œìš©ë¥  ê³„ì‚°
        let avg_utilization = calculate_weighted_average_utilization(model, current_time);
        
        // ëª©í‘œ í™œìš©ë¥ ê³¼ì˜ í¸ì°¨ ê³„ì‚°
        let utilization_deviation = if (avg_utilization > model.target_utilization) {
            avg_utilization - model.target_utilization
        } else {
            model.target_utilization - avg_utilization
        };
        
        // ì¡°ì • í­ ê³„ì‚°
        let adjustment = math64::min(
            (utilization_deviation * model.adjustment_factor) / 10000,
            model.max_adjustment
        );
        
        // ëª©í‘œë³´ë‹¤ ë†’ìœ¼ë©´ ì´ììœ¨ ìƒìŠ¹, ë‚®ìœ¼ë©´ í•˜ë½
        if (avg_utilization > model.target_utilization) {
            base_rate + adjustment
        } else {
            if (base_rate > adjustment) {
                base_rate - adjustment
            } else {
                base_rate / 2  // ìµœì†Œ ì ˆë°˜ê¹Œì§€ë§Œ í•˜ë½
            }
        }
    }
    
    /// ë³€ë™ì„± ì¡°ì • ì ìš©
    fun apply_volatility_adjustment(
        model: &AdaptiveInterestRateModel,
        base_rate: u64
    ): u64 {
        // ìµœê·¼ í™œìš©ë¥  ë³€ë™ì„± ê³„ì‚°
        let volatility = calculate_utilization_volatility(model);
        
        // ì‹œì¥ ìŠ¤íŠ¸ë ˆìŠ¤ ì§€í‘œ
        let stress_level = calculate_market_stress(model);
        
        // ë³€ë™ì„± ê¸°ë°˜ ì¡°ì •
        let volatility_adjustment = (base_rate * volatility * model.volatility_multiplier) / (10000 * 10000);
        
        // ìŠ¤íŠ¸ë ˆìŠ¤ ê¸°ë°˜ ì¡°ì •
        let stress_adjustment = if (stress_level > 5000) {  // 50% ì´ìƒ
            (base_rate * model.stress_multiplier) / 10000
        } else {
            0
        };
        
        base_rate + volatility_adjustment + stress_adjustment
    }
    
    /// ì‹œê°„ ê°€ì¤‘ í‰ê·  í™œìš©ë¥  ê³„ì‚°
    fun calculate_weighted_average_utilization(
        model: &AdaptiveInterestRateModel,
        current_time: u64
    ): u64 {
        let history = &model.utilization_history;
        let window_start = current_time - model.history_window;
        
        let mut weighted_sum = 0;
        let mut total_weight = 0;
        let i = 0;
        
        while (i < vector::length(history)) {
            let point = vector::borrow(history, i);
            if (point.timestamp >= window_start) {
                let weight = current_time - point.timestamp + 1;  // ìµœì‹ ì¼ìˆ˜ë¡ ë†’ì€ ê°€ì¤‘ì¹˜
                weighted_sum = weighted_sum + (point.utilization_rate * weight);
                total_weight = total_weight + weight;
            };
            i = i + 1;
        };
        
        if (total_weight > 0) {
            weighted_sum / total_weight
        } else {
            0
        }
    }
    
    /// í™œìš©ë¥  ë³€ë™ì„± ê³„ì‚°
    fun calculate_utilization_volatility(model: &AdaptiveInterestRateModel): u64 {
        let history = &model.utilization_history;
        let len = vector::length(history);
        
        if (len < 2) {
            return 0
        };
        
        // í‘œì¤€í¸ì°¨ ê³„ì‚°ì„ ìœ„í•œ í‰ê· 
        let mut sum = 0;
        let i = 0;
        while (i < len) {
            let point = vector::borrow(history, i);
            sum = sum + point.utilization_rate;
            i = i + 1;
        };
        let mean = sum / len;
        
        // ë¶„ì‚° ê³„ì‚°
        let mut variance_sum = 0;
        let i = 0;
        while (i < len) {
            let point = vector::borrow(history, i);
            let diff = if (point.utilization_rate > mean) {
                point.utilization_rate - mean
            } else {
                mean - point.utilization_rate
            };
            variance_sum = variance_sum + (diff * diff);
            i = i + 1;
        };
        
        let variance = variance_sum / len;
        math64::sqrt(variance)  // í‘œì¤€í¸ì°¨ = ë³€ë™ì„±
    }
    
    /// ì‹œì¥ ìŠ¤íŠ¸ë ˆìŠ¤ ì§€í‘œ ê³„ì‚°
    fun calculate_market_stress(model: &AdaptiveInterestRateModel): u64 {
        let history = &model.utilization_history;
        let len = vector::length(history);
        
        if (len == 0) {
            return 0
        };
        
        let mut stress_sum = 0;
        let i = 0;
        while (i < len) {
            let point = vector::borrow(history, i);
            stress_sum = stress_sum + point.market_stress_indicator;
            i = i + 1;
        };
        
        stress_sum / len  // í‰ê·  ìŠ¤íŠ¸ë ˆìŠ¤ ë ˆë²¨
    }
    
    /// í™œìš©ë¥  íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
    fun update_utilization_history(
        model: &mut AdaptiveInterestRateModel,
        current_utilization: u64,
        current_time: u64
    ) {
        // ì‹œì¥ ìŠ¤íŠ¸ë ˆìŠ¤ ì§€í‘œ ê³„ì‚° (ê°„ë‹¨í•œ ì˜ˆì‹œ)
        let stress_indicator = if (current_utilization > 9000) {  // 90% ì´ìƒ
            8000  // ë†’ì€ ìŠ¤íŠ¸ë ˆìŠ¤
        } else if (current_utilization > 7000) {  // 70% ì´ìƒ
            5000  // ì¤‘ê°„ ìŠ¤íŠ¸ë ˆìŠ¤
        } else {
            2000  // ë‚®ì€ ìŠ¤íŠ¸ë ˆìŠ¤
        };
        
        let new_point = UtilizationPoint {
            utilization_rate: current_utilization,
            timestamp: current_time,
            market_stress_indicator: stress_indicator
        };
        
        vector::push_back(&mut model.utilization_history, new_point);
        
        // ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬ (ìœˆë„ìš° ë°–ì˜ ë°ì´í„° ì œê±°)
        let window_start = current_time - model.history_window;
        let mut i = 0;
        while (i < vector::length(&model.utilization_history)) {
            let point = vector::borrow(&model.utilization_history, i);
            if (point.timestamp < window_start) {
                vector::remove(&mut model.utilization_history, i);
            } else {
                i = i + 1;
            }
        }
    }
    
    /// ê³µê¸‰ ì´ììœ¨ ê³„ì‚°
    fun calculate_supply_rate_from_borrow(
        borrow_rate: u64,
        utilization_rate: u64,
        reserve_factor: u64
    ): u64 {
        let net_rate = borrow_rate - (borrow_rate * reserve_factor) / 10000;
        (net_rate * utilization_rate) / 10000
    }
}
```

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

Lending & Borrowing ì‹œìŠ¤í…œì„ ë§ˆìŠ¤í„°í–ˆë‹¤ë©´:

**[DEX & AMM êµ¬í˜„ â†’](/dapp-development/defi-development/dex-amm-implementation)**

## ğŸ“š ì°¸ê³  ìë£Œ

- [Movement ê°œë°œì í¬í„¸](https://developer.movementnetwork.xyz/)
- [DeFi ëŒ€ì¶œ í”„ë¡œí† ì½œ ê°€ì´ë“œ](https://docs.movementnetwork.xyz/defi-lending)
- [ì´ììœ¨ ëª¨ë¸ ì„¤ê³„](https://docs.movementnetwork.xyz/interest-rate-models)

---

*Movement Networkì—ì„œ ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ ëŒ€ì¶œ í”„ë¡œí† ì½œì„ êµ¬ì¶•í•˜ì„¸ìš”! ğŸ¦ğŸ’°*